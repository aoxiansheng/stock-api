# 监控组件说明文档

## 📋 概述

监控组件是一个**事件驱动**的系统监控解决方案，提供完整的性能监控、健康检查、趋势分析和指标收集功能。采用现代化的架构设计，实现了组件解耦、高性能处理和生产级的稳定性。

### 🎯 核心特性

- **🔄 事件驱动架构**：完全基于事件通信，消除组件间循环依赖
- **⚡ 高性能批处理**：智能事件聚合，支持背压控制，处理能力 >1000 events/sec
- **🛡️ 错误隔离**：监控失败不影响业务逻辑，优雅降级机制
- **📊 完整监控覆盖**：API请求、缓存操作、数据库查询、系统指标
- **🔍 实时健康检查**：多维度健康评分，智能趋势分析
- **🎛️ 自监控能力**：监控组件自身性能和健康状态

---

## 🏗️ 架构组成

### 核心服务层次

```
┌─────────────────────────────────────────────────────┐
│                   业务组件层                          │
│  (Core Components, Providers, Controllers, etc.)   │
└─────────────────┬───────────────────────────────────┘
                  │ 发送事件
                  ▼
┌─────────────────────────────────────────────────────┐
│                监控事件总线                          │
│             (EventEmitter2)                        │
└─────────────────┬───────────────────────────────────┘
                  │ 事件分发
                  ▼
┌─────────────────────────────────────────────────────┐
│               监控组件核心层                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐     │
│  │事件桥接服务 │ │ 缓存服务    │ │ 收集器服务  │     │
│  │EventBridge │ │ Cache       │ │ Collector   │     │
│  └─────────────┘ └─────────────┘ └─────────────┘     │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐     │
│  │ 分析器服务  │ │ 健康检查    │ │ 展示器服务  │     │
│  │ Analyzer    │ │ Health      │ │ Presenter   │     │
│  └─────────────┘ └─────────────┘ └─────────────┘     │
└─────────────────┬───────────────────────────────────┘
                  │ 指标输出
                  ▼
┌─────────────────────────────────────────────────────┐
│            外部监控系统                              │
│        (Prometheus, Grafana, AlertManager)         │
└─────────────────────────────────────────────────────┘
```

### 主要组件说明

| 组件 | 位置 | 职责 | 特性 |
|------|-----|------|------|
| **EventBridge** | `infrastructure/bridge/` | 事件到指标转换 | 批处理、背压控制、错误隔离 |
| **Collector** | `collector/` | 原始数据收集 | 纯数据收集、事件发送 |
| **Analyzer** | `analyzer/` | 数据分析计算 | 事件驱动、缓存优化 |
| **Cache** | `cache/` | 监控专用缓存 | 事件化、性能监控 |
| **Health** | `health/` | 健康状态检查 | 多维度评分、趋势分析 |
| **Presenter** | `presenter/` | 数据展示接口 | REST API、格式化输出 |

---

## 🔧 组件功能详解

### 1. 事件桥接服务 (MonitoringEventBridgeService)

**核心功能**：将系统事件转换为 Prometheus 指标

```typescript
// 自动注册的事件处理器
@OnEvent(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED)
@OnEvent(SYSTEM_STATUS_EVENTS.CACHE_HIT)
@OnEvent(SYSTEM_STATUS_EVENTS.CACHE_MISS)
@OnEvent(SYSTEM_STATUS_EVENTS.API_REQUEST_COMPLETED)
// ... 更多事件类型
```

**特性**：
- ✅ 智能批处理：100ms间隔或100个事件自动刷新
- ✅ 背压控制：队列满时自动丢弃事件，保护系统稳定
- ✅ 错误隔离：事件处理失败不影响业务流程
- ✅ 指标聚合：相同类型事件自动聚合减少Prometheus压力

### 2. 数据收集服务 (CollectorService)

**核心功能**：收集原始监控数据并发送事件

```typescript
// 主要收集方法
recordRequest(endpoint, method, statusCode, duration, metadata?)
recordDatabaseOperation(operation, duration, success, metadata?)
recordCacheOperation(operation, hit, duration, metadata?)
recordSystemMetrics(metrics)
```

**特性**：
- ✅ 纯数据收集：不包含计算逻辑，职责单一
- ✅ 事件发送：每次记录自动发送 METRIC_COLLECTED 事件
- ✅ 缓冲区管理：内存缓冲+定期持久化
- ✅ 事件驱动交互：通过 DATA_REQUEST/RESPONSE 事件与分析层通信

### 3. 数据分析服务 (AnalyzerService)

**核心功能**：基于原始数据进行性能分析和健康评分

```typescript
// 主要分析方法
getPerformanceAnalysis(options?: AnalysisOptions): Promise<PerformanceAnalysisDto>
getHealthScore(): Promise<number>
getHealthReport(): Promise<HealthReportDto>
calculateTrends(period: string): Promise<TrendsDto>
getOptimizationSuggestions(): Promise<SuggestionDto[]>
```

**特性**：
- ✅ 完全事件驱动：通过事件请求数据，消除直接依赖
- ✅ 智能缓存：热点数据自动缓存，支持分布式锁
- ✅ 多维分析：性能、健康、趋势、优化建议
- ✅ 异步处理：5秒超时保护，资源自动清理

### 4. 监控缓存服务 (MonitoringCacheService)

**核心功能**：为监控组件提供专用缓存能力

```typescript
// 分类缓存API
getOrSetHealthData<T>(key: string, factory: () => Promise<T>): Promise<T>
getOrSetTrendData<T>(key: string, factory: () => Promise<T>): Promise<T>
getOrSetPerformanceData<T>(key: string, factory: () => Promise<T>): Promise<T>

// 批量管理API
invalidateHealthCache(): Promise<void>
invalidateTrendCache(): Promise<void>
healthCheck(): Promise<{status, metrics}>
```

**特性**：
- ✅ 专用优化：针对监控数据特性的TTL策略
- ✅ 事件集成：缓存操作自动发送事件
- ✅ 性能监控：P95/P99延迟统计，命中率监控
- ✅ 故障恢复：Redis故障时自动降级，不影响功能

### 5. API监控拦截器 (ApiMonitoringInterceptor)

**核心功能**：自动捕获API请求生命周期

```typescript
// 自动捕获的事件
API_REQUEST_STARTED    // 请求开始
API_REQUEST_COMPLETED  // 请求成功完成  
API_REQUEST_ERROR      // 请求错误
```

**特性**：
- ✅ 全自动：无需手动埋点，自动捕获所有API请求
- ✅ 非阻塞：异步事件发送，零性能影响
- ✅ 丰富元数据：IP、User-Agent、响应大小、处理时间等
- ✅ 智能过滤：自动跳过健康检查等内部端点

---

## 📚 使用方式指南

### 1. 基础集成 - 模块导入

```typescript
// app.module.ts
import { MonitoringModule } from '@monitoring/monitoring.module';

@Module({
  imports: [
    MonitoringModule, // 导入监控模块
    // ... 其他模块
  ],
})
export class AppModule {}
```

```typescript
// main.ts - 全局拦截器
import { ApiMonitoringInterceptor } from '@monitoring/infrastructure/interceptors/api-monitoring.interceptor';

async function bootstrap() {
  const app = await NestJSFactory.create(AppModule);
  
  // 注册API监控拦截器（自动监控所有API请求）
  const apiMonitoringInterceptor = app.get(ApiMonitoringInterceptor);
  app.useGlobalInterceptors(apiMonitoringInterceptor);
  
  await app.listen(3000);
}
```

### 2. 数据收集 - 在业务组件中使用

#### 方式一：直接注入CollectorService（推荐）

```typescript
import { CollectorService } from '@monitoring/collector/collector.service';

@Injectable()
export class UserService {
  constructor(
    private readonly collectorService: CollectorService,
  ) {}

  async createUser(userData: CreateUserDto) {
    const startTime = Date.now();
    
    try {
      const result = await this.userRepository.save(userData);
      
      // 记录成功的数据库操作
      this.collectorService.recordDatabaseOperation(
        'create_user',
        Date.now() - startTime,
        true,
        { userId: result.id, userType: userData.type }
      );
      
      return result;
    } catch (error) {
      // 记录失败的数据库操作
      this.collectorService.recordDatabaseOperation(
        'create_user',
        Date.now() - startTime,
        false,
        { error: error.message, userType: userData.type }
      );
      throw error;
    }
  }
}
```

#### 方式二：发送自定义事件（高级用法）

```typescript
import { EventEmitter2 } from '@nestjs/event-emitter';
import { SYSTEM_STATUS_EVENTS } from '@monitoring/contracts/events/system-status.events';

@Injectable()
export class PaymentService {
  constructor(
    private readonly eventBus: EventEmitter2,
  ) {}

  async processPayment(paymentData: PaymentDto) {
    const startTime = Date.now();
    
    try {
      const result = await this.paymentProcessor.process(paymentData);
      
      // 发送自定义业务事件
      this.eventBus.emit(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED, {
        timestamp: new Date(),
        source: 'payment',
        metricType: 'business',
        metricName: 'payment_processed',
        metricValue: paymentData.amount,
        tags: {
          payment_method: paymentData.method,
          currency: paymentData.currency,
          status: 'success',
          provider: 'stripe'
        }
      });
      
      return result;
    } catch (error) {
      // 发送错误事件
      this.eventBus.emit(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED, {
        timestamp: new Date(),
        source: 'payment',
        metricType: 'business',
        metricName: 'payment_failed',
        metricValue: 1,
        tags: {
          payment_method: paymentData.method,
          error_type: error.constructor.name,
          provider: 'stripe'
        }
      });
      throw error;
    }
  }
}
```

### 3. 性能分析 - 获取监控数据

```typescript
import { AnalyzerService } from '@monitoring/analyzer/analyzer.service';

@Controller('admin/monitoring')
export class AdminMonitoringController {
  constructor(
    private readonly analyzerService: AnalyzerService,
  ) {}

  // 获取系统性能分析报告
  @Get('performance')
  async getPerformanceReport() {
    return await this.analyzerService.getPerformanceAnalysis({
      startTime: new Date(Date.now() - 24 * 60 * 60 * 1000), // 最近24小时
      includeDetails: true
    });
  }

  // 获取健康评分
  @Get('health/score')
  async getHealthScore() {
    const score = await this.analyzerService.getHealthScore();
    return { score, status: score > 70 ? 'healthy' : score > 40 ? 'warning' : 'critical' };
  }

  // 获取优化建议
  @Get('suggestions')
  async getOptimizationSuggestions() {
    return await this.analyzerService.getOptimizationSuggestions();
  }

  // 获取趋势分析
  @Get('trends/:period')
  async getTrends(@Param('period') period: string) {
    return await this.analyzerService.calculateTrends(period); // '1h', '6h', '1d', '7d'
  }
}
```

### 4. 缓存操作 - 监控专用缓存

```typescript
import { MonitoringCacheService } from '@monitoring/cache/monitoring-cache.service';

@Injectable()
export class DashboardService {
  constructor(
    private readonly monitoringCache: MonitoringCacheService,
  ) {}

  // 使用健康数据缓存
  async getSystemHealthStatus() {
    return await this.monitoringCache.getOrSetHealthData(
      'system_status',
      async () => {
        // 复杂的健康状态计算
        const cpuUsage = await this.getCPUUsage();
        const memoryUsage = await this.getMemoryUsage();
        const diskUsage = await this.getDiskUsage();
        
        return {
          cpu: cpuUsage,
          memory: memoryUsage,
          disk: diskUsage,
          overall: this.calculateOverallHealth(cpuUsage, memoryUsage, diskUsage)
        };
      }
    );
  }

  // 使用趋势数据缓存
  async getPerformanceTrends(period: string) {
    return await this.monitoringCache.getOrSetTrendData(
      `performance_trends_${period}`,
      async () => {
        return await this.calculatePerformanceTrends(period);
      }
    );
  }
}
```

### 5. 装饰器方式 - 自动性能监控

```typescript
import { PerformanceMonitoring } from '@common/core/decorators/performance-monitoring.decorator';

@Injectable()
export class StockDataService {
  
  // 自动监控方法性能
  @PerformanceMonitoring({
    operation: 'get_stock_quote',
    layer: 'service',
    includeArgs: false,
    includeResult: false
  })
  async getStockQuote(symbol: string): Promise<StockQuote> {
    // 业务逻辑...
    // 装饰器自动记录执行时间和成功/失败状态
    return await this.dataProvider.fetchQuote(symbol);
  }

  @PerformanceMonitoring({
    operation: 'batch_stock_update',
    layer: 'service',
    metricTags: { operation_type: 'batch', provider: 'internal' }
  })
  async batchUpdateStocks(symbols: string[]): Promise<void> {
    // 批量处理逻辑...
    // 自动记录批次大小、处理时间等指标
  }
}
```

---

## 🔍 监控端点和查询

### REST API 端点

监控组件提供标准的 REST API 访问接口：

```bash
# 基础路径: /api/monitoring

# 获取性能分析报告
GET /api/monitoring/performance
GET /api/monitoring/performance?startTime=2024-01-01T00:00:00Z&endTime=2024-01-02T00:00:00Z

# 健康检查相关
GET /api/monitoring/health
GET /api/monitoring/health/score
GET /api/monitoring/health/report

# 趋势分析
GET /api/monitoring/trends/1h    # 最近1小时趋势
GET /api/monitoring/trends/1d    # 最近1天趋势
GET /api/monitoring/trends/7d    # 最近7天趋势

# 优化建议
GET /api/monitoring/suggestions

# 缓存管理
POST /api/monitoring/cache/invalidate
POST /api/monitoring/cache/invalidate?pattern=health

# 组件状态
GET /api/monitoring/status
GET /api/monitoring/metrics/cache-stats
```

### 响应数据格式

```typescript
// 性能分析响应
interface PerformanceAnalysisDto {
  timestamp: string;
  summary: {
    totalRequests: number;
    averageResponseTimeMs: number;
    errorRate: number;
    throughput: number;
  };
  healthScore: number;
  trends?: TrendsDto;
  endpointMetrics?: EndpointMetricsDto[];
  // ... 更多字段
}

// 健康报告响应
interface HealthReportDto {
  overall: {
    score: number;
    status: 'healthy' | 'warning' | 'critical';
    timestamp: string;
  };
  components: {
    api: ComponentHealthDto;
    database: ComponentHealthDto;
    cache: ComponentHealthDto;
    system: ComponentHealthDto;
  };
  recommendations?: string[];
}

// 趋势分析响应
interface TrendsDto {
  responseTime: TrendMetric;
  errorRate: TrendMetric;
  throughput: TrendMetric;
}

interface TrendMetric {
  current: number;
  previous: number;
  trend: 'up' | 'down' | 'stable';
  changePercentage: number;
}
```

---

## 📊 Prometheus 指标说明

监控组件自动向 Prometheus 发送以下指标类型：

### 核心业务指标
```bash
# HTTP请求指标
receiver_requests_total{method="GET|POST|PUT|DELETE", status="200|404|500", provider="api", operation="endpoint"}
receiver_processing_duration_seconds{method, provider, operation, status, attempt}
receiver_active_connections{connection_type="api|websocket"}
receiver_error_rate{error_type}

# 数据库指标  
storage_operations_total{operation="create|read|update|delete", storage_type="mongodb|redis"}
storage_query_duration_seconds{query_type, storage_type}
storage_data_volume{data_type, storage_type}

# 缓存指标
storage_cache_efficiency{cache_type="monitoring|smart|symbol", operation}
```

### 监控自监控指标
```bash
# 事件处理指标
monitoring_events_processed_total{event_type, status}
monitoring_events_dropped_total{reason}
monitoring_batch_processing_duration_seconds
monitoring_queue_utilization_percent

# 缓存性能指标
monitoring_cache_hit_rate{cache_type}
monitoring_cache_operation_duration_seconds{operation}
```

### 查询示例
```promql
# API请求成功率
rate(receiver_requests_total{status!~"4..|5.."}[5m]) / rate(receiver_requests_total[5m])

# 平均响应时间
rate(receiver_processing_duration_seconds_sum[5m]) / rate(receiver_processing_duration_seconds_count[5m])

# 缓存命中率
rate(storage_cache_efficiency{cache_type="monitoring"}[5m])

# 事件处理性能
rate(monitoring_events_processed_total[5m])
```

---

## ⚙️ 配置选项

### 环境变量配置

```bash
# 事件处理配置
MONITORING_BATCH_SIZE=100                    # 批处理大小
MONITORING_FLUSH_INTERVAL_MS=100            # 刷新间隔(毫秒)
MONITORING_MAX_QUEUE_SIZE=10000             # 最大队列大小
MONITORING_REQUEST_TIMEOUT_MS=5000          # 数据请求超时

# 缓存配置
MONITORING_CACHE_TTL_HEALTH=30              # 健康数据TTL(秒)
MONITORING_CACHE_TTL_TREND=300              # 趋势数据TTL(秒)
MONITORING_CACHE_TTL_PERFORMANCE=60         # 性能数据TTL(秒)
MONITORING_CACHE_COMPRESSION_THRESHOLD=1024  # 压缩阈值(字节)

# 自监控配置
MONITORING_SELF_CHECK_INTERVAL=60000        # 自检间隔(毫秒)
MONITORING_FALLBACK_THRESHOLD=10            # 回退次数告警阈值
```

### 代码配置

```typescript
// monitoring.config.ts
export const getMonitoringConfigForEnvironment = (): MonitoringConfig => ({
  cache: {
    namespace: 'monitoring',
    ttl: {
      health: 30,      // 健康数据缓存30秒
      trend: 300,      // 趋势数据缓存5分钟
      performance: 60, // 性能数据缓存1分钟
      alert: 120,      // 告警数据缓存2分钟
      cacheStats: 60   // 缓存统计1分钟
    },
    compressionThreshold: 1024,
    batchSize: 50,
    keyIndexPrefix: 'monitoring:index',
    fallbackThreshold: 10
  },
  events: {
    batchSize: 100,
    flushInterval: 100,
    maxQueueSize: 10000,
    requestTimeout: 5000
  }
});
```

---

## 🚨 错误处理和故障排除

### 常见问题和解决方案

#### 1. 事件队列满告警
```bash
# 症状
WARN: 事件批处理队列已满，事件被丢弃 {reason: 'queue_full', droppedCount: 42}

# 解决方案
# 1. 增大队列大小
MONITORING_MAX_QUEUE_SIZE=20000

# 2. 减少批处理间隔
MONITORING_FLUSH_INTERVAL_MS=50

# 3. 检查事件发送频率是否异常
```

#### 2. 缓存服务不可用
```bash
# 症状
WARN: 监控缓存操作失败，降级处理 {error: 'Redis connection lost'}

# 处理
# 监控组件自动降级，不影响业务
# 检查Redis连接状态，修复后自动恢复
```

#### 3. 数据请求超时
```bash
# 症状  
ERROR: 数据请求超时 {requestId: 'analyzer_1234', timeout: 5000}

# 解决方案
# 1. 增加超时时间
MONITORING_REQUEST_TIMEOUT_MS=10000

# 2. 检查CollectorService是否正常响应事件
# 3. 查看事件总线是否有阻塞
```

### 健康检查端点

```bash
# 检查监控组件整体健康状态
curl -X GET http://localhost:3000/api/monitoring/status

# 检查缓存服务健康状态  
curl -X GET http://localhost:3000/api/monitoring/cache/health

# 检查事件批处理器状态
curl -X GET http://localhost:3000/api/monitoring/events/health
```

### 调试模式

```bash
# 启用调试日志
LOG_LEVEL=debug npm run start

# 或者只启用监控组件调试
DEBUG=monitoring:* npm run start
```

---

## 🔧 开发指南

### 扩展监控功能

#### 1. 添加新的事件类型

```typescript
// 1. 在 system-status.events.ts 中添加新事件
export const SYSTEM_STATUS_EVENTS = {
  // ... 现有事件
  CUSTOM_BUSINESS_EVENT: 'system-status.custom.business.event',
} as const;

// 2. 在 MonitoringEventBridgeService 中添加处理器
@OnEvent(SYSTEM_STATUS_EVENTS.CUSTOM_BUSINESS_EVENT)
handleCustomBusinessEvent(event: any) {
  try {
    // 处理自定义事件，映射到Prometheus指标
    this.metricsRegistry.customBusinessMetric.inc({
      business_type: event.businessType,
      operation: event.operation
    });
  } catch (error) {
    this.logger.debug('自定义事件处理失败', error.message);
  }
}
```

#### 2. 添加新的分析功能

```typescript
// 1. 创建专业分析服务
@Injectable()
export class CustomAnalyzerService {
  async generateCustomReport(rawMetrics: any): Promise<CustomReportDto> {
    // 自定义分析逻辑
    return customReport;
  }
}

// 2. 集成到主分析器
@Injectable()
export class AnalyzerService {
  constructor(
    // ... 现有依赖
    private readonly customAnalyzer: CustomAnalyzerService,
  ) {}

  async getCustomAnalysis(): Promise<CustomReportDto> {
    const rawMetrics = await this.requestRawMetrics();
    return await this.customAnalyzer.generateCustomReport(rawMetrics);
  }
}
```

### 性能优化建议

#### 1. 批处理参数调优
```typescript
// 根据业务特征调整参数
// 高频场景：减少间隔，增加批次大小
const highFrequencyConfig = {
  flushIntervalMs: 50,
  maxBatchSize: 200,
  maxQueueSize: 20000
};

// 低频场景：增加间隔，减少批次大小
const lowFrequencyConfig = {
  flushIntervalMs: 500,
  maxBatchSize: 50,
  maxQueueSize: 5000
};
```

#### 2. 缓存策略优化
```typescript
// 根据数据特征调整TTL
const adaptiveTtlStrategy = {
  // 快速变化的数据：短TTL
  realtimeMetrics: 5,
  
  // 中等变化的数据：中等TTL
  healthScores: 30,
  
  // 慢速变化的数据：长TTL
  systemConfig: 300,
  
  // 历史数据：超长TTL
  historicalTrends: 3600
};
```

---

## 📈 监控最佳实践

### 1. 事件发送最佳实践

```typescript
// ✅ 推荐：异步发送，不阻塞主流程
async processOrder(order: OrderDto) {
  try {
    const result = await this.orderProcessor.process(order);
    
    // 异步发送监控事件
    setImmediate(() => {
      this.eventBus.emit(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED, {
        // 事件数据...
      });
    });
    
    return result;
  } catch (error) {
    // 错误情况也要发送监控事件
    setImmediate(() => {
      this.eventBus.emit(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED, {
        // 错误事件数据...
      });
    });
    throw error;
  }
}

// ❌ 避免：同步发送，可能阻塞主流程
async processOrder(order: OrderDto) {
  const result = await this.orderProcessor.process(order);
  
  // 同步发送可能导致性能问题
  this.eventBus.emit(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED, {
    // 事件数据...
  });
  
  return result;
}
```

### 2. 标签使用最佳实践

```typescript
// ✅ 推荐：合理的标签基数
const goodTags = {
  method: 'GET',           // 低基数 (4-10个值)
  status_code: '200',      // 低基数 (10-20个值)
  endpoint_group: 'api',   // 低基数 (5-15个值)
  provider: 'longport'     // 低基数 (2-10个值)
};

// ❌ 避免：高基数标签
const badTags = {
  user_id: '12345',        // 高基数，会导致指标爆炸
  timestamp: '1640995200', // 高基数，时间戳作为标签
  request_id: 'req_abc',   // 高基数，唯一ID作为标签
  ip_address: '192.168.1.1' // 高基数，IP地址作为标签
};
```

### 3. 缓存使用最佳实践

```typescript
// ✅ 推荐：合理的缓存键命名和TTL
class DashboardService {
  async getSystemOverview() {
    return await this.monitoringCache.getOrSetPerformanceData(
      'system_overview',  // 简洁明确的键名
      async () => {
        // 计算成本高的操作
        return await this.calculateSystemOverview();
      }
    );
  }

  async getUserSpecificData(userId: string) {
    // 对于用户特定数据，使用更短的TTL
    return await this.monitoringCache.getOrSetHealthData(
      `user_health_${userId}`,
      async () => {
        return await this.calculateUserHealth(userId);
      }
    );
  }
}
```

### 4. 错误处理最佳实践

```typescript
// ✅ 推荐：完善的错误处理和监控
class PaymentService {
  async processPayment(payment: PaymentDto) {
    const startTime = Date.now();
    
    try {
      const result = await this.paymentGateway.charge(payment);
      
      // 成功指标
      this.collectorService.recordRequest(
        'payment_process',
        'POST',
        200,
        Date.now() - startTime,
        {
          payment_method: payment.method,
          amount: payment.amount,
          currency: payment.currency
        }
      );
      
      return result;
      
    } catch (error) {
      // 详细的错误分类
      const errorType = this.classifyError(error);
      
      this.collectorService.recordRequest(
        'payment_process',
        'POST',
        error.status || 500,
        Date.now() - startTime,
        {
          payment_method: payment.method,
          error_type: errorType,
          error_code: error.code
        }
      );
      
      throw error;
    }
  }

  private classifyError(error: any): string {
    if (error.code === 'INSUFFICIENT_FUNDS') return 'business_error';
    if (error.code === 'INVALID_CARD') return 'validation_error';
    if (error.message?.includes('timeout')) return 'network_error';
    return 'system_error';
  }
}
```

---

## 🔄 版本历史和路线图

### 当前版本：v2.0 (事件驱动架构)

**主要特性**：
- ✅ 完整事件驱动架构
- ✅ 智能批处理和背压控制
- ✅ 监控组件完全解耦
- ✅ 生产级错误处理和恢复
- ✅ 自监控和健康检查

### 未来路线图

#### v2.1 - 增强分析能力 (计划中)
- 🔄 机器学习异常检测
- 🔄 智能告警降噪
- 🔄 自适应阈值调整
- 🔄 预测性故障检测

#### v2.2 - 分布式支持 (计划中)  
- 🔄 多实例监控数据聚合
- 🔄 分布式缓存一致性
- 🔄 集群健康状态统一视图
- 🔄 跨服务调用链追踪

#### v3.0 - OpenTelemetry集成 (规划中)
- 🔄 标准化可观测性
- 🔄 分布式追踪支持
- 🔄 多语言SDK支持
- 🔄 云原生监控集成

---

## 🤝 贡献指南

### 提交问题
如果你发现问题或有改进建议，请在项目仓库中创建Issue。

### 开发环境设置
```bash
# 1. 安装依赖
npm install

# 2. 启动开发环境（需要 MongoDB 和 Redis）
npm run dev

# 3. 运行监控组件测试
npm run test:unit:monitoring

# 4. 运行集成测试
npm run test:integration:monitoring
```

### 代码贡献流程
1. Fork 项目仓库
2. 创建特性分支：`git checkout -b feature/new-monitoring-feature`
3. 提交代码：`git commit -m 'Add: new monitoring feature'`
4. 推送分支：`git push origin feature/new-monitoring-feature`
5. 创建 Pull Request

---

## 📞 支持和联系

- **文档问题**：查看 `docs/` 目录下的详细文档
- **使用问题**：创建 GitHub Issue 并添加 `monitoring` 标签
- **性能问题**：提供监控数据和错误日志
- **功能请求**：创建 GitHub Issue 并添加 `enhancement` 标签

---

*文档版本：v2.0.0*  
*最后更新：2024-01-01*  
*维护者：监控团队*