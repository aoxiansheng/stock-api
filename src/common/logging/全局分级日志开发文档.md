# 全局分级日志控制系统开发文档

## 📚 目录

- [系统概述](#系统概述)
- [架构设计](#架构设计)
- [核心组件](#核心组件)
- [配置体系](#配置体系)
- [配置文件与环境变量关系](#配置文件与环境变量关系)
- [实现细节](#实现细节)
- [API参考](#api参考)
- [迁移指南](#迁移指南)
- [性能优化](#性能优化)
- [故障排除](#故障排除)
- [版本历史](#版本历史)

---

## 🎯 系统概述

### 设计目标

全局分级日志控制系统是一个**集中式、全局管理**的日志级别控制解决方案，旨在：

1. **统一管理**：提供单一控制点管理所有组件的日志级别
2. **灵活控制**：支持全局、模块、命名空间三级精细化控制
3. **高性能**：通过缓存和预计算优化性能开销
4. **易于使用**：零侵入式集成，API完全兼容现有代码
5. **动态调整**：支持运行时动态更新日志级别，无需重启应用

### 核心特性

- ✅ **三级控制体系**：全局级别 → 模块级别 → 命名空间级别
- ✅ **通配符支持**：命名空间支持 `*` 和 `?` 通配符匹配
- ✅ **配置热更新**：支持配置文件和REST API动态更新
- ✅ **性能优化**：结果缓存、预计算、性能模式
- ✅ **完全兼容**：无缝替换现有日志系统

---

## 🏗️ 架构设计

### 系统架构图

```
┌─────────────────────────────────────────────────────────┐
│                     应用层 (Application Layer)           │
├─────────────────────────────────────────────────────────┤
│   MonitoringService │ AuthService │ CacheService │ ...   │
└────────────────────┬───────────────────────────────────┘
                     │ 使用
                     ▼
┌─────────────────────────────────────────────────────────┐
│              ControlledLogger (受控日志器)                │
│  ┌─────────────────────────────────────────────────┐   │
│  │  提供标准日志接口：debug, info, warn, error      │   │
│  │  集成级别检查：isDebugEnabled, isInfoEnabled    │   │
│  └─────────────────────────────────────────────────┘   │
└────────────────────┬───────────────────────────────────┘
                     │ 查询
                     ▼
┌─────────────────────────────────────────────────────────┐
│           LogLevelController (级别控制器-单例)           │
│  ┌─────────────────────────────────────────────────┐   │
│  │  配置管理 │ 级别计算 │ 缓存优化 │ 动态更新       │   │
│  └─────────────────────────────────────────────────┘   │
└────────────────────┬───────────────────────────────────┘
                     │ 读取
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  配置源 (Configuration Sources)          │
├──────────────┬──────────────┬──────────────────────────┤
│ 环境变量      │ 配置文件      │ REST API                 │
│ (.env)       │ (log-levels.json) │ (/api/admin/log-levels) │
└──────────────┴──────────────┴──────────────────────────┘
```

### 级别优先级

日志级别检查按以下优先级顺序进行：

1. **模块级别**（最高优先级）：精确匹配模块名称
2. **命名空间级别**：通配符匹配
3. **全局级别**（最低优先级）：默认级别

### 日志级别层次

```
silent < fatal < error < warn < info < debug < trace
  0       1       2      3      4      5       6
```

---

## 🔧 核心组件

### 1. LogLevelController（级别控制器）

**文件位置**：`src/common/logging/log-level-controller.ts`

#### 主要职责
- 管理全局日志级别配置
- 计算特定上下文的日志级别
- 提供动态更新接口
- 优化性能（缓存机制）

#### 核心方法

```typescript
class LogLevelController {
  // 检查是否应该记录日志
  shouldLog(context: string, level: LogLevel): boolean
  
  // 动态更新日志级别
  updateLogLevel(target: string, level: LogLevel, type: 'module' | 'namespace' | 'global'): void
  
  // 获取当前配置
  getConfiguration(): any
  
  // 批量更新
  batchUpdate(updates: Array<UpdateConfig>): void
  
  // 重置配置
  reset(): void
}
```

### 2. ControlledLogger（受控日志器）

**文件位置**：`src/common/logging/controlled-logger.ts`

#### 主要职责
- 提供标准日志接口
- 集成级别控制逻辑
- 保持API兼容性

#### 使用示例

```typescript
export class MyService {
  private readonly logger = createControlledLogger(MyService.name);
  
  someMethod() {
    // 标准日志方法
    this.logger.debug('Debug message');
    this.logger.info('Info message');
    this.logger.warn('Warning message');
    this.logger.error('Error message');
    
    // 性能优化：先检查级别
    if (this.logger.isDebugEnabled()) {
      const expensiveData = this.calculateExpensiveData();
      this.logger.debug('Debug with expensive data', expensiveData);
    }
  }
}
```

### 3. LogLevelManagementController（管理API）

**文件位置**：`src/common/logging/log-level.controller.ts`

#### REST API端点

| 方法 | 路径 | 描述 |
|------|------|------|
| GET | `/api/admin/log-levels` | 获取当前配置 |
| PUT | `/api/admin/log-levels/global/:level` | 更新全局级别 |
| PUT | `/api/admin/log-levels/module/:module/:level` | 更新模块级别 |
| PUT | `/api/admin/log-levels/batch` | 批量更新 |
| PUT | `/api/admin/log-levels/reset` | 重置为默认 |

---

## 🔧 实现细节

### 配置加载和合并实现

```typescript
// src/common/logging/log-level-controller.ts

export class LogLevelController implements OnModuleInit {
  private config: LogLevelConfig;
  private configFilePath: string;
  private envOverrides: Map<string, any> = new Map();
  
  /**
   * 加载配置的主流程
   */
  private loadConfiguration(): void {
    // 1. 加载默认配置
    const defaultConfig = this.getDefaultConfig();
    
    // 2. 加载配置文件（固定配置）
    const fileConfig = this.loadFromConfigFile();
    
    // 3. 加载环境变量（动态覆盖）
    const envOverrides = this.loadEnvironmentOverrides();
    
    // 4. 智能合并配置
    this.config = this.mergeConfigurations(
      defaultConfig,
      fileConfig,
      envOverrides
    );
    
    // 5. 验证配置完整性
    this.validateConfiguration();
    
    // 6. 记录最终配置
    this.logConfiguration();
  }
  
  /**
   * 从配置文件加载（主要配置源）
   */
  private loadFromConfigFile(): Partial<LogLevelConfig> | null {
    // 支持多个配置文件路径
    const configPaths = [
      process.env.LOG_CONFIG_PATH,
      path.join(process.cwd(), 'config', 'log-levels.json'),
      path.join(process.cwd(), 'log-levels.json'),
      path.join(process.cwd(), `.log-levels.${process.env.NODE_ENV}.json`),
    ].filter(Boolean);
    
    for (const configPath of configPaths) {
      if (fs.existsSync(configPath)) {
        try {
          const content = fs.readFileSync(configPath, 'utf-8');
          const config = JSON.parse(content);
          
          console.log(`✅ Loaded log config from: ${configPath}`);
          this.configFilePath = configPath;
          
          return this.parseFileConfig(config);
        } catch (error) {
          console.error(`❌ Failed to load config from ${configPath}:`, error);
        }
      }
    }
    
    console.warn('⚠️ No log config file found, using defaults');
    return null;
  }
  
  /**
   * 智能合并配置
   * 优先级: 环境变量 > 配置文件 > 默认值
   */
  private mergeConfigurations(
    defaultConfig: LogLevelConfig,
    fileConfig: Partial<LogLevelConfig> | null,
    envOverrides: Partial<LogLevelConfig>
  ): LogLevelConfig {
    let merged = { ...defaultConfig };
    
    if (fileConfig) {
      merged = this.deepMerge(merged, fileConfig);
    }
    
    if (envOverrides) {
      merged = this.deepMerge(merged, envOverrides);
    }
    
    return merged;
  }
}
```

### 配置文件组织结构

```
config/
├── log-levels.json                 # 主配置文件
├── log-levels.schema.json         # JSON Schema 验证
├── log-levels.development.json    # 开发环境补充
├── log-levels.production.json     # 生产环境补充
└── log-levels.test.json          # 测试环境补充
```

### 配置验证 Schema

```json
// config/log-levels.schema.json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "global": {
      "type": "string",
      "enum": ["fatal", "error", "warn", "info", "debug", "trace", "silent"]
    },
    "modules": {
      "type": "object",
      "additionalProperties": {
        "type": "string",
        "enum": ["fatal", "error", "warn", "info", "debug", "trace", "silent"]
      }
    },
    "namespaces": {
      "type": "object",
      "additionalProperties": {
        "type": "string",
        "enum": ["fatal", "error", "warn", "info", "debug", "trace", "silent"]
      }
    },
    "features": {
      "type": "object"
    },
    "performance": {
      "type": "object"
    },
    "output": {
      "type": "object"
    }
  },
  "required": ["global"]
}
```

### 版本控制策略

```gitignore
# .gitignore
.env                    # 不提交，包含敏感信息
.env.local             # 不提交，本地覆盖

# 提交这些文件
.env.example           # 提交，示例配置
config/log-levels.json # 提交，标准配置
config/log-levels.*.json # 提交，环境特定配置
```

### 快速开始

#### 1. 安装和配置

```typescript
// src/common/logging/logging.module.ts
import { Global, Module } from '@nestjs/common';
import { LogLevelController } from './log-level-controller';
import { LogLevelManagementController } from './log-level.controller';

@Global()
@Module({
  controllers: [LogLevelManagementController],
  providers: [
    {
      provide: LogLevelController,
      useFactory: () => new LogLevelController(),
    },
  ],
  exports: [LogLevelController],
})
export class LoggingModule {}
```

#### 2. 在AppModule中导入

```typescript
// src/app.module.ts
import { LoggingModule } from './common/logging/logging.module';

@Module({
  imports: [
    LoggingModule, // 添加全局日志模块
    // ... 其他模块
  ],
})
export class AppModule {}
```

#### 3. 在组件中使用

```typescript
// 任意服务或组件
import { createControlledLogger } from '@common/logging/controlled-logger';

@Injectable()
export class MonitoringService {
  private readonly logger = createControlledLogger(MonitoringService.name);
  
  async processData() {
    this.logger.debug('Starting data processing');
    
    try {
      // 业务逻辑
      const result = await this.doProcessing();
      this.logger.info('Processing completed', { result });
      return result;
    } catch (error) {
      this.logger.error('Processing failed', error);
      throw error;
    }
  }
}
```

### 高级用法

#### 条件日志记录

```typescript
// 避免不必要的计算
if (this.logger.isDebugEnabled()) {
  // 只有在debug级别启用时才执行
  const metrics = this.calculateComplexMetrics();
  this.logger.debug('Performance metrics', metrics);
}
```

#### 结构化日志

```typescript
this.logger.info('User action', {
  userId: user.id,
  action: 'login',
  timestamp: new Date().toISOString(),
  metadata: {
    ip: request.ip,
    userAgent: request.headers['user-agent'],
  }
});
```

---

## 📋 配置体系

### 配置设计原则

- **配置文件**：存储**固定的、结构化的、详细的**配置
- **环境变量**：存储**变化的、敏感的、环境特定的**配置
- **优先级**：环境变量覆盖 > 配置文件 > 默认值

### 配置职责划分

#### 配置文件负责的内容
- 详细的模块级别映射
- 命名空间匹配规则
- 功能特性开关
- 性能参数设置
- 输出格式配置
- 通用业务规则

#### 环境变量负责的内容
- 环境标识（NODE_ENV）
- 临时调试覆盖
- 敏感信息（API密钥、URL）
- 环境特定路径
- 紧急调整开关
- 外部服务配置

---

## 🔄 配置文件与环境变量关系

### 配置加载流程

```
启动应用
    │
    ▼
加载默认配置（硬编码）
    │
    ▼
查找配置文件
    │
    ├─► LOG_CONFIG_PATH 环境变量指定路径
    ├─► config/log-levels.json
    ├─► log-levels.json
    └─► log-levels.{NODE_ENV}.json
    │
    ▼
加载配置文件（如果存在）
    │
    ▼
加载环境变量覆盖
    │
    ├─► LOG_LEVEL（全局级别）
    ├─► LOG_LEVEL_OVERRIDE_MODULE（模块覆盖）
    └─► 其他功能开关
    │
    ▼
合并配置（环境变量 > 配置文件 > 默认）
    │
    ▼
验证配置完整性
    │
    ▼
应用最终配置
```

### 标准配置文件结构（config/log-levels.json）

```json
{
  "$schema": "./log-levels.schema.json",
  "version": "1.0.0",
  "description": "生产环境日志级别配置",
  
  "global": "info",
  
  "modules": {
    "// 监控组件": "===================",
    "MonitoringEventBridge": "info",
    "MonitoringCacheService": "warn",
    "CollectorService": "warn",
    "AnalyzerService": "info",
    "PresenterService": "info",
    
    "// 核心组件": "===================",
    "AuthService": "warn",
    "AuthGuard": "error",
    "JwtStrategy": "error",
    
    "// 数据层": "===================",
    "DatabaseService": "error",
    "MongoRepository": "error",
    "RedisService": "warn",
    "CacheService": "info"
  },
  
  "namespaces": {
    "*Service": "info",
    "*Controller": "info",
    "*Repository": "warn",
    "*Handler": "info",
    "*Interceptor": "info",
    "*Guard": "warn",
    "Monitor*": "debug",
    "Test*": "silent"
  },
  
  "features": {
    "enableStructuredLogging": true,
    "enableTimestamps": true,
    "enableMetadata": true,
    "enableCallerInfo": false,
    "enableColorOutput": false
  },
  
  "performance": {
    "cacheEnabled": true,
    "cacheExpiry": 5000,
    "maxCacheSize": 1000,
    "batchSize": 100,
    "flushInterval": 1000
  },
  
  "output": {
    "format": "json",
    "prettyPrint": false,
    "maxMessageLength": 10000,
    "maxDepth": 5,
    "includeStackTrace": true
  }
}
```

### 环境变量配置

```bash
# .env 文件

# ============= 全局配置 =============
LOG_LEVEL=info                              # 全局默认级别

# ============= 模块级别配置 =============
# 格式: module1:level1,module2:level2
LOG_LEVEL_MODULES=monitoring:debug,auth:warn,cache:info,database:error

# ============= 命名空间配置 =============
# 支持通配符: * 匹配任意字符, ? 匹配单个字符
LOG_LEVEL_NAMESPACES=Monitor*:debug,*Service:info,*Controller:debug,*Repository:warn

# ============= 功能开关 =============
DYNAMIC_LOG_LEVEL=true                      # 启用动态更新
LOG_PERFORMANCE_MODE=true                   # 启用性能模式
```

### 环境特定配置示例

#### 开发环境（.env.development）
```bash
# 环境标识
NODE_ENV=development

# 覆盖全局级别（临时调试）
LOG_LEVEL=debug

# 临时调试特定模块
LOG_LEVEL_OVERRIDE_MODULE=DatabaseService:trace

# 开发特定设置
LOG_TO_FILE=false
LOG_CONFIG_DEBUG=true
```

#### 生产环境（.env.production）
```bash
# 环境标识
NODE_ENV=production

# 使用配置文件的设置，不覆盖
# LOG_LEVEL 不设置，使用配置文件的 "info"

# 远程日志服务（敏感信息）
LOG_REMOTE_URL=https://logs.company.com/api
LOG_REMOTE_API_KEY=${SECRET_LOG_API_KEY}

# 生产特定设置
LOG_TO_FILE=true
LOG_FILE_PATH=/var/log/application
LOG_TO_REMOTE=true

# 性能优化
LOG_PERFORMANCE_MODE=true
```

#### 测试环境（.env.test）
```bash
# 环境标识
NODE_ENV=test

# 测试时静默大部分日志
LOG_LEVEL=error

# 禁用不必要的功能
DYNAMIC_LOG_LEVEL=false
LOG_TO_FILE=false
LOG_TO_REMOTE=false
```

### 环境特定配置文件

```json
// config/log-levels.development.json
{
  "global": "info",
  "modules": {
    "MonitoringEventBridge": "debug",
    "MonitoringCacheService": "info",
    "CollectorService": "warn",
    "AnalyzerService": "debug",
    "PresenterService": "info",
    "AuthService": "warn",
    "DatabaseService": "error",
    "CacheService": "info"
  },
  "namespaces": {
    "*Service": "info",
    "*Controller": "debug",
    "Monitor*": "debug",
    "*Repository": "warn",
    "*Handler": "info",
    "*Interceptor": "debug",
    "Test*": "silent"
  },
  "dynamicEnabled": true,
  "performanceMode": true
}
```

### 配置优先级

当多个配置源存在时，按以下优先级生效：

1. **配置文件** (`log-levels.json`) - 最高优先级
2. **环境变量** (`.env`) - 中等优先级
3. **默认值** - 最低优先级

---

## 🔌 API参考

### LogLevelController API

```typescript
interface LogLevelController {
  /**
   * 检查指定上下文和级别是否应该记录
   * @param context - 日志上下文（类名、模块名等）
   * @param level - 日志级别
   * @returns 是否应该记录
   */
  shouldLog(context: string, level: LogLevel): boolean;
  
  /**
   * 动态更新日志级别
   * @param target - 目标（模块名、命名空间或空字符串表示全局）
   * @param level - 新的日志级别
   * @param type - 更新类型
   */
  updateLogLevel(
    target: string,
    level: LogLevel,
    type: 'module' | 'namespace' | 'global'
  ): void;
  
  /**
   * 获取当前配置
   * @returns 配置对象
   */
  getConfiguration(): LogLevelConfig;
  
  /**
   * 批量更新配置
   * @param updates - 更新数组
   */
  batchUpdate(updates: UpdateConfig[]): void;
  
  /**
   * 重置为默认配置
   */
  reset(): void;
}
```

### ControlledLogger API

```typescript
interface ControlledLogger {
  // 标准日志方法
  debug(message: any, ...optionalParams: any[]): void;
  log(message: any, ...optionalParams: any[]): void;
  info(message: any, ...optionalParams: any[]): void;
  warn(message: any, ...optionalParams: any[]): void;
  error(message: any, ...optionalParams: any[]): void;
  verbose(message: any, ...optionalParams: any[]): void;
  
  // 级别检查方法
  isDebugEnabled(): boolean;
  isInfoEnabled(): boolean;
  isWarnEnabled(): boolean;
  isErrorEnabled(): boolean;
  isVerboseEnabled(): boolean;
}
```

### REST API

#### 获取配置
```http
GET /api/admin/log-levels
Authorization: Bearer {admin-token}

Response:
{
  "global": "info",
  "modules": {
    "monitoring": "debug",
    "auth": "warn"
  },
  "namespaces": {
    "*Service": "info"
  },
  "dynamicEnabled": true,
  "performanceMode": true,
  "cacheSize": 42
}
```

#### 更新全局级别
```http
PUT /api/admin/log-levels/global/debug
Authorization: Bearer {admin-token}

Response:
{
  "message": "Global log level updated",
  "level": "debug"
}
```

#### 批量更新
```http
PUT /api/admin/log-levels/batch
Authorization: Bearer {admin-token}
Content-Type: application/json

Body:
[
  { "target": "monitoring", "level": "debug", "type": "module" },
  { "target": "*Controller", "level": "info", "type": "namespace" }
]

Response:
{
  "message": "Batch update completed",
  "count": 2
}
```

---

## 💡 最佳实践

### 1. 命名规范

使用清晰、一致的命名规范有助于日志管理：

```typescript
// ✅ 推荐：使用类名作为context
private readonly logger = createControlledLogger(MonitoringService.name);

// ✅ 推荐：使用模块名作为context
private readonly logger = createControlledLogger('monitoring.cache');

// ❌ 避免：使用模糊的名称
private readonly logger = createControlledLogger('service');
```

### 2. 性能优化

#### 使用级别检查避免不必要的计算

```typescript
// ✅ 推荐：先检查级别
if (this.logger.isDebugEnabled()) {
  const stats = this.calculateStatistics(); // 昂贵的操作
  this.logger.debug('Statistics', stats);
}

// ❌ 避免：总是执行计算
this.logger.debug('Statistics', this.calculateStatistics());
```

#### 启用性能模式

```bash
# 在生产环境启用性能模式
LOG_PERFORMANCE_MODE=true
```

### 3. 结构化日志

使用结构化数据而非字符串拼接：

```typescript
// ✅ 推荐：结构化数据
this.logger.info('Request processed', {
  requestId: req.id,
  userId: user.id,
  duration: endTime - startTime,
  status: 'success'
});

// ❌ 避免：字符串拼接
this.logger.info(`Request ${req.id} for user ${user.id} took ${endTime - startTime}ms`);
```

### 4. 错误日志

始终包含错误堆栈和上下文：

```typescript
catch (error) {
  this.logger.error('Operation failed', {
    error: error.message,
    stack: error.stack,
    context: {
      userId: user.id,
      operation: 'updateProfile',
      params: { ...params, password: '[REDACTED]' }
    }
  });
}
```

### 5. 环境特定配置

为不同环境设置适当的日志级别：

```bash
# .env.development
LOG_LEVEL=debug
LOG_LEVEL_MODULES=*:debug

# .env.production
LOG_LEVEL=info
LOG_LEVEL_MODULES=monitoring:warn,auth:error,critical:info

# .env.test
LOG_LEVEL=error
LOG_LEVEL_MODULES=*:error
```

---

## 🔄 迁移指南

### 从现有日志系统迁移

#### 步骤1：安装新的日志模块

```bash
# 创建日志模块文件
mkdir -p src/common/logging
touch src/common/logging/log-level-controller.ts
touch src/common/logging/controlled-logger.ts
touch src/common/logging/logging.module.ts
```

#### 步骤2：批量替换导入

```bash
# 替换导入语句
find src -name "*.ts" -type f -exec sed -i \
  's|import { createLogger } from.*|import { createControlledLogger } from "@common/logging/controlled-logger"|g' {} \;

# 替换函数调用
find src -name "*.ts" -type f -exec sed -i \
  's/createLogger(/createControlledLogger(/g' {} \;
```

#### 步骤3：更新环境变量

```bash
# 添加到 .env 文件
echo "LOG_LEVEL_MODULES=monitoring:debug,auth:warn" >> .env
echo "LOG_LEVEL_NAMESPACES=*Service:info,*Controller:debug" >> .env
echo "DYNAMIC_LOG_LEVEL=true" >> .env
echo "LOG_PERFORMANCE_MODE=true" >> .env
```

#### 步骤4：验证迁移

```typescript
// 创建测试文件
// test/logging-migration.spec.ts
describe('Logging Migration', () => {
  it('should use controlled logger', () => {
    const logger = createControlledLogger('TestService');
    expect(logger).toBeDefined();
    expect(logger.isDebugEnabled).toBeDefined();
  });
});
```

### 兼容性保证

新系统完全兼容现有日志API：

```typescript
// 现有代码无需修改
logger.debug('message');
logger.info('message', data);
logger.warn('message', { context });
logger.error('message', error);

// 新增的功能是可选的
if (logger.isDebugEnabled()) { // 可选优化
  logger.debug('expensive operation');
}
```

---

## 🔍 故障排除

### 常见问题

#### 1. 日志未按预期输出

**症状**：设置了debug级别但未看到debug日志

**排查步骤**：
```bash
# 1. 检查环境变量
echo $LOG_LEVEL
echo $LOG_LEVEL_MODULES

# 2. 检查配置文件
cat log-levels.json

# 3. 通过API查看运行时配置
curl http://localhost:3000/api/admin/log-levels

# 4. 检查context名称匹配
# 确保logger的context与配置匹配
```

#### 2. 性能问题

**症状**：日志系统造成性能下降

**解决方案**：
```bash
# 启用性能模式
LOG_PERFORMANCE_MODE=true

# 减少日志级别
LOG_LEVEL=warn

# 禁用不必要的模块日志
LOG_LEVEL_MODULES=critical:info,monitoring:warn
```

#### 3. 配置未生效

**症状**：修改配置后未生效

**解决方案**：
```typescript
// 手动触发配置重载
logLevelController.reset();

// 或通过API
curl -X PUT http://localhost:3000/api/admin/log-levels/reset
```

### 调试模式

启用调试模式查看日志系统内部运行：

```bash
# 环境变量
DEBUG_LOG_SYSTEM=true
LOG_LEVEL=trace

# 查看内部日志
tail -f logs/system.log | grep LogLevelController
```

### 健康检查

```typescript
// 添加健康检查端点
@Get('/health/logging')
async checkLoggingHealth() {
  const config = this.logLevelController.getConfiguration();
  return {
    status: 'healthy',
    config: config,
    cacheSize: config.cacheSize,
    performanceMode: config.performanceMode,
  };
}
```

---

## ⚡ 性能优化

### 缓存机制

系统使用多级缓存优化性能：

```typescript
// 缓存配置
{
  cacheExpiry: 5000,        // 5秒过期
  maxCacheSize: 1000,       // 最大缓存条目
  performanceMode: true,    // 启用性能模式
}
```

### 性能指标

典型性能指标（基于1000次/秒日志调用）：

| 操作 | 无缓存 | 有缓存 | 性能模式 |
|------|--------|--------|----------|
| shouldLog检查 | 0.5ms | 0.05ms | 0.01ms |
| 内存使用 | 基准 | +10KB | +50KB |
| CPU使用率 | 基准 | -30% | -50% |

### 优化建议

1. **生产环境**：始终启用性能模式
2. **高频日志**：使用级别检查避免不必要的日志
3. **批量操作**：使用批量更新API减少开销
4. **定期清理**：配置合理的缓存过期时间

### 基准测试

```typescript
// benchmark.ts
import { createControlledLogger } from '@common/logging/controlled-logger';

const logger = createControlledLogger('BenchmarkTest');
const iterations = 100000;

console.time('Performance Test');
for (let i = 0; i < iterations; i++) {
  if (logger.isDebugEnabled()) {
    logger.debug(`Test message ${i}`);
  }
}
console.timeEnd('Performance Test');

// 预期结果：
// 性能模式开启: ~500ms
// 性能模式关闭: ~1500ms
```

---

## 📊 监控和指标

### 集成Prometheus指标

```typescript
// 添加日志系统指标
@Injectable()
export class LoggingMetricsService {
  private readonly logCallsCounter = new Counter({
    name: 'log_calls_total',
    help: 'Total number of log calls',
    labelNames: ['level', 'module'],
  });
  
  private readonly cacheHitRate = new Gauge({
    name: 'log_cache_hit_rate',
    help: 'Log level cache hit rate',
  });
  
  trackLogCall(level: string, module: string) {
    this.logCallsCounter.inc({ level, module });
  }
  
  updateCacheMetrics(hits: number, total: number) {
    this.cacheHitRate.set(hits / total);
  }
}
```

### Grafana仪表板配置

```json
{
  "dashboard": {
    "title": "日志系统监控",
    "panels": [
      {
        "title": "日志调用频率",
        "targets": [
          {
            "expr": "rate(log_calls_total[5m])"
          }
        ]
      },
      {
        "title": "缓存命中率",
        "targets": [
          {
            "expr": "log_cache_hit_rate"
          }
        ]
      }
    ]
  }
}
```

---

## 🔐 安全考虑

### 访问控制

管理API必须添加适当的权限控制：

```typescript
@Controller('api/admin/log-levels')
@UseGuards(AdminGuard) // 仅管理员可访问
@UseInterceptors(AuditInterceptor) // 审计日志
export class LogLevelManagementController {
  // ...
}
```

### 敏感信息过滤

确保日志不包含敏感信息：

```typescript
// 自动过滤敏感字段
const sanitizeData = (data: any) => {
  const sensitive = ['password', 'token', 'secret', 'key'];
  const cleaned = { ...data };
  
  sensitive.forEach(field => {
    if (cleaned[field]) {
      cleaned[field] = '[REDACTED]';
    }
  });
  
  return cleaned;
};
```

---

## 📅 版本历史

| 版本 | 日期 | 更改内容 |
|------|------|----------|
| 1.0.0 | 2024-01-11 | 初始版本，基础功能实现 |
| 1.1.0 | 待定 | 添加WebSocket支持 |
| 1.2.0 | 待定 | 添加日志聚合功能 |
| 2.0.0 | 待定 | 添加分布式日志支持 |

---

## 🤝 贡献指南

欢迎提交Issue和Pull Request来改进日志系统。

### 提交Issue

请包含以下信息：
- 问题描述
- 复现步骤
- 期望行为
- 实际行为
- 环境信息

### 开发流程

1. Fork仓库
2. 创建特性分支：`git checkout -b feature/improved-logging`
3. 提交更改：`git commit -m 'Add: improved logging feature'`
4. 推送分支：`git push origin feature/improved-logging`
5. 创建Pull Request

---

## 📞 支持

- **文档**：本文档
- **示例**：`examples/logging/`
- **测试**：`test/logging/`
- **问题反馈**：创建GitHub Issue

---

**文档版本**：1.0.0  
**最后更新**：2024-01-11  
**维护者**：系统架构团队