/**
 * 漏洞模板工具类
 * 🎯 符合开发规范指南 - 模板化漏洞管理
 */

import {
  SECURITY_VULNERABILITY_TEMPLATES,
  SECURITY_VULNERABILITY_STATUS,
} from '../../security/constants/security-scanner.constants';
import { SecurityVulnerability } from '../../security/interfaces/security-scanner.interface';

/**
 * 模板参数接口
 */
export interface VulnerabilityTemplateParams {
  [key: string]: string | number | string[];
}

/**
 * 漏洞模板工具类
 */
export class VulnerabilityTemplateUtil {
  /**
   * 根据模板创建漏洞对象
   * @param templateKey 模板键名
   * @param params 模板参数
   * @returns 漏洞对象
   */
  static createVulnerability(
    templateKey: keyof typeof SECURITY_VULNERABILITY_TEMPLATES,
    params: VulnerabilityTemplateParams = {},
  ): SecurityVulnerability {
    const template = SECURITY_VULNERABILITY_TEMPLATES[templateKey];
    
    if (!template) {
      throw new Error(`漏洞模板不存在: ${templateKey}`);
    }

    return {
      id: this.replaceTemplate(template.id, params),
      type: template.type as SecurityVulnerability['type'],
      severity: template.severity as SecurityVulnerability['severity'],
      title: this.replaceTemplate(template.title, params),
      description: this.replaceTemplate(template.description, params),
      impact: this.replaceTemplate(template.impact, params),
      recommendation: this.replaceTemplate(template.recommendation, params),
      detected: new Date(),
      status: SECURITY_VULNERABILITY_STATUS.DETECTED as SecurityVulnerability['status'],
    };
  }

  /**
   * 创建默认凭据漏洞
   * @param usernames 默认用户名列表
   * @returns 漏洞对象
   */
  static createDefaultCredentialsVulnerability(usernames: string[]): SecurityVulnerability {
    return this.createVulnerability('DEFAULT_CREDENTIALS', {
      usernames: usernames.join(', '),
    });
  }

  /**
   * 创建过期API Key漏洞
   * @param apiKeyId API Key ID
   * @param maskedKey 掩码后的API Key
   * @returns 漏洞对象
   */
  static createExpiredApiKeyVulnerability(apiKeyId: string, maskedKey: string): SecurityVulnerability {
    return this.createVulnerability('EXPIRED_API_KEY', {
      id: apiKeyId,
      maskedKey,
    });
  }

  /**
   * 创建权限过多漏洞
   * @param apiKeyId API Key ID
   * @param maskedKey 掩码后的API Key
   * @returns 漏洞对象
   */
  static createExcessivePermissionsVulnerability(apiKeyId: string, maskedKey: string): SecurityVulnerability {
    return this.createVulnerability('EXCESSIVE_PERMISSIONS', {
      id: apiKeyId,
      maskedKey,
    });
  }

  /**
   * 创建频率限制不足漏洞
   * @param count 没有频率限制的API Key数量
   * @returns 漏洞对象
   */
  static createInsufficientRateLimitingVulnerability(count: number): SecurityVulnerability {
    return this.createVulnerability('INSUFFICIENT_RATE_LIMITING', {
      count: count.toString(),
    });
  }

  /**
   * 创建JWT密钥强度不足漏洞
   * @param minLength 最小长度要求
   * @returns 漏洞对象
   */
  static createWeakJwtSecretVulnerability(minLength: number): SecurityVulnerability {
    return this.createVulnerability('WEAK_JWT_SECRET', {
      minLength: minLength.toString(),
    });
  }

  /**
   * 创建生产环境本地数据库漏洞
   * @returns 漏洞对象
   */
  static createLocalhostDbInProductionVulnerability(): SecurityVulnerability {
    return this.createVulnerability('LOCALHOST_DB_IN_PRODUCTION');
  }

  /**
   * 创建密码哈希强度不足漏洞
   * @param currentRounds 当前哈希轮数
   * @param recommendedRounds 推荐哈希轮数
   * @returns 漏洞对象
   */
  static createWeakPasswordHashingVulnerability(
    currentRounds: number,
    recommendedRounds: number,
  ): SecurityVulnerability {
    return this.createVulnerability('WEAK_PASSWORD_HASHING', {
      currentRounds: currentRounds.toString(),
      recommendedRounds: recommendedRounds.toString(),
    });
  }

  /**
   * 替换模板中的占位符
   * @param template 模板字符串
   * @param params 参数对象
   * @returns 替换后的字符串
   */
  private static replaceTemplate(template: string, params: VulnerabilityTemplateParams): string {
    let result = template;
    
    Object.entries(params).forEach(([key, value]) => {
      const placeholder = `{${key}}`;
      const replacement = Array.isArray(value) ? value.join(', ') : value.toString();
      result = result.replace(new RegExp(placeholder, 'g'), replacement);
    });
    
    return result;
  }

  /**
   * 验证模板参数
   * @param templateKey 模板键名
   * @param params 参数对象
   * @returns 是否有效
   */
  static validateTemplateParams(
    templateKey: keyof typeof SECURITY_VULNERABILITY_TEMPLATES,
    params: VulnerabilityTemplateParams,
  ): boolean {
    const template = SECURITY_VULNERABILITY_TEMPLATES[templateKey];
    
    if (!template) {
      return false;
    }

    // 检查模板中的占位符是否都有对应的参数
    const placeholderRegex = /\{(\w+)\}/g;
    const templateString = `${template.id} ${template.description} ${template.impact} ${template.recommendation}`;
    const matches = templateString.match(placeholderRegex);
    
    if (!matches) {
      return true; // 没有占位符，参数有效
    }

    const requiredParams = matches.map(match => match.slice(1, -1)); // 移除大括号
    const providedParams = Object.keys(params);
    
    return requiredParams.every(param => providedParams.includes(param));
  }

  /**
   * 获取模板中的占位符列表
   * @param templateKey 模板键名
   * @returns 占位符列表
   */
  static getTemplatePlaceholders(templateKey: keyof typeof SECURITY_VULNERABILITY_TEMPLATES): string[] {
    const template = SECURITY_VULNERABILITY_TEMPLATES[templateKey];
    
    if (!template) {
      return [];
    }

    const placeholderRegex = /\{(\w+)\}/g;
    const templateString = `${template.id} ${template.description} ${template.impact} ${template.recommendation}`;
    const matches = templateString.match(placeholderRegex);
    
    if (!matches) {
      return [];
    }

    return [...new Set(matches.map(match => match.slice(1, -1)))]; // 移除大括号并去重
  }

  /**
   * 获取所有可用的模板键名
   * @returns 模板键名列表
   */
  static getAvailableTemplates(): string[] {
    return Object.keys(SECURITY_VULNERABILITY_TEMPLATES);
  }

  /**
   * 检查模板是否存在
   * @param templateKey 模板键名
   * @returns 是否存在
   */
  static hasTemplate(templateKey: string): boolean {
    return templateKey in SECURITY_VULNERABILITY_TEMPLATES;
  }
}
