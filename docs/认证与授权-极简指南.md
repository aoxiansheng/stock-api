# 认证与授权（极简指南）

本系统的认证与授权已全面精简为“两个角色 + 两档权限画像 + 两个装饰器”。不再保留兼容层、统一配置和细粒度权限拼装。

## 核心模型
- 角色（UserRole）
  - `ADMIN` 管控角色（JWT，内部使用）
  - `DEVELOPER` 查询角色（等同普通用户）

- 权限画像
  - `READ_PROFILE`：查询能力（数据读取、查询执行、基础能力查询、流读取/订阅）
  - `ADMIN_PROFILE`：管控能力（READ_PROFILE + 用户/密钥/配置/提供商管理、系统管理与流写入）

- 认证形态
  - JWT：仅管理员（ADMIN）使用，内部系统/后台页面
  - API Key：外部访问使用，ApiKey.profile ∈ {READ, ADMIN}，默认 READ

## 装饰器用法（唯一标准）
- 查询端点：`@ReadAccess()`（等价 `MixedAuth([DEVELOPER], READ_PROFILE)`）
- 管控端点：`@AdminOnly()`（等价 `Auth([ADMIN], ADMIN_PROFILE)`）
- 外部管控（谨慎使用）：`@ApiKeyAuth(ADMIN_PROFILE)`

示例：
```ts
import { Controller, Get, Post } from '@nestjs/common';
import { ReadAccess, AdminOnly } from '@authv2/decorators';

@Controller('items')
export class ItemsController {
  // 查询能力（API Key READ 或 JWT DEVELOPER/ADMIN）
  @ReadAccess()
  @Get()
  list() {}

  // 管控能力（JWT ADMIN）
  @AdminOnly()
  @Post()
  create() {}
}
```

## API Key 规范
- 存储结构：`ApiKey`（MongoDB）
  - `appKey: string`
  - `accessToken: string`
  - `profile: 'READ' | 'ADMIN'`（默认 `'READ'`）
  - `expiresAt?: Date`

- 权限推导：
  - `profile === 'ADMIN'` → `ADMIN_PROFILE`
  - `profile === 'READ'` → `READ_PROFILE`

## WebSocket 鉴权
- 握手参数或头部：
  - `X-App-Key` / `appKey`
  - `X-Access-Token` / `accessToken`
- 校验逻辑：
  1. 验证 `appKey + accessToken` 是否存在/未过期
  2. 根据 ApiKey.profile 推导权限画像
  3. 检查是否具备流权限（READ 可订阅/读取；ADMIN 额外写入）

## 迁移与清理
- 端点统一改造为 `@ReadAccess()` / `@AdminOnly()`
- API Key 仅使用 `profile`（移除 `permissions[]` 自定义拼装）
- 删除旧目录 `src/auth/**` 与旧权限文档
- 全局守卫：`JwtAuthGuard`、`ApiKeyAuthGuard`、`PermissionsGuard`（@authv2/guards）

## 验收清单
- [ ] 查询端点均使用 `@ReadAccess()`
- [ ] 管控端点均使用 `@AdminOnly()`
- [ ] JWT 仅用于 ADMIN；外部均为 API Key
- [ ] 新发放 API Key 默认 `profile=READ`
- [ ] WebSocket 握手仅接受 `appKey/accessToken`，并正确推导画像
- [ ] 代码中不再出现 `@RequirePermissions(...)` 与旧 `@auth/*` 引用

## 常见问题
- Q：是否还支持细粒度权限？
  - A：不支持。所有端点仅分“查询/管控”两类，复用两档权限画像。
- Q：能否只保留 API Key？
  - A：可以。将后台/内部系统换成 API Key 管理方案，并用 `@ApiKeyAuth(ADMIN_PROFILE)` 标注管控端点。

---
最后更新：2025-01
