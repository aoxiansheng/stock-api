
1.检查组件是否存在兼容层，残留的无效代码，以及无效文件。生成一份报告，只是生成报告，不要对代码进行改动。
 清理掉
2. 现在我们分析组件 当前已经实现了什么功能，配置项有什么是需要配置的，分析 组件内的配置文件与环境变量之间有重叠吗？或者是否存在独占设置？


验证器复用检查 不要自建，而是使用通用的
通用验证常量已存在
src/common/constants/validation.constants.ts

验证装饰器模式复用
src/common/validators/symbol-format.validator.ts

基于市场优先级的智能选择 + 安全回退机制
新增方法: getDefaultProvider, analyzeMarketDistribution, getProviderByMarketPriority

大部分测试都已经通过，但是我发现测试代码存在投机性行为，为了 测试通过而通过，这些断言没有反应后端真实的设计目的和行为。你现在的工作就是分析这些断言是否是投机性的。

  - 并发安全性缺失
    - WebSocket重连逻辑问题
    - 异常处理不一致
  2. 架构优化机会：
    - 建议引入事件驱动架构
    - 实现连接池管理
- 错误处理统一规范 错误一致性
  - 类型安全改进计划

Dto 的简化
集成 dto 的拆分

枚举值与常量的重复定义


性能统计占位实现 🔴 高优先级
位置: src/core/04-storage/storage/services/storage.service.ts


@Throttle({ default: { limit: 30, ttl: 60000 } })  应该配置 而不是硬编码 
市场状态没有 api 支持 需要添加 futu 的拓展
market-awareness-caching.e2e.test.ts

npx jest --config test/config/jest.blackbox.config.js  market-awareness-caching.e2e.test.ts //未测试
   

StreamReceiver → SymbolTransformerService → SymbolMapperCacheService    → stream-data-fetcher → transformer  → 返回数据
但这里的“获取规则”这个动作，正是由 SymbolTransformerService 委托 SymbolMapperCacheService 去完成的。

   * SymbolTransformerService 的角色是 “转换流程的管理者/执行者”。它接收任务，并管理完成任务所需的所有步骤。
   * SymbolMapperCacheService 的角色是 “映射规则的提供者（带缓存）”。它的职责很纯粹：给我一个输入，我给你一个输出，并且我会用缓存来加速。

  SymbolTransformerService 作为“执行者”，它的执行步骤之一就是调用 SymbolMapperCacheService 来“获取规则”。因此，调用链必然是 Transformer 
  → Cache。
    
用户管理，增删改，root 用户的权限，可以删除 admin 和 developer。

基础工具类
通用装饰器
通用拦截器
通用类型定义
通用分页 通用响应。

ThrottlerGuard 全局限流器被修改了
智能缓存有疑问 Storage 储存器 

Websocket 的权限设置 我有疑惑 应该有一个 close，然后 write 权限作用是什么？？


现在我们需要确认我们的重构是否实现了我的要求.预定顺序是:Request → Receiver → SymbolMapper →  DataFetcher → Transformer → Storage → Response.我们的项目是一个聚会第三方 sdk 获取股票信息的项目,用户发起对我们接口的请求,使用的 symbol 是标准字符串比如 00700.HK,由于第三方 sdk可能需要专用 sdksymbol 比如 700.HK,因此我们需要使用转化器SymbolMapper 进行转换.然后发送 转换后的 symbol到第三方 sdk,也就是使用DataFetcher组件,然后第三方组件返回的数据,每个 sdk 商的格式都不一样,因此我们预设组件Data-Mapper实现了数据映射规则,我们的Transformer数据转化器会读取Data-Mapper  设置规则,对数据进行格式化,接着Storage进行储存后,返回给用户需要的数据. 

数据流程正确实现：
1. 请求首先由Receiver接收
2. Receiver委托SymbolMapper进行符号转换
3. Receiver将转换后的符号传递给DataFetcher处理SDK调用
4. 获取到原始数据后，Receiver委托Transformer进行格式转换
5. Transformer使用Data-Mapper的映射规则进行数据标准化
6. 转换后的数据传递给Storage组件进行存储
7. 最后返回标准化的响应数据


 用户请求: { symbols: ["00700.HK"], receiverType: "get-stock-quote" }
      ↓
  Receiver: 验证请求，选择provider (如longport)
      ↓
  SymbolMapper: 00700.HK → 700.HK (SDK格式)
      ↓
  DataFetcher: 调用LongPort SDK获取 { symbol: "700.HK", last_done: 385.6 }
      ↓
  Transformer: 读取Data-Mapper规则，转换为 { symbol: "00700.HK", lastPrice: 385.6 }
      ↓
  Storage: 存储到Redis和MongoDB
      ↓
  Response: 返回标准化数据给用户



3. **错误代码重复模式**
   - 位置: auth/constants/auth.constants.ts:211-227, permission.constants.ts:195-206, apikey.constants.ts:159-170
   - 影响: 错误代码定义模式相似但分散
   - 建议: 考虑使用统一的错误代码生成器或基础模板

配置文件与环境变量的拆分

TypeScript类型推导：
可以考虑使用TypeScript的类型推导功能，从常量对象中推导出类型，进一步提高类型安全性


消除 any

常量继承体系方案:
建议采用组合而非继承的方式，提高灵活性
考虑使用工厂函数创建模块特定常量，而非类继承


ApiType 应该保留
我看到这个ApiType枚举已经被标记为deprecated，而且实际使用的是内联的字符串联合类型。让我检查是否还有其他地方使用
  这个枚举：


  中英文注释混用，影响代码风格一致性

针对 ERROR_TYPES 语义重复问题的最佳方案
推荐方案: 统一使用 ErrorType 枚举定义

针对 RETRY_CONFIG 重复问题的最佳方案
推荐方案: 使用统一重试配置中心 RETRY_CONSTANTS

针对 TIMEOUT 配置重复问题的最佳方案
推荐方案: 使用统一超时配置中心 PERFORMANCE_CONSTANTS.TIMEOUTS


缓存键前缀命名规范不统一 - 冒号分隔 vs 下划线 vs 缩写+冒号
  2. 缺乏基础配置接口 - 配置结构未标准化


 auth/utils/deep-freeze.util.ts 深度冻结函数的复用


 施抽象接口解耦，移除对monitoring层的直接依赖
 import { SYSTEM_STATUS_EVENTS } from "../../contracts/events/system-status.events";


 降低耦合: 通过适配器模式减少模块间直接依赖
 backend/src/common/modules/permission/adapters/auth-permission.adapter.ts

