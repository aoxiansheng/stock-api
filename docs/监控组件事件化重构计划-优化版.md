## 监控组件事件化重构计划 - 优化版 v2.0

### 1. 背景与现状

#### 1.1 现有基础
- ✅ **事件总线已就绪**：EventEmitter2已全局注册，支持通配符订阅
- ✅ **事件常量已定义**：完整的SYSTEM_STATUS_EVENTS定义已存在
- ✅ **收集器已事件化**：CollectorService已发送METRIC_COLLECTED等事件
- ✅ **仓储模式已实现**：CollectorRepository可支持数据持久化

#### 1.2 待解决问题
- ❌ **业务直写指标**：35+个组件直接注入MetricsRegistryService
- ❌ **分析层强依赖**：AnalyzerService直接调用CollectorService.getRawMetrics() 13次
- ❌ **缓存未事件化**：MonitoringCacheService未发送缓存事件
- ❌ **缺少事件桥接**：无统一的事件到指标转换层
- ❌ **API事件未使用**：API_REQUEST_*事件已定义但未实装

### 2. 核心设计理念

#### 2.1 设计原则
- **渐进式改造**：保持向后兼容，新旧模式并行
- **最小破坏性**：优先新增而非修改，避免影响现有功能
- **按需实施**：核心功能优先，高级特性延后
- **性能优先**：避免过度抽象，确保低延迟

#### 2.2 目标架构
```
业务组件 → 发送事件 → EventBridge → 更新指标
                    ↓
              监控组件订阅处理
```

### 3. 实施方案（2-3周完成）

## Phase 1：基础事件化（第1周）

### 任务1.1：最小化事件桥接层【高优先级】

**实施位置**：`src/monitoring/infrastructure/bridge/monitoring-event-bridge.service.ts`

```typescript
import { Injectable, OnModuleInit } from '@nestjs/common';
import { EventEmitter2, OnEvent } from '@nestjs/event-emitter';
import { MetricsRegistryService } from '../metrics/metrics-registry.service';
import { SYSTEM_STATUS_EVENTS } from '../../contracts/events/system-status.events';
import { createLogger } from '@common/config/logger.config';

@Injectable()
export class MonitoringEventBridgeService implements OnModuleInit {
  private readonly logger = createLogger(MonitoringEventBridgeService.name);
  private eventCounter = 0;
  private lastFlush = Date.now();
  
  constructor(
    private readonly eventBus: EventEmitter2,
    private readonly metricsRegistry: MetricsRegistryService,
  ) {}

  onModuleInit() {
    this.logger.log('监控事件桥接层已启动');
  }

  /**
   * 处理指标收集事件
   */
  @OnEvent(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED)
  handleMetricCollected(event: any) {
    try {
      // 直接更新Prometheus指标
      const { metricType, metricName, metricValue, tags } = event;
      
      switch (metricType) {
        case 'request':
          this.metricsRegistry.receiverRequestsTotal.inc(tags || {});
          break;
        case 'cache':
          this.metricsRegistry.storageCacheEfficiency.set(
            tags || {}, 
            metricValue
          );
          break;
        case 'database':
          this.metricsRegistry.storageOperationsTotal.inc(tags || {});
          break;
      }
      
      this.eventCounter++;
      
      // 简单的批量刷新（每100个事件或每秒）
      if (this.eventCounter >= 100 || Date.now() - this.lastFlush > 1000) {
        this.flushMetrics();
      }
    } catch (error) {
      // 静默处理，不影响主流程
      this.logger.debug('事件处理失败', error.message);
    }
  }

  /**
   * 处理缓存事件
   */
  @OnEvent(SYSTEM_STATUS_EVENTS.CACHE_HIT)
  @OnEvent(SYSTEM_STATUS_EVENTS.CACHE_MISS)
  handleCacheEvent(event: any) {
    try {
      const isHit = event.type === SYSTEM_STATUS_EVENTS.CACHE_HIT;
      this.metricsRegistry.storageCacheEfficiency.set(
        { cache_type: 'monitoring', operation: event.key },
        isHit ? 1 : 0
      );
    } catch (error) {
      this.logger.debug('缓存事件处理失败', error.message);
    }
  }

  /**
   * 处理分析完成事件
   */
  @OnEvent(SYSTEM_STATUS_EVENTS.ANALYSIS_COMPLETED)
  handleAnalysisCompleted(event: any) {
    try {
      const { duration, dataPoints, analysisType } = event;
      // 使用现有的通用处理时间指标
      this.metricsRegistry.receiverProcessingDuration.observe(
        { 
          method: 'analysis',
          provider: 'internal',
          operation: analysisType,
          status: 'success',
          attempt: '1'
        },
        duration / 1000
      );
      
      // 或使用存储查询持续时间指标记录分析耗时
      this.metricsRegistry.storageQueryDuration.observe(
        { 
          query_type: `analysis_${analysisType}`,
          storage_type: 'memory'
        },
        duration / 1000
      );
    } catch (error) {
      this.logger.debug('分析事件处理失败', error.message);
    }
  }

  private flushMetrics() {
    this.eventCounter = 0;
    this.lastFlush = Date.now();
    // 批量更新逻辑（如需要）
  }
}
```

**集成到模块（避免循环依赖）**：
```typescript
// src/monitoring/infrastructure/infrastructure.module.ts
import { Module, forwardRef } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { MonitoringEventBridgeService } from './bridge/monitoring-event-bridge.service';

@Module({
  imports: [
    MetricsModule,
    // 使用forwardRef避免循环依赖
    forwardRef(() => MonitoringModule),
  ],
  providers: [
    FeatureFlags,
    MetricsRegistryService,
    MonitoringEventBridgeService, // 新增
    // 提供EventEmitter2的工厂，从全局获取实例
    {
      provide: EventEmitter2,
      useFactory: (moduleRef: ModuleRef) => {
        // 从全局上下文获取EventEmitter2，避免循环依赖
        try {
          return moduleRef.get(EventEmitter2, { strict: false });
        } catch (error) {
          // 如果获取失败，创建本地实例（降级方案）
          console.warn('无法获取全局EventEmitter2，创建本地实例');
          return new EventEmitter2();
        }
      },
      inject: [ModuleRef],
    }
  ],
  exports: [
    MetricsModule,
    FeatureFlags,
    MetricsRegistryService,
    MonitoringEventBridgeService, // 导出供其他模块使用
  ],
})
export class InfrastructureModule {}
```

### 任务1.2：缓存服务事件化【高优先级】

**修改位置**：`src/monitoring/cache/monitoring-cache.service.ts`

```typescript
// 在现有MonitoringCacheService中添加事件发送（向后兼容方式）
import { Optional } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { SYSTEM_STATUS_EVENTS } from '../contracts/events/system-status.events';

@Injectable()
export class MonitoringCacheService {
  constructor(
    private readonly cacheService: CacheService,
    @Optional() private readonly eventBus?: EventEmitter2, // 可选注入，保持向后兼容
  ) {
    // 如果eventBus未注入，记录警告但不影响功能
    if (!this.eventBus) {
      this.logger.warn('EventEmitter2未注入，事件功能将被禁用');
    }
  }

  async getOrSet<T>(
    key: string,
    factory: () => Promise<T>,
    ttlMs?: number
  ): Promise<T> {
    const cacheKey = this.buildKey(key);
    const startTime = Date.now();
    
    try {
      // 尝试获取缓存
      const cached = await this.cacheService.get(cacheKey);
      
      if (cached !== null && cached !== undefined) {
        // 发送缓存命中事件（仅在eventBus存在时）
        if (this.eventBus) {
          this.eventBus.emit(SYSTEM_STATUS_EVENTS.CACHE_HIT, {
            timestamp: new Date(),
            source: 'cache',
            key: cacheKey,
            metadata: { 
              duration: Date.now() - startTime,
              ttlMs 
            }
          });
        }
        return cached as T;
      }
      
      // 发送缓存未命中事件
      if (this.eventBus) {
        this.eventBus.emit(SYSTEM_STATUS_EVENTS.CACHE_MISS, {
          timestamp: new Date(),
          source: 'cache',
          key: cacheKey,
          metadata: { duration: Date.now() - startTime }
        });
      }
      
      // 执行工厂函数
      const value = await factory();
      
      // 设置缓存
      await this.set(cacheKey, value, ttlMs);
      
      // 发送缓存设置事件
      if (this.eventBus) {
        this.eventBus.emit(SYSTEM_STATUS_EVENTS.CACHE_SET, {
          timestamp: new Date(),
          source: 'cache',
          key: cacheKey,
          metadata: { 
            ttlMs,
            size: JSON.stringify(value).length 
          }
        });
      }
      
      return value;
    } catch (error) {
      // 发送缓存错误事件
      if (this.eventBus) {
        this.eventBus.emit(SYSTEM_STATUS_EVENTS.CACHE_ERROR, {
          timestamp: new Date(),
          source: 'cache',
          key: cacheKey,
          metadata: { 
            error: error.message,
            duration: Date.now() - startTime 
          }
        });
      }
      
      // 缓存失败时直接返回工厂函数结果
      return await factory();
    }
  }

  async invalidate(pattern?: string): Promise<void> {
    try {
      const keys = pattern 
        ? await this.cacheService.keys(`${this.keyPrefix}:${pattern}`)
        : await this.cacheService.keys(`${this.keyPrefix}:*`);
      
      if (keys.length > 0) {
        await this.cacheService.del(...keys);
        
        // 发送缓存失效事件
        if (this.eventBus) {
          this.eventBus.emit(SYSTEM_STATUS_EVENTS.CACHE_INVALIDATED, {
            timestamp: new Date(),
            source: 'cache',
            pattern: pattern || '*',
            metadata: { count: keys.length }
          });
        }
      }
    } catch (error) {
      this.logger.error('缓存失效失败', error);
    }
  }
}
```

### 任务1.3：简单测试覆盖【高优先级】

**测试文件**：`test/jest/unit/monitoring/event-bridge.spec.ts`

```typescript
describe('MonitoringEventBridgeService', () => {
  let service: MonitoringEventBridgeService;
  let eventBus: EventEmitter2;
  let metricsRegistry: MetricsRegistryService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        MonitoringEventBridgeService,
        {
          provide: EventEmitter2,
          useValue: {
            emit: jest.fn(),
          },
        },
        {
          provide: MetricsRegistryService,
          useValue: {
            receiverRequestsTotal: { inc: jest.fn() },
            storageCacheEfficiency: { set: jest.fn() },
            storageOperationsTotal: { inc: jest.fn() },
            analyzerProcessingDuration: { observe: jest.fn() },
          },
        },
      ],
    }).compile();

    service = module.get(MonitoringEventBridgeService);
    eventBus = module.get(EventEmitter2);
    metricsRegistry = module.get(MetricsRegistryService);
  });

  it('should handle metric collected events', () => {
    const event = {
      metricType: 'request',
      metricName: 'test',
      metricValue: 1,
      tags: { method: 'GET' },
    };

    service.handleMetricCollected(event);

    expect(metricsRegistry.receiverRequestsTotal.inc).toHaveBeenCalledWith({ method: 'GET' });
  });

  it('should handle cache hit events', () => {
    const event = {
      type: SYSTEM_STATUS_EVENTS.CACHE_HIT,
      key: 'test-key',
    };

    service.handleCacheEvent(event);

    expect(metricsRegistry.storageCacheEfficiency.set).toHaveBeenCalledWith(
      expect.any(Object),
      1
    );
  });

  it('should not throw on event handling errors', () => {
    metricsRegistry.receiverRequestsTotal.inc = jest.fn().mockImplementation(() => {
      throw new Error('Test error');
    });

    expect(() => service.handleMetricCollected({})).not.toThrow();
  });
});
```

## Phase 2：性能优化与扩展（第2周）

### 任务2.1：批处理优化【中优先级】

**新增文件**：`src/monitoring/infrastructure/bridge/event-batcher.ts`

```typescript
interface BatchedEvent {
  type: string;
  events: any[];
  count: number;
  firstTimestamp: number;
  lastTimestamp: number;
}

// 批处理结果
export interface BatchResult {
  accepted: boolean;
  reason?: 'queue_full' | 'rate_limit' | 'shutdown';
  shouldFlush?: boolean;
  droppedCount?: number;
}

export class EventBatcher {
  private batches = new Map<string, BatchedEvent>();
  private flushTimer?: NodeJS.Timeout;
  private totalEventCount = 0;
  private droppedEvents = 0;
  private isShuttingDown = false;
  
  // 背压控制参数
  private readonly maxTotalEvents = 10000;
  private readonly highWaterMark = 8000;
  
  constructor(
    private readonly flushIntervalMs = 100,
    private readonly maxBatchSize = 100,
    private readonly maxQueueSize = 10000
  ) {}

  add(eventType: string, event: any): BatchResult {
    // 关闭状态检查
    if (this.isShuttingDown) {
      return { 
        accepted: false, 
        reason: 'shutdown' 
      };
    }
    
    // 背压控制 - 总事件数检查
    if (this.totalEventCount >= this.maxTotalEvents) {
      this.droppedEvents++;
      return { 
        accepted: false, 
        reason: 'queue_full',
        shouldFlush: true,
        droppedCount: this.droppedEvents
      };
    }
    
    const batch = this.batches.get(eventType) || {
      type: eventType,
      events: [],
      count: 0,
      firstTimestamp: Date.now(),
      lastTimestamp: Date.now(),
    };
    
    batch.events.push(event);
    batch.count++;
    batch.lastTimestamp = Date.now();
    this.totalEventCount++;
    
    this.batches.set(eventType, batch);
    
    // 检查是否需要立即刷新
    let shouldFlush = false;
    
    // 批次大小触发刷新
    if (batch.count >= this.maxBatchSize) {
      this.flushType(eventType);
      shouldFlush = true;
    }
    
    // 高水位触发刷新
    if (this.totalEventCount >= this.highWaterMark) {
      this.flushAll();
      shouldFlush = true;
    }
    
    // 启动定时刷新
    if (!this.flushTimer && !shouldFlush) {
      this.flushTimer = setTimeout(() => this.flushAll(), this.flushIntervalMs);
    }
    
    return { 
      accepted: true,
      shouldFlush 
    };
  }

  flushType(eventType: string): BatchedEvent | null {
    const batch = this.batches.get(eventType);
    if (!batch) return null;
    
    this.batches.delete(eventType);
    this.totalEventCount -= batch.count;
    return batch;
  }

  flushAll(): BatchedEvent[] {
    const results = Array.from(this.batches.values());
    this.batches.clear();
    this.totalEventCount = 0;
    
    if (this.flushTimer) {
      clearTimeout(this.flushTimer);
      this.flushTimer = undefined;
    }
    
    return results;
  }
  
  // 获取统计信息
  getMetrics() {
    return {
      totalEvents: this.totalEventCount,
      droppedEvents: this.droppedEvents,
      batchCount: this.batches.size,
      isShuttingDown: this.isShuttingDown,
      queueUtilization: (this.totalEventCount / this.maxTotalEvents) * 100
    };
  }
  
  // 优雅关闭
  async shutdown(): Promise<void> {
    this.isShuttingDown = true;
    
    // 刷新所有待处理事件
    const finalBatches = this.flushAll();
    
    // 清理资源
    if (this.flushTimer) {
      clearTimeout(this.flushTimer);
      this.flushTimer = undefined;
    }
    
    return Promise.resolve();
  }
  
  // 重置统计
  resetMetrics() {
    this.droppedEvents = 0;
  }
}
```

**更新EventBridge使用批处理**：
```typescript
export class MonitoringEventBridgeService {
  private readonly batcher = new EventBatcher(100, 100);

  @OnEvent(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED)
  handleMetricCollected(event: any) {
    // 高频事件使用批处理
    const shouldFlush = this.batcher.add(event.metricType, event);
    
    if (shouldFlush) {
      this.processBatch(event.metricType);
    }
  }

  private processBatch(eventType: string) {
    const batch = this.batcher.flushType(eventType);
    if (!batch) return;
    
    // 批量更新指标
    try {
      const aggregated = this.aggregateEvents(batch.events);
      this.updateMetricsBatch(eventType, aggregated);
    } catch (error) {
      this.logger.debug(`批处理失败: ${eventType}`, error.message);
    }
  }
}
```

### 任务2.2：API拦截器事件化【中优先级】

**新增拦截器**：`src/monitoring/infrastructure/interceptors/api-monitoring.interceptor.ts`

```typescript
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { SYSTEM_STATUS_EVENTS } from '../../contracts/events/system-status.events';

@Injectable()
export class ApiMonitoringInterceptor implements NestInterceptor {
  constructor(private readonly eventBus: EventEmitter2) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();
    const startTime = Date.now();
    
    // 发送请求开始事件（异步，不阻塞）
    setImmediate(() => {
      this.eventBus.emit(SYSTEM_STATUS_EVENTS.API_REQUEST_STARTED, {
        timestamp: new Date(),
        source: 'api',
        endpoint: request.path,
        method: request.method,
        metadata: {
          ip: request.ip,
          userAgent: request.headers['user-agent'],
        }
      });
    });

    return next.handle().pipe(
      tap(() => {
        const duration = Date.now() - startTime;
        
        // 发送请求完成事件
        setImmediate(() => {
          this.eventBus.emit(SYSTEM_STATUS_EVENTS.API_REQUEST_COMPLETED, {
            timestamp: new Date(),
            source: 'api',
            endpoint: request.path,
            method: request.method,
            statusCode: response.statusCode,
            duration,
            metadata: {
              size: response.get('content-length') || 0,
            }
          });
        });
      }),
      catchError((error) => {
        const duration = Date.now() - startTime;
        
        // 发送请求错误事件
        setImmediate(() => {
          this.eventBus.emit(SYSTEM_STATUS_EVENTS.API_REQUEST_ERROR, {
            timestamp: new Date(),
            source: 'api',
            endpoint: request.path,
            method: request.method,
            statusCode: error.status || 500,
            duration,
            metadata: {
              errorType: error.constructor.name,
              errorMessage: error.message,
            }
          });
        });
        
        throw error;
      })
    );
  }
}
```

**集成到main.ts**：
```typescript
// src/main.ts
const apiMonitoringInterceptor = app.get(ApiMonitoringInterceptor);
app.useGlobalInterceptors(apiMonitoringInterceptor);
```

## Phase 3：高级功能（按需实施）

### 任务3.1：分析层渐进式去耦【低优先级】

**保持双模式运行策略**：

```typescript
@Injectable()
export class AnalyzerService {
  private useEventMode = false; // 配置开关
  
  constructor(
    private readonly collectorService: CollectorService, // 保留DI
    private readonly collectorRepository: CollectorRepository,
    private readonly eventBus: EventEmitter2,
  ) {}

  @OnEvent(SYSTEM_STATUS_EVENTS.COLLECTION_COMPLETED)
  async handleCollectionCompleted(event: any) {
    if (!this.useEventMode) return; // 事件模式开关
    
    // 从仓储获取数据
    const metrics = await this.collectorRepository.findLatest();
    await this.runAnalysis(metrics);
  }

  async runAnalysis(options?: any) {
    let rawMetrics;
    
    if (this.useEventMode && !options?.forceDirect) {
      // 事件模式：从仓储获取
      rawMetrics = await this.collectorRepository.findLatest();
    } else {
      // 兼容模式：直接调用
      rawMetrics = await this.collectorService.getRawMetrics();
    }
    
    // 执行分析逻辑...
    
    // 发送分析完成事件
    this.eventBus.emit(SYSTEM_STATUS_EVENTS.ANALYSIS_COMPLETED, {
      timestamp: new Date(),
      source: 'analyzer',
      analysisType: 'trend',
      duration: Date.now() - startTime,
      dataPoints: rawMetrics.length,
    });
  }
}
```

### 任务3.2：监控自监控【中优先级】

```typescript
// src/monitoring/infrastructure/bridge/self-monitoring.ts
export class MonitoringSelfMetrics {
  private metrics = {
    eventsReceived: 0,
    eventsProcessed: 0,
    eventsDropped: 0,
    processingErrors: 0,
    batchesProcessed: 0,
    averageLatencyMs: 0,
  };
  
  private samples: number[] = [];
  private readonly maxSamples = 100;
  
  recordEvent(success: boolean, latencyMs: number) {
    this.metrics.eventsReceived++;
    
    if (success) {
      this.metrics.eventsProcessed++;
      this.samples.push(latencyMs);
      
      if (this.samples.length > this.maxSamples) {
        this.samples.shift();
      }
      
      this.metrics.averageLatencyMs = 
        this.samples.reduce((a, b) => a + b, 0) / this.samples.length;
    } else {
      this.metrics.eventsDropped++;
    }
  }
  
  recordError() {
    this.metrics.processingErrors++;
  }
  
  recordBatch(size: number) {
    this.metrics.batchesProcessed++;
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
  
  reset() {
    this.metrics = {
      eventsReceived: 0,
      eventsProcessed: 0,
      eventsDropped: 0,
      processingErrors: 0,
      batchesProcessed: 0,
      averageLatencyMs: 0,
    };
    this.samples = [];
  }
}
```

## 4. 风险管理与兼容性

### 4.1 向后兼容策略
- **保留现有DI模式**：MetricsRegistryService继续可直接注入
- **双模式运行**：事件化与直接调用并行，通过配置切换
- **渐进式迁移**：新功能使用事件，旧功能逐步改造

### 4.2 性能保障
- **异步事件发送**：使用setImmediate避免阻塞
- **批处理机制**：高频事件聚合处理
- **错误隔离**：事件处理失败不影响业务

### 4.3 监控与告警
```typescript
// 监控事件系统健康度
interface EventSystemHealth {
  eventRate: number;        // 事件速率
  errorRate: number;        // 错误率
  dropRate: number;         // 丢弃率
  latencyP95: number;       // P95延迟
  queueSize: number;        // 队列大小
}

// 健康检查端点
@Get('/monitoring/event-health')
async getEventHealth(): Promise<EventSystemHealth> {
  return this.eventBridge.getHealthMetrics();
}
```

## 5. 测试策略

### 5.1 单元测试
- 事件桥接层逻辑测试
- 批处理器功能测试
- 缓存事件发送验证

### 5.2 集成测试
```typescript
describe('Event-driven Monitoring Integration', () => {
  it('should update metrics when cache events are emitted', async () => {
    // 触发缓存操作
    await monitoringCache.getOrSet('test', async () => 'value');
    
    // 等待事件处理
    await new Promise(r => setTimeout(r, 150));
    
    // 验证指标更新
    const metrics = await request(app.getHttpServer())
      .get('/metrics')
      .expect(200);
    
    expect(metrics.text).toContain('storage_cache_efficiency');
  });

  it('should handle EventEmitter2 unavailable gracefully', async () => {
    // 模拟EventEmitter2不可用的情况
    const cacheServiceWithoutEvents = new MonitoringCacheService(
      cacheService,
      undefined // 未注入EventEmitter2
    );
    
    // 缓存操作应该正常工作
    const result = await cacheServiceWithoutEvents.getOrSet(
      'test-key',
      async () => 'test-value'
    );
    
    expect(result).toBe('test-value');
    
    // 验证警告日志
    expect(loggerSpy.warn).toHaveBeenCalledWith(
      expect.stringContaining('EventEmitter2未注入')
    );
  });

  it('should handle module circular dependency resolution', async () => {
    // 测试模块依赖解析
    const testModule = await Test.createTestingModule({
      imports: [
        InfrastructureModule,
        forwardRef(() => MonitoringModule)
      ]
    }).compile();
    
    const eventBridge = testModule.get(MonitoringEventBridgeService);
    const eventEmitter = testModule.get(EventEmitter2);
    
    expect(eventBridge).toBeDefined();
    expect(eventEmitter).toBeDefined();
  });
});
```

### 5.3 边界条件和错误处理测试
```typescript
describe('Event System Boundary Conditions', () => {
  describe('EventBatcher Edge Cases', () => {
    let batcher: EventBatcher;
    
    beforeEach(() => {
      batcher = new EventBatcher(100, 50, 1000);
    });
    
    it('should handle queue overflow with backpressure', () => {
      // 填满队列到高水位
      for (let i = 0; i < 8000; i++) {
        const result = batcher.add('test-event', { id: i });
        expect(result.accepted).toBe(true);
      }
      
      // 超过限制应该触发背压
      for (let i = 8000; i < 10001; i++) {
        const result = batcher.add('test-event', { id: i });
        if (!result.accepted) {
          expect(result.reason).toBe('queue_full');
          expect(result.shouldFlush).toBe(true);
          break;
        }
      }
      
      const metrics = batcher.getMetrics();
      expect(metrics.droppedEvents).toBeGreaterThan(0);
    });
    
    it('should handle shutdown gracefully', async () => {
      // 添加一些事件
      batcher.add('test-event', { id: 1 });
      batcher.add('test-event', { id: 2 });
      
      // 关闭batcher
      await batcher.shutdown();
      
      // 关闭后应该拒绝新事件
      const result = batcher.add('test-event', { id: 3 });
      expect(result.accepted).toBe(false);
      expect(result.reason).toBe('shutdown');
    });
    
    it('should handle concurrent flush operations', async () => {
      // 添加多个批次
      for (let i = 0; i < 100; i++) {
        batcher.add(`event-${i % 5}`, { id: i });
      }
      
      // 并发刷新操作
      const flushPromises = [
        Promise.resolve(batcher.flushAll()),
        Promise.resolve(batcher.flushType('event-0')),
        Promise.resolve(batcher.flushType('event-1'))
      ];
      
      const results = await Promise.all(flushPromises);
      
      // 验证没有重复处理
      const allEvents = results.flat().reduce((acc, batch) => {
        if (batch && batch.events) {
          return acc + batch.events.length;
        }
        return acc;
      }, 0);
      
      expect(allEvents).toBeLessThanOrEqual(100);
    });
  });

  describe('MonitoringEventBridgeService Error Handling', () => {
    it('should handle malformed metric events', () => {
      const malformedEvents = [
        undefined,
        null,
        {},
        { metricType: null },
        { metricValue: 'invalid' },
        { tags: 'not-an-object' }
      ];
      
      malformedEvents.forEach(event => {
        expect(() => service.handleMetricCollected(event)).not.toThrow();
      });
      
      // 验证错误日志记录
      expect(loggerSpy.debug).toHaveBeenCalledWith(
        expect.stringContaining('事件处理失败')
      );
    });
    
    it('should handle metric registry failures', () => {
      // 模拟指标更新失败
      const errorMessage = 'Prometheus metric update failed';
      metricsRegistry.receiverRequestsTotal.inc.mockImplementation(() => {
        throw new Error(errorMessage);
      });
      
      const event = {
        metricType: 'request',
        metricValue: 1,
        tags: { method: 'GET' }
      };
      
      // 不应该抛出异常
      expect(() => service.handleMetricCollected(event)).not.toThrow();
      
      // 验证错误被记录
      expect(loggerSpy.debug).toHaveBeenCalledWith(
        expect.stringContaining('事件处理失败'),
        errorMessage
      );
    });
    
    it('should handle event emission failures in cache service', async () => {
      // 模拟EventEmitter2故障
      const mockEventBus = {
        emit: jest.fn().mockImplementation(() => {
          throw new Error('EventEmitter2 failure');
        })
      };
      
      const cacheService = new MonitoringCacheService(
        baseCacheService,
        mockEventBus as any
      );
      
      // 缓存操作应该继续工作
      const result = await cacheService.getOrSet(
        'test-key',
        async () => 'test-value'
      );
      
      expect(result).toBe('test-value');
      expect(mockEventBus.emit).toHaveBeenCalled();
    });
  });
});
```

### 5.4 性能压力测试
```typescript
describe('Event System Performance Under Stress', () => {
  it('should handle burst traffic without degradation', async () => {
    const startTime = Date.now();
    const eventCount = 50000;
    let processedEvents = 0;
    
    // 监听事件处理
    eventBus.on(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED, () => {
      processedEvents++;
    });
    
    // 发送突发流量
    const events = Array.from({ length: eventCount }, (_, i) => ({
      metricType: 'burst_test',
      metricValue: i,
      timestamp: Date.now()
    }));
    
    // 并发发送事件
    await Promise.all(
      events.map(event => 
        Promise.resolve(eventBus.emit(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED, event))
      )
    );
    
    // 等待处理完成
    await new Promise(resolve => {
      const checkProcessed = () => {
        if (processedEvents >= eventCount || Date.now() - startTime > 10000) {
          resolve(undefined);
        } else {
          setTimeout(checkProcessed, 100);
        }
      };
      checkProcessed();
    });
    
    const endTime = Date.now();
    const duration = endTime - startTime;
    const throughput = processedEvents / (duration / 1000);
    
    expect(processedEvents).toBeGreaterThanOrEqual(eventCount * 0.95); // 允许5%丢失
    expect(throughput).toBeGreaterThan(1000); // 至少1000 events/sec
    expect(duration).toBeLessThan(60000); // 不超过1分钟
  });
  
  it('should maintain memory stability under continuous load', async () => {
    const initialMemory = process.memoryUsage().heapUsed;
    const iterations = 10;
    const eventsPerIteration = 10000;
    
    for (let i = 0; i < iterations; i++) {
      // 发送批量事件
      for (let j = 0; j < eventsPerIteration; j++) {
        eventBus.emit(SYSTEM_STATUS_EVENTS.METRIC_COLLECTED, {
          metricType: 'memory_test',
          metricValue: Math.random(),
          iteration: i,
          event: j
        });
      }
      
      // 等待处理并强制GC
      await new Promise(r => setTimeout(r, 200));
      if (global.gc) {
        global.gc();
      }
    }
    
    // 最终内存检查
    const finalMemory = process.memoryUsage().heapUsed;
    const memoryGrowth = (finalMemory - initialMemory) / 1024 / 1024;
    
    expect(memoryGrowth).toBeLessThan(100); // 内存增长小于100MB
  });
  
  it('should handle mixed event types efficiently', async () => {
    const eventTypes = [
      SYSTEM_STATUS_EVENTS.METRIC_COLLECTED,
      SYSTEM_STATUS_EVENTS.CACHE_HIT,
      SYSTEM_STATUS_EVENTS.CACHE_MISS,
      SYSTEM_STATUS_EVENTS.ANALYSIS_COMPLETED,
      SYSTEM_STATUS_EVENTS.API_REQUEST_STARTED
    ];
    
    const eventsPerType = 2000;
    const startTime = Date.now();
    
    // 并发发送不同类型的事件
    const promises = eventTypes.map(eventType =>
      Promise.all(
        Array.from({ length: eventsPerType }, (_, i) =>
          Promise.resolve(eventBus.emit(eventType, {
            timestamp: new Date(),
            source: 'performance_test',
            id: i,
            eventType
          }))
        )
      )
    );
    
    await Promise.all(promises);
    
    const duration = Date.now() - startTime;
    const totalEvents = eventTypes.length * eventsPerType;
    const throughput = totalEvents / (duration / 1000);
    
    expect(throughput).toBeGreaterThan(5000); // 混合事件吞吐量 > 5000/sec
    expect(duration).toBeLessThan(10000); // 处理时间 < 10秒
  });
});
```

## 6. 实施计划

### Week 1：基础实施
- **Day 1-2**：实现EventBridge基础版本，部署到测试环境
- **Day 3-4**：MonitoringCacheService事件化，验证事件流
- **Day 5**：基础测试编写，性能基线建立

### Week 2：优化与扩展
- **Day 6-7**：批处理优化，API拦截器实现
- **Day 8-9**：监控自监控，健康检查端点
- **Day 10**：集成测试，文档更新

### Week 3（可选）：高级特性
- 分析层渐进式去耦
- 分布式流控（仅多实例场景）
- OpenTelemetry集成准备

## 7. 验收标准

### 功能验收
- ✅ EventBridge正常工作，指标正确更新
- ✅ 缓存事件正常发送和处理
- ✅ API请求生命周期完整监控
- ✅ 监控故障不影响业务（错误隔离）

### 性能验收
- ✅ 事件处理延迟 < 50ms (P95)
- ✅ 支持 1000+ events/sec
- ✅ 内存增长 < 10MB/hour
- ✅ CPU开销 < 5%

### 质量验收
- ✅ 单元测试覆盖率 > 80%
- ✅ 集成测试通过率 100%
- ✅ 无破坏性变更
- ✅ 向后兼容性保证

## 8. 关键决策点

### 立即实施 ✅
1. EventBridge基础版本
2. MonitoringCacheService事件化
3. 基础测试覆盖

### 逐步实施 ⏳
1. 批处理优化
2. API拦截器
3. 监控自监控

### 延后决策 ⏸
1. 分析层完全去耦（评估影响后决定）
2. Redis分布式流控（多实例时再考虑）
3. OpenTelemetry（需求明确后实施）

## 9. 成功指标

### 短期（2周内）
- 事件化覆盖率达到60%
- 监控延迟降低30%
- 代码耦合度降低40%

### 中期（1个月）
- 事件化覆盖率达到80%
- 完全消除业务直写指标
- 建立完整的事件驱动监控体系

### 长期（3个月）
- 100%事件驱动监控
- 支持分布式追踪
- 可扩展到微服务架构

## 附录：配置示例

```yaml
# monitoring.config.yaml
monitoring:
  event:
    enabled: true
    bridge:
      batchSize: 100
      flushInterval: 100
      maxQueueSize: 10000
    cache:
      eventEnabled: true
      includeSize: true
    api:
      interceptorEnabled: true
      includeHeaders: false
  compatibility:
    keepDirectInjection: true
    analyzerEventMode: false
  selfMonitoring:
    enabled: true
    metricsEndpoint: /monitoring/event-health
    healthCheckInterval: 60000
```

## 总结

本优化版方案基于现有代码基础，采用渐进式改造策略，确保：
1. **最小风险**：保持向后兼容，新旧并行
2. **快速见效**：2周内完成核心功能
3. **可控成本**：避免过度设计，按需扩展
4. **持续改进**：建立监控反馈循环

通过事件化改造，预期实现监控与业务的完全解耦，提升系统的可维护性和可扩展性。