# 缓存层监控改造计划 - 事件驱动架构

> **📋 事件驱动架构更新（2025-08-26）**
>
> 本文档已全面更新以支持事件驱动监控架构v2.0，基于MonitoringCacheService的最新事件化实现。
> 主要更新内容：
> - ✅ 事件驱动架构：完全解耦的监控体系
> - ✅ 自动事件发射：MonitoringCacheService自动发射CACHE_HIT/MISS/SET/ERROR事件
> - ✅ 错误隔离保证：监控失败不影响缓存业务逻辑
> - ✅ 高性能批处理：EventBatcher智能聚合缓存事件
> - ✅ 向后兼容：保持原有缓存API接口

## 🔄 事件驱动架构原理

### 🏗️ MonitoringCacheService 事件化模式

基于最新的MonitoringCacheService实现，缓存操作已全面事件化：

```typescript
// ✅ 自动事件发射机制
// 缓存命中：自动发射 SYSTEM_STATUS_EVENTS.CACHE_HIT
// 缓存未命中：自动发射 SYSTEM_STATUS_EVENTS.CACHE_MISS
// 缓存设置：自动发射 SYSTEM_STATUS_EVENTS.CACHE_SET
// 缓存错误：自动发射 SYSTEM_STATUS_EVENTS.CACHE_ERROR

this.eventBus.emit(SYSTEM_STATUS_EVENTS.CACHE_HIT, {
  timestamp: new Date(),
  source: 'cache',
  key: cacheKey,
  metadata: { 
    duration,
    ttl,
    cache_type: 'monitoring',
    category: 'health'
  }
});
```

### 🎯 核心设计原则

1. **🔄 事件驱动解耦**：缓存组件只使用MonitoringCacheService或CollectorService
2. **⚡ 自动事件发射**：缓存操作自动触发相应事件，无需手动编码
3. **🛡️ 错误隔离保证**：监控事件失败不影响缓存操作
4. **📦 智能批处理**：EventBatcher自动聚合缓存事件，减少监控开销
5. **🔧 向后兼容**：保持原有缓存API，渐进式迁移

### 🚨 当前旧架构问题

| 缓存子组件 | 当前问题 | 事件驱动改造方案 |
|------------|-------------|-------------|
| **CommonCache** | Mock Registry导致监控失效 | 使用MonitoringCacheService自动事件发射 |
| **SymbolMapperCache** | 直接注入MetricsRegistryService | 替换为CollectorService事件驱动模式 |
| **DataMapperCache** | 私有metrics对象 | 移除私有统计，采用事件发射 |
| **StreamCache** | 私有stats统计 | 移除私有stats，使用CollectorService |
| **SmartCache** | 注入presenterRegistryService | 替换为MonitoringCacheService |

## 🔧 事件驱动改造计划

### 阶段1：CommonCache组件改造（优先级：最高）

#### 3.1.1 移除Mock Registry
**文件**: `src/core/05-caching/common-cache/module/common-cache.module.ts`

**改造内容**:
- 移除METRICS_REGISTRY provider定义（第76-92行）
- 导入MonitoringModule
- 从exports中移除METRICS_REGISTRY

#### 3.1.2 服务层改造
**文件**: `src/core/05-caching/common-cache/services/common-cache.service.ts`

**改造内容**:
- 移除`@Inject('METRICS_REGISTRY')`注入
- 注入CollectorService替代
- 改造recordMetrics方法使用CollectorService.recordCacheOperation
- 改造recordDecompressionMetrics方法

**示例代码**:
```typescript
constructor(
  @Inject('REDIS_CLIENT') private readonly redis: Redis,
  private readonly configService: ConfigService,
  private readonly compressionService: CacheCompressionService,
  private readonly collectorService: CollectorService, // 新增
) {}

private recordMetrics(operation: string, success: boolean, duration: number): void {
  try {
    // 使用CollectorService的业务语义化接口
    this.collectorService.recordCacheOperation(
      operation,
      success, // hit参数，成功即命中
      duration,
      { layer: 'common-cache' }
    );
  } catch (error) {
    // 监控失败不影响业务
    this.logger.debug(`监控记录失败: ${error.message}`);
  }
}
```

### 阶段2：SymbolMapperCache组件改造

#### 3.2.1 模块改造
**文件**: `src/core/05-caching/symbol-mapper-cache/module/symbol-mapper-cache.module.ts`

**改造内容**:
- 导入MonitoringModule
- 移除对MetricsRegistryService的直接导入

#### 3.2.2 服务层改造
**文件**: `src/core/05-caching/symbol-mapper-cache/services/symbol-mapper-cache.service.ts`

**改造内容**:
- 将MetricsRegistryService注入改为CollectorService
- 改造recordCacheMetrics方法
- 改造recordPerformanceMetrics方法
- 移除对Prometheus底层API的直接调用

**示例代码**:
```typescript
constructor(
  private readonly repository: SymbolMapperRepository,
  private readonly featureFlags: FeatureFlagsService,
  private readonly collectorService: CollectorService, // 替换MetricsRegistryService
) {}

private recordCacheMetrics(hit: boolean, layer: string): void {
  try {
    const operation = `symbol_mapping_${layer}`;
    this.collectorService.recordCacheOperation(
      operation,
      hit,
      0, // 如果没有duration可传0
      { 
        layer,
        cacheType: 'symbol-mapper'
      }
    );
  } catch (error) {
    this.logger.debug(`监控记录失败: ${error.message}`);
  }
}
```

### 阶段3：DataMapperCache组件改造

#### 3.3.1 移除私有metrics对象
**文件**: `src/core/05-caching/data-mapper-cache/services/data-mapper-cache.service.ts`

**改造内容**:
- 移除私有的metrics对象（第20-26行）
- 注入CollectorService
- 改造updateMetrics方法使用CollectorService

**示例代码**:
```typescript
constructor(
  private readonly redisService: RedisService,
  private readonly collectorService: CollectorService, // 新增
) {}

private updateMetrics(hit: boolean, operation: string): void {
  try {
    this.collectorService.recordCacheOperation(
      `data_mapper_${operation}`,
      hit,
      0,
      { cacheType: 'data-mapper' }
    );
  } catch (error) {
    this.logger.debug(`监控记录失败: ${error.message}`);
  }
}
```

### 阶段4：StreamCache组件改造

#### 3.4.1 移除私有stats对象
**文件**: `src/core/05-caching/stream-cache/services/stream-cache.service.ts`

**改造内容**:
- 移除私有的stats对象（第35-42行）
- 注入CollectorService
- 改造所有stats更新逻辑

**示例代码**:
```typescript
constructor(
  @Inject('REDIS_CLIENT') private redisClient: Redis,
  private readonly collectorService: CollectorService, // 新增
) {}

// 替换原有的stats.hotCacheHits++
private recordHotCacheHit(): void {
  try {
    this.collectorService.recordCacheOperation(
      'stream_hot_cache',
      true, // hit
      0,
      { cacheLayer: 'hot' }
    );
  } catch (error) {
    this.logger.debug(`监控记录失败: ${error.message}`);
  }
}
```

### 阶段5：SmartCache组件改造

#### 3.5.1 服务注入规范化
**文件**: `src/core/05-caching/smart-cache/services/smart-cache-orchestrator.service.ts`

**改造内容**:
- 移除presenterRegistryService注入
- 注入CollectorService
- 改造所有监控记录逻辑

**示例代码**:
```typescript
constructor(
  private readonly rawConfig: ConfigService,
  private readonly commonCacheService: CommonCacheService,
  private readonly dataChangeDetectorService: DataChangeDetectorService,
  private readonly marketStatusService: MarketStatusService,
  private readonly backgroundTaskService: BackgroundTaskService,
  private readonly collectorService: CollectorService, // 替换presenterRegistryService
) {}
```

## 4. 测试计划

### 4.1 单元测试改造
每个组件需要更新对应的测试文件：
- 移除Mock Registry相关测试
- 添加CollectorService的Mock
- 验证监控方法调用正确性

### 4.2 集成测试
- 验证监控数据正确流向CollectorService
- 验证监控失败不影响业务逻辑
- 验证性能影响在可接受范围内

### 4.3 E2E测试
- 验证完整的监控数据流
- 验证Prometheus指标正确性
- 验证监控数据展示正确性

## 5. 实施顺序

| 顺序 | 组件 | 预计工时 | 风险等级 |
|------|------|----------|----------|
| 1 | CommonCache | 2小时 | 低 |
| 2 | StreamCache | 1.5小时 | 低 |
| 3 | DataMapperCache | 1.5小时 | 低 |
| 4 | SymbolMapperCache | 2小时 | 中 |
| 5 | SmartCache | 2小时 | 中 |

## 6. 回滚计划

如果改造出现问题，可以按以下步骤回滚：

1. **版本控制回滚**：通过Git恢复到改造前的版本
2. **配置开关**：在每个组件添加feature flag控制新旧监控切换
3. **逐步回滚**：按组件独立回滚，不影响其他组件

## 7. 成功标准

- ✅ 所有缓存组件统一使用CollectorService
- ✅ 移除所有Mock Registry和私有统计对象
- ✅ 监控数据完整性达到95%以上
- ✅ 监控延迟不超过5ms
- ✅ 监控失败率低于0.1%
- ✅ 通过所有单元测试和集成测试

## 8. 注意事项

1. **向后兼容**：保持对外接口不变，只改造内部实现
2. **性能优化**：使用异步方式记录监控，避免阻塞业务逻辑
3. **错误处理**：监控失败必须静默处理，不能影响缓存功能
4. **日志级别**：监控相关日志使用debug级别，避免生产环境日志膨胀
5. **批量处理**：对于高频操作，考虑批量提交监控数据

## 9. 后续优化建议

1. **统一监控配置**：将监控相关配置集中管理
2. **监控数据聚合**：在CollectorService层面实现数据预聚合
3. **自定义指标**：根据业务需求定制缓存专属指标
4. **告警规则**：基于监控数据配置告警规则
5. **可视化优化**：优化Grafana Dashboard展示

## 10. 文档更新

改造完成后需要更新以下文档：
- 监控组件使用指导文档
- 缓存组件架构说明文档
- 监控指标说明文档
- 运维手册相关章节