# 新数据源接入工作指导文档

## 概述

本文档详细介绍如何为智能股票数据系统接入新的数据源提供商。系统采用自动发现机制，只需按照标准结构创建文件，系统会在启动时自动注册所有能力。

## 🎯 自动发现机制原理

### 工作流程

1. **启动时扫描**: 系统启动时，`CapabilityRegistryService` 自动扫描 `src/providers/` 目录
2. **目录遍历**: 识别所有提供商目录（排除 `node_modules`、`interfaces` 等系统目录）
3. **能力发现**: 在每个提供商的 `capabilities/` 子目录中查找能力文件
4. **动态加载**: 通过 ES6 动态导入加载能力模块
5. **自动注册**: 将有效的能力自动注册到能力注册表

### 核心代码实现

```typescript
// CapabilityRegistryService.discoverCapabilities()
async discoverCapabilities(): Promise<void> {
  this.logger.log('开始自动发现数据源能力...');
  
  const providersPath = __dirname;
  try {
    const providerDirs = await readdir(providersPath, { withFileTypes: true });

    // 排除系统目录和文件，只扫描可能的提供商目录
    const excludedDirs = ['node_modules', 'interfaces'];
    
    for (const dirent of providerDirs) {
      if (dirent.isDirectory() && 
          !excludedDirs.includes(dirent.name) &&
          !dirent.name.startsWith('.')) {
        await this.loadProviderCapabilities(dirent.name);
      }
    }

    this.logger.log({
      message: '能力发现完成',
      totalCapabilities: this.getTotalCapabilitiesCount(),
    });
  } catch (error) {
    this.logger.error(
      { error: error.stack },
      '自动发现能力时发生错误',
    );
  }
}
```

## 🏗️ 接入新数据源步骤

### 第一步：创建提供商目录结构

在 `src/providers/` 下创建新的提供商目录：

```
src/providers/
└── [新提供商名称]/
    ├── capabilities/           # 能力实现目录（必需）
    ├── [提供商名称].provider.ts   # 提供商主类（必需）
    ├── [提供商名称].module.ts     # NestJS模块（必需）
    ├── types.ts               # 类型定义（推荐）
    └── [提供商名称]-context.service.ts  # 上下文服务（可选）
```

### 第二步：实现提供商主类

创建提供商类，实现 `IDataProvider` 接口：

```typescript
// src/providers/newprovider/newprovider.provider.ts
import { Injectable } from '@nestjs/common';
import { createLogger } from '@common/config/logger.config';
import { IDataProvider } from '../interfaces/provider.interface';
import { ICapability } from '../interfaces/capability.interface';

@Injectable()
export class NewProviderProvider implements IDataProvider {
  private readonly logger = createLogger(NewProviderProvider.name);
  
  readonly name = 'newprovider';
  readonly description = '新数据提供商描述';
  readonly capabilities: ICapability[] = [];

  constructor(
    // 注入配置服务、上下文服务等依赖
  ) {}

  async initialize(): Promise<void> {
    this.logger.log('初始化新数据提供商...');
    // 实现初始化逻辑
    this.logger.log('新数据提供商初始化完成');
  }

  async testConnection(): Promise<boolean> {
    try {
      // 实现连接测试逻辑
      return true;
    } catch (error) {
      this.logger.error('连接测试失败', { error: error.message });
      return false;
    }
  }

  getCapability(name: string): ICapability | null {
    return this.capabilities.find(cap => cap.name === name) || null;
  }
}
```

### 第三步：创建NestJS模块

```typescript
// src/providers/newprovider/newprovider.module.ts
import { Module } from '@nestjs/common';
import { NewProviderProvider } from './newprovider.provider';

@Module({
  providers: [NewProviderProvider],
  exports: [NewProviderProvider],
})
export class NewProviderModule {}
```

### 第四步：实现能力文件

在 `capabilities/` 目录下创建能力实现文件：

```typescript
// src/providers/newprovider/capabilities/get-stock-quote.ts
import { ICapability } from '../../interfaces/capability.interface';
import { MARKETS } from '@common/constants/market.constants';

/**
 * 新提供商股票报价获取能力
 */
export const getStockQuote: ICapability = {
  name: 'get-stock-quote',
  description: '获取股票实时报价数据',
  supportedMarkets: [MARKETS.HK, MARKETS.US, MARKETS.SZ, MARKETS.SH],
  supportedSymbolFormats: ['700.HK', 'AAPL.US', '000001.SZ', '600000.SH'],
  rateLimit: {
    requestsPerSecond: 10,
    requestsPerDay: 10000,
  },

  async execute(params: { symbols: string[], contextService?: any }): Promise<any> {
    try {
      console.log('调用新提供商API获取股票报价:', params.symbols);
      
      // 实现具体的API调用逻辑
      // const quotes = await this.callProviderAPI(params.symbols);
      
      // 转换为标准格式
      const secu_quote = []; // 转换后的数据
      
      return { secu_quote };
    } catch (error) {
      throw new Error(`新提供商获取股票报价失败: ${error.message}`);
    }
  },
};

// 重要：必须默认导出
export default getStockQuote;
```

### 第五步：注册到主模块

在 `src/providers/providers.module.ts` 中添加新模块：

```typescript
import { Module, OnModuleInit } from '@nestjs/common';
import { CapabilityRegistryService } from './capability-registry.service';
import { ProvidersController } from './providers-controller';
import { AuthModule } from '../auth/auth.module';

// Provider modules
import { LongportModule } from './longport/longport.module';
import { LongportSgModule } from './longport-sg/longport-sg.module';
import { NewProviderModule } from './newprovider/newprovider.module'; // 新增

// Provider实例导入
import { LongportProvider } from './longport/longport.provider';
import { LongportSgProvider } from './longport-sg/longport-sg.provider';
import { NewProviderProvider } from './newprovider/newprovider.provider'; // 新增

@Module({
  imports: [
    AuthModule,
    LongportModule,
    LongportSgModule,
    NewProviderModule, // 新增
  ],
  controllers: [ProvidersController],
  providers: [CapabilityRegistryService],
  exports: [CapabilityRegistryService],
})
export class ProvidersModule implements OnModuleInit {
  constructor(
    private readonly capabilityRegistry: CapabilityRegistryService,
    private readonly longportProvider: LongportProvider,
    private readonly longportSgProvider: LongportSgProvider,
    private readonly newProvider: NewProviderProvider, // 新增
  ) {}

  async onModuleInit() {
    // 🎯 自动注册所有Provider实例
    await this.registerProviders();
  }

  private async registerProviders(): Promise<void> {
    // 注册现有Provider
    this.capabilityRegistry.registerProvider(this.longportProvider);
    this.capabilityRegistry.registerProvider(this.longportSgProvider);
    
    // 注册新Provider
    this.capabilityRegistry.registerProvider(this.newProvider); // 新增
  }
}
```

**重要说明**：
- 除了添加模块导入外，还必须手动注册Provider实例
- Provider实例注册是必需的，用于在运行时获取Provider的上下文服务
- 自动发现机制只负责扫描和注册能力，不负责Provider实例管理

## 📋 接口规范

### IDataProvider 接口

**位置**: `src/providers/interfaces/provider.interface.ts`

```typescript
export interface IDataProvider {
  name: string;                                    // 提供商名称
  description: string;                             // 提供商描述
  capabilities: ICapability[];                     // 能力列表
  initialize(): Promise<void>;                     // 初始化方法
  testConnection(): Promise<boolean>;               // 连接测试
  getCapability(name: string): ICapability | null; // 获取指定能力
}
```

### ICapability 接口

**位置**: `src/providers/interfaces/capability.interface.ts`

```typescript
export interface ICapability {
  name: string;                    // 能力名称
  description: string;             // 能力描述
  supportedMarkets: string[];      // 支持的市场
  supportedSymbolFormats: string[]; // 支持的股票代码格式
  rateLimit?: {                    // 速率限制（可选）
    requestsPerSecond: number;
    requestsPerDay: number;
  };
  execute(params: any): Promise<any>; // 执行方法
}
```

**正确的导入方式**：
```typescript
import { IDataProvider } from '../interfaces/provider.interface';
import { ICapability } from '../interfaces/capability.interface';
```

## 🎯 标准能力类型

系统支持以下标准能力类型，建议新提供商实现：

| 能力名称 | 描述 | 对应API数据类型 |
|---------|------|---------------|
| `get-stock-quote` | 获取股票实时报价 | `stock-quote` |
| `get-stock-basic-info` | 获取股票基本信息 | `stock-basic-info` |
| `get-index-quote` | 获取指数报价 | `index-quote` |
| `get-market-status` | 获取市场状态 | `market-status` |
| `get-trading-days` | 获取交易日历 | `trading-days` |

## 📁 文件命名规范

- **提供商目录**: 使用小写字母，可选连字符，如 `longport`、`longport-sg`
- **Provider类**: 使用PascalCase + Provider后缀，如 `LongportProvider`、`LongportSgProvider`
- **Module类**: 使用PascalCase + Module后缀，如 `LongportModule`、`LongportSgModule`  
- **能力文件**: 使用连字符分隔，如 `get-stock-quote.ts`
- **类型文件**: 统一命名为 `types.ts`
- **Context服务**: 使用连字符 + context.service.ts，如 `longport-context.service.ts`

**实际案例**：
```
src/providers/
├── longport/                        # 无连字符
│   ├── longport.provider.ts         # 类名: LongportProvider
│   ├── longport.module.ts           # 类名: LongportModule
│   └── longport-context.service.ts  # 类名: LongportContextService
└── longport-sg/                     # 有连字符（区分地区）
    ├── longport-sg.provider.ts      # 类名: LongportSgProvider
    ├── longport-sg.module.ts        # 类名: LongportSgModule
    └── longport-sg-context.service.ts # 类名: LongportSgContextService
```

## 🔧 实际示例：参考LongPort实现

### 目录结构
```
src/providers/longport/
├── capabilities/
│   ├── get-stock-quote.ts
│   ├── get-stock-basic-info.ts
│   └── get-index-quote.ts
├── longport.provider.ts
├── longport.module.ts
├── longport-context.service.ts
└── types.ts
```

### 核心实现要点

1. **上下文服务**: 用于管理连接池和会话
2. **错误处理**: 统一的错误处理和日志记录
3. **数据转换**: 将提供商原始数据转换为系统标准格式
4. **配置管理**: 通过环境变量管理API凭证

## ⚡ 自动发现验证

系统启动后，可通过以下方式验证新提供商是否成功注册：

### 1. 查看启动日志
```bash
bun run dev
# 查找类似日志：
# [CapabilityRegistryService] 加载提供商 newprovider 的 3 个能力
# [CapabilityRegistryService] 能力发现完成，共注册 X 个能力
```

### 2. API检查
```bash
# 查看所有注册的能力
curl http://localhost:3000/api/v1/providers/capabilities

# 查看特定提供商能力
curl http://localhost:3000/api/v1/providers/newprovider/capabilities

# 测试最佳提供商选择
curl http://localhost:3000/api/v1/providers/best-provider/get-stock-quote/HK
```

### 3. 使用新提供商
```bash
# 使用receiver接口测试
curl -X POST http://localhost:3000/api/v1/receiver/data \
  -H "Content-Type: application/json" \
  -d '{
    "symbols": ["700.HK"], 
    "capabilityType": "get-stock-quote",
    "options": {"preferredProvider": "newprovider"}
  }'
```

## 🚨 常见问题和注意事项

### 1. 能力文件导出规范
```typescript
// ✅ 推荐：默认导出（优先级最高）
export default getStockQuote;

// ✅ 备选：命名导出（作为fallback）
export const getStockQuote: ICapability = { ... };

// ❌ 错误 - 仅使用解构导出
export { getStockQuote };
```

**加载机制说明**：系统会按优先级尝试加载：
1. 首先尝试 `capabilityModule.default`
2. 如果失败，尝试 `capabilityModule[camelCaseName]`
3. 两者都失败则跳过该能力

### 2. 目录结构必须正确
```
src/providers/
└── newprovider/          # 提供商目录
    └── capabilities/     # 能力目录（必需）
        └── *.ts         # 能力文件
```

### 3. 实现ICapability接口
所有能力文件必须实现完整的 `ICapability` 接口，特别是 `execute` 方法。

### 4. 错误处理
在 `execute` 方法中进行充分的错误处理，并抛出有意义的错误信息。

### 5. 数据格式标准化
返回的数据应该转换为系统标准格式，便于后续处理。

## 🔄 完整的注册和发现机制

### 双重注册机制

系统采用**能力自动发现** + **Provider实例手动注册**的双重机制：

#### 1. 能力自动发现（启动时）
```typescript
// CapabilityRegistryService 自动扫描和注册能力
async discoverCapabilities(): Promise<void> {
  // 1. 扫描 src/providers/ 目录
  // 2. 发现所有 capabilities/*.ts 文件
  // 3. 动态导入并注册能力
  // 4. 默认优先级为1，状态为enabled
}
```

#### 2. Provider实例手动注册（模块初始化时）
```typescript
// ProvidersModule 手动注册Provider实例
private async registerProviders(): Promise<void> {
  this.capabilityRegistry.registerProvider(this.newProvider);
  // 注册Provider实例，用于获取上下文服务和连接管理
}
```

### 能力优先级和选择

系统会根据以下规则选择最佳提供商：

1. **优先级数字**: 数字越小优先级越高（默认为1）
2. **市场支持**: 提供商必须支持请求的市场
3. **能力启用状态**: 只考虑已启用的能力

```typescript
// 能力注册时的默认设置
this.registerCapability(providerName, capability, 1, true);
//                                                 ↑  ↑
//                                              优先级 启用状态
```

### 注册状态验证

可以通过以下方式验证注册状态：

```bash
# 1. 查看所有注册的能力
curl -H "X-App-Key: YOUR_KEY" -H "X-Access-Token: YOUR_TOKEN" \
  http://localhost:3000/api/v1/providers/capabilities

# 2. 查看特定提供商的Provider实例是否注册
# 在启动日志中查找: "Provider实例注册成功: newprovider"
```

## 📈 测试和验证

1. **单元测试**: 为每个能力编写单元测试
2. **集成测试**: 测试与系统其他组件的集成
3. **API测试**: 通过Swagger UI或curl测试API端点
4. **压力测试**: 验证速率限制和性能表现

## 🎉 接入完成

按照以上步骤完成后，新的数据源将：

1. ✅ **能力自动发现**: 系统启动时自动扫描和注册所有能力
2. ✅ **Provider实例注册**: 在ProvidersModule中手动注册Provider实例
3. ✅ **API文档显示**: 自动在Swagger文档中显示新的能力
4. ✅ **智能提供商选择**: 参与最佳提供商选择算法
5. ✅ **多种调用方式**: 支持通过Receiver、Query等方式调用
6. ✅ **统一的错误处理和监控**: 享受系统级的错误处理和性能监控

## 📝 接入清单

完成新数据源接入需要完成以下步骤：

- [ ] **第一步**: 创建提供商目录结构 (`src/providers/newprovider/`)
- [ ] **第二步**: 实现Provider类 (`newprovider.provider.ts`)
- [ ] **第三步**: 创建NestJS模块 (`newprovider.module.ts`)
- [ ] **第四步**: 实现能力文件 (`capabilities/*.ts`)
- [ ] **第五步**: 更新ProvidersModule导入和注册
- [ ] **验证步骤**: 启动系统并验证能力和Provider实例都已注册

**关键要点**：
- 能力文件使用默认导出或命名导出
- 必须在ProvidersModule中手动注册Provider实例
- 能力自动发现机制处理能力注册，无需手动干预
- 两种注册机制缺一不可，共同确保系统正常运行

通过这种设计，系统在保持自动化便利性的同时，确保了Provider实例的生命周期管理和依赖注入的正确性。