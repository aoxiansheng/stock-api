### 可执行的遗留代码修复文档（安全审计与扫描子系统）

- 范围：仅涉及数据与业务逻辑层（认证→事件→审计→扫描），不改接口契约与技术栈。
- 原则：保持功能等价；证据驱动；分阶段、可回滚；不改变外部 API。

## 架构模式对比分析（现状 vs 目标）

- 事件驱动链路
  - 现状：`SecurityAuditService` 已实现 `@OnEvent('auth.*')` 监听；认证链路未发出对应事件，导致监听器“孤岛”。
  - 目标：在登录成功/失败与 API Key 使用路径发出标准化事件，打通审计数据流。

- 中间件注册
  - 现状：`SecurityMiddleware` 在 `main.ts` 里 `new` 实例手动绑定，未走 Nest DI 生命周期。
  - 目标：在模块 `configure(Consumer)` 中使用 Nest 方式注册，支持依赖注入与统一管理。

- 扫描器检查项一致性
  - 现状：`ALL_SECURITY_CHECKS` 清单与实际实现不完全一致，存在“无条件告警”的占位项（如 NO_MFA、POTENTIAL_DATA_EXPOSURE、NOSQL_INJECTION_RISK）。
  - 目标：与实现对齐；未实现项增加配置开关或补齐最小可行检查。

- 依赖洁净度
  - 现状：`SecurityAuditService` 注入了未使用的 `PaginationService`。
  - 目标：移除冗余注入，避免误导。

## 问题标注（证据-定位-说明）

- 高优先级｜事件未接入（监听存在，触发缺失）
```394:402:/Users/honor/Documents/code/newstockapi/backend/src/security/services/security-audit.service.ts
@OnEvent("auth.login.success")
async handleLoginSuccess(data: {
  userId: string;
  clientIP: string;
  userAgent: string;
}) {
```
```128:142:/Users/honor/Documents/code/newstockapi/backend/src/auth/services/auth.service.ts
const { accessToken, refreshToken } =
  await this.tokenService.generateTokens(user);
...
return {
  user: user.toJSON() as User,
  accessToken,
  refreshToken,
};
```
- 说明：认证服务未向事件总线发出 `auth.login.success` / `auth.login.failure`；API Key 链路未发出 `auth.apikey.used`，导致审计、报告、仪表盘全为空或严重失真。

- 中优先级｜中间件未走 DI（手动实例化）
```41:44:/Users/honor/Documents/code/newstockapi/backend/src/main.ts
const securityMiddleware = new SecurityMiddleware();
app.use(securityMiddleware.use.bind(securityMiddleware));
```
- 说明：违背 Nest 模式，阻断依赖注入，测试/生产不一致风险增大。

- 中优先级｜扫描项与实现不一致，存在无条件告警
```328:333:/Users/honor/Documents/code/newstockapi/backend/src/security/services/security-scanner.service.ts
vulnerabilities.push(
  VulnerabilityTemplateUtil.createVulnerability("NO_MFA"),
);
```
```366:373:/Users/honor/Documents/code/newstockapi/backend/src/security/services/security-scanner.service.ts
vulnerabilities.push(
  VulnerabilityTemplateUtil.createVulnerability(
    "POTENTIAL_DATA_EXPOSURE",
  ),
);
vulnerabilities.push(
  VulnerabilityTemplateUtil.createVulnerability("NOSQL_INJECTION_RISK"),
);
```
- 说明：上述漏洞项未基于实际检查条件，报告误报率高；与 `ALL_SECURITY_CHECKS` 不一致。

- 中优先级｜手动扫描与定时扫描可能并发
```57:59:/Users/honor/Documents/code/newstockapi/backend/src/security/services/security-scanner.service.ts
@Interval(SECURITY_SCANNER_CONFIG.SCAN_INTERVAL_MS)
async performSecurityScan(): Promise<SecurityScanResultDocument> {
```
```133:141:/Users/honor/Documents/code/newstockapi/backend/src/security/controller/security.controller.ts
async performSecurityScan(): Promise<SecurityScanResponseDto> {
  const scanResult = await this.securityScanner.performSecurityScan();
```
- 说明：缺少互斥控制，可能导致重复插入、耗资源。

- 低优先级｜冗余服务注入（未使用）
```46:52:/Users/honor/Documents/code/newstockapi/backend/src/security/services/security-audit.service.ts
constructor(
  private readonly auditLogRepository: SecurityAuditLogRepository,
  private readonly eventEmitter: EventEmitter2,
  private readonly cacheService: CacheService,
  private readonly paginationService: PaginationService,
) {}
```
- 说明：`PaginationService` 未被调用，保留会误导“支持分页查询”。

## 分阶段替换方案（保持功能等价、可回滚）

### 阶段一（当天完成，零接口风险）

- 事件接入（核心打通）
  - 在 `AuthService.login()` 成功分支 emit `"auth.login.success"`，失败分支 emit `"auth.login.failure"`（尽早、抛错前）。
  - 在 API Key 成功认证后 emit `"auth.apikey.used"`（推荐在 `ApiKeyAuthGuard` 或 `ApiKeyService.validateApiKey()` 成功路径二选一，避免重复）。
  - 使用现有 `EventEmitter2`（保持技术一致）。

- 中间件 DI 化
  - 将 `SecurityMiddleware` 的注册从 `main.ts` 移除，改到 `SecurityModule`（或 `AppModule`）的 `configure(Consumer)` 中，通过 Nest DI 注入需要的依赖。
  - 不改路由路径和行为，仅变更注册方式。

- 移除冗余注入
  - 从 `SecurityAuditService` 构造函数移除 `PaginationService`，删除对应 import。

预计回归风险：低。可直接回滚。

### 阶段二（小改，行为更真实，可回滚）

- 扫描项一致化与误报控制
  - 为 NO_MFA、POTENTIAL_DATA_EXPOSURE、NOSQL_INJECTION_RISK 增加配置开关（如 `security.scanner.assumeBaselineRisks`），默认关闭；或补齐最小可行检查后再输出。
  - 将 `ALL_SECURITY_CHECKS` 与实际 `checks` 对齐（删冗余或补实现）。

- 扫描互斥
  - 在 `SecurityScannerService` 内部添加轻量互斥（进程内 `isScanning` 或基于缓存的分布式锁），重入返回“已有扫描进行中”。

预计回归风险：中（报告项变动）。需更新内部文档/演示口径。

### 阶段三（观测与验证）

- 新增 e2e 校验
  - 登录成功/失败/API Key 请求后，可在 `/security/audit/events` 查询到对应事件。
  - 同时触发定时与手动扫描时，无并发扫描发生。

- 文档一致化
  - 更新安全扫描文档说明“策略型检查”的开关项与默认值。

## 详细修复步骤（逐点可执行）

- 事件接入
  - 文件：`src/auth/services/auth.service.ts`
    - 在登录成功返回前 emit `"auth.login.success"`，包含 `{ userId, clientIP, userAgent }`（从请求头或上层透传）。
    - 在鉴权失败抛出前 emit `"auth.login.failure"`，包含 `{ username, clientIP, userAgent, reason }`。
  - 文件（其一）：`src/auth/guards/apikey-auth.guard.ts` 或 `src/auth/services/apikey.service.ts`
    - 成功认证后 emit `"auth.apikey.used"`，包含 `{ apiKeyId, clientIP, userAgent, endpoint }`。

- 中间件 DI 化
  - 文件：`src/main.ts`
    - 删除手动 `new SecurityMiddleware()` 的注册代码。
  - 文件：`src/security/module/security.module.ts`（或 `app.module.ts`）
    - 实现 `configure(consumer: MiddlewareConsumer)` 注册 `SecurityMiddleware`。
    - 确保 `SecurityMiddleware` 可通过构造函数注入（若后续需要）。

- 移除冗余注入
  - 文件：`src/security/services/security-audit.service.ts`
    - 删除 `PaginationService` 的 import 与构造函数参数。

- 扫描项一致化与互斥
  - 文件：`src/security/services/security-scanner.service.ts`
    - 为“占位型”漏洞项增加配置条件或最小检查实现。
    - 新增 `isScanning` 标志位（try/finally 复位）或使用缓存锁。

## 兼容性与回滚

- 外部 API、响应结构与权限装饰器均不变。
- 仅新增事件与调整内部注册方式。
- 回滚方式：逐改逐回，删新增 emit；恢复 `main.ts` 中间件注册；恢复旧扫描项行为。

## 验收标准（DoD）

- 登录成功/失败、API Key 请求后，`/security/audit/events` 能查询到对应事件记录。
- 手动扫描与定时扫描不可并发；若重入，返回“已有扫描进行中”信息。
- 安全报告不再出现无条件的策略型漏洞项（或受配置开关控制）。
- 单元/集成/e2e 测试通过（至少覆盖事件接入、扫描互斥、仪表盘数据）。

## 任务分解与优先级

- 高（必须先做）
  - 接入认证与 API Key 审计事件（2人日）
  - 中间件 DI 化（0.5人日）

- 中
  - 扫描项一致化与开关（1人日）
  - 互斥控制（0.5人日）

- 低
  - 移除 `PaginationService` 注入（0.2人日）
  - 文档与 Swagger 描述同步（0.3人日）

## 代码定位索引（便于落地）

- 审计监听器（已实现）
```394:408:/Users/honor/Documents/code/newstockapi/backend/src/security/services/security-audit.service.ts
@OnEvent("auth.login.success")
async handleLoginSuccess(data: {
  userId: string;
  clientIP: string;
  userAgent: string;
}) {
  await this.logAuthenticationEvent(
    "user_login",
    "success",
    data.clientIP,
    data.userAgent,
    data.userId,
  );
}
```

- 登录服务（需发事件）
```128:142:/Users/honor/Documents/code/newstockapi/backend/src/auth/services/auth.service.ts
const { accessToken, refreshToken } =
  await this.tokenService.generateTokens(user);
...
return {
  user: user.toJSON() as User,
  accessToken,
  refreshToken,
};
```

- API Key 服务（可发事件）
```68:91:/Users/honor/Documents/code/newstockapi/backend/src/auth/services/apikey.service.ts
if (apiKey.expiresAt && apiKey.expiresAt < new Date()) {
  ...
}
// 更新使用统计（异步执行，不影响响应时间）
this.updateApiKeyUsage(apiKey._id.toString()).catch((error) => {
...
});
return apiKey;
```

- 手动实例化的中间件（需改为 DI）
```41:44:/Users/honor/Documents/code/newstockapi/backend/src/main.ts
const securityMiddleware = new SecurityMiddleware();
app.use(securityMiddleware.use.bind(securityMiddleware));
```

- 扫描器占位型漏洞（需开关/实现）
```328:333:/Users/honor/Documents/code/newstockapi/backend/src/security/services/security-scanner.service.ts
vulnerabilities.push(
  VulnerabilityTemplateUtil.createVulnerability("NO_MFA"),
);
```

## 提交说明与测试建议

- 提交粒度：按阶段拆分 PR，先“事件接入+中间件DI化+移除冗余”，再“扫描器一致化+互斥”。
- 测试：
  - 单测：`SecurityAuditService` 事件监听调用验证；`SecurityScannerService` 互斥与开关逻辑。
  - e2e：`test/jest/e2e/auth/controller/auth.controller.e2e.test.ts` 增补登录事件落库可查询；安全接口校验。

- 命令：
  - 类型检查：`npx tsc --noEmit`
  - 单测：`npx jest test/jest/unit/security/`
  - e2e：`npx jest test/jest/e2e/auth/` 

## 文档补充与优化（基于代码核查）

### 1) 事件接入位置与字段规范（建议落地）
- **登录事件触发位置（推荐 Controller 层）**：
  - 成功登录：在 `auth.controller.ts` 的 `login` 成功返回前 emit `"auth.login.success"`。
  - 失败登录：在捕获到 `UnauthorizedException`（或抛出前） emit `"auth.login.failure"`，保证失败事件不漏记。
  - 选择理由：Controller 拥有完整请求上下文（`clientIP`、`userAgent`），无需改动 `AuthService` 方法签名；与现有监听器数据结构完全对齐。
  - 可选方案（等价备选）：在 `AuthService.login` 注入 `EventEmitter2`，并从 Controller 透传 `clientIP`、`userAgent` 到 Service；侵入性更高，仅在必须时采用。
- **API Key 使用事件触发位置（推荐 Strategy 层）**：
  - 在 `auth/strategies/apikey.strategy.ts` 的 `validate(req)` 成功后 emit `"auth.apikey.used"`，事件体包含 `{ apiKeyId, clientIP, userAgent, endpoint }`，其中 `endpoint= req.originalUrl`。
  - 选择理由：Strategy 能获取完整请求上下文并处在鉴权“单点”，避免 Guard/Service 双处重复触发；与监听器的 `logDataAccessEvent` 语义更一致。
  - 若临时落在 `ApiKeyService.validateApiKey`：需增补 `endpoint` 获取途径，否则上下文缺失。
- **事件字段规范（统一来源）**：
  - `clientIP`、`userAgent` 统一使用 `HttpHeadersUtil` 获取并进行长度/字符清洗。
  - 登录失败事件补充 `reason` 与 `username`；API Key 事件包含 `endpoint` 与 `apiKeyId`。

### 2) 中间件 DI 化落地细化
- **注册位置与方式**：在 `SecurityModule`（或 `AppModule`）实现 `configure(consumer)`，按顺序注册：
  - `SecurityMiddleware` → `CSRFMiddleware` → `RateLimitByIPMiddleware`（如启用）
  - 路由范围建议：`forRoutes('api/v1/*')`；
  - 排除无需安全处理的端点：如 `exclude('/docs', '/health')`。
- **移除手动实例化**：删除 `main.ts` 中 `new SecurityMiddleware()` 与 `app.use(...)` 相关代码，避免绕过 DI 生命周期，便于未来注入依赖（如缓存/审计服务）。

### 3) 扫描项一致化与统计口径（避免“无条件告警”）
- **策略型占位项 gated 输出**：为 `NO_MFA`、`POTENTIAL_DATA_EXPOSURE`、`NOSQL_INJECTION_RISK` 增加配置开关（建议：`security.scanner.assumeBaselineRisks`，默认 `false`）。关闭时不产出相关漏洞项；开启时在扫描报告中标注“策略型告警”。
- **`totalChecks` 统计口径对齐**：
  - 当前从 `ALL_SECURITY_CHECKS.length` 取值，易与实际执行检查集合不一致。
  - 建议改为：以实际执行的检查函数集合计数（如 `checkPasswordSecurity`、`checkAPIKeySecurity`、`checkConfigurationSecurity`、`checkEncryptionSecurity`），或从各检查函数返回的“规则项集合”动态聚合去重后计数。
- **最小可行检查补齐**：如保留 `NO_MFA`，则以“是否启用 MFA 配置/策略”作为判定条件；数据暴露与 NoSQL 注入可基于已存在的输入检查/响应头策略给出“弱信号”判定与低严重度分级。

### 4) 并发互斥策略（优先分布式锁）
- **分布式锁（推荐）**：
  - 锁键：`security:scan:lock`；TTL：建议为 2×平均扫描耗时（如无历史基线，先取 120s）。
  - 获取失败时 Controller 返回“已有扫描进行中”（建议 HTTP 409 或 202 + `Retry-After`），避免重复入库与资源浪费。
  - `try/finally` 释放锁并兜底异常路径；若进程崩溃，TTL 过期自动释放。
- **进程内互斥（备选）**：`isScanning` 标志位 + `try/finally`；不跨进程，适用于单实例或临时方案。

### 5) 测试与监控补充
- **单元测试**：
  - `AuthController.login` 成功/失败路径是否分别 emit 对应事件（`EventEmitter2` mock 断言载荷字段完整性）。
  - `ApiKeyStrategy.validate` 成功后是否 emit 且包含 `endpoint`、`apiKeyId`、`clientIP`、`userAgent`。
  - `SecurityScannerService` 在开/关“策略型占位项”时的 `vulnerabilities` 差异与 `totalChecks` 一致性；锁重入返回是否符合预期。
- **e2e 测试**：
  - 登录成功/失败后 `/security/audit/events` 可查询到对应记录（字段与时间序一致）。
  - 使用 API Key 访问受保护端点后，`auth.apikey.used` 事件可落库可查询，`endpoint` 与调用路径匹配。
  - 定时扫描进行中再调用手动扫描，不发生并发扫描；接口返回“进行中”且无重复结果。
- **监控指标（可选）**：
  - 事件 emit 计数、审计日志 flush 成功/失败计数、扫描锁等待/占用时长分布；在 `/security/dashboard` 增补展示趋势。

### 6) 验收标准（DoD）补充
- 登录/失败、API Key 使用事件记录的字段完整性校验（含 `clientIP`、`userAgent`、`endpoint`/`reason` 等）。
- 手动/定时扫描不可并发；并发请求返回“已有扫描进行中”，且无重复入库。
- 在默认配置下不再出现“无条件的策略型漏洞项”；开启开关后以“策略型”标记显示。
- `totalChecks` 与实际执行检查集合一致，报告分与基线一致或有合理解释。

### 7) 提交与回滚建议（精细化）
- **PR 1（低风险）**：事件接入（Controller + Strategy）、中间件 DI 化（删除 `main.ts` 手动注册）、移除 `PaginationService` 冗余注入；补充单元/e2e。
- **PR 2（中风险）**：扫描项开关与统计口径统一、扫描互斥（分布式锁优先）；同步更新文档与演示口径。
- **回滚策略**：
  - 事件：移除新增 emit；
  - 中间件：恢复 `main.ts` 注册；
  - 扫描：关闭“策略型占位项”开关或恢复旧统计口径；
  - 互斥：移除锁逻辑或退回进程内互斥。 