### å¯æ‰§è¡Œçš„é—ç•™ä»£ç ä¿®å¤æ–‡æ¡£ï¼ˆç›‘æ§/æŒ‡æ ‡å­ç³»ç»Ÿï¼‰

â€”â€” èšç„¦â€œè€ç‰ˆåº”ç”¨å†…æŒ‡æ ‡ç³»ç»Ÿâ€ä¸â€œæ–° Prometheus æ³¨å†Œä¸­å¿ƒâ€å¹¶å­˜å¯¼è‡´çš„æ¶æ„å†²çªï¼Œæä¾›åˆ†é˜¶æ®µæ›¿æ¢æ–¹æ¡ˆï¼Œä¿æŒå¯¹å¤–å¥‘çº¦ä¸å˜

## 1. æ¶æ„æ¨¡å¼å¯¹æ¯”ä¸èƒŒæ™¯

- æ—§æ¶æ„ï¼ˆåº”ç”¨å†…ç»Ÿè®¡ã€å­˜å‚¨é©±åŠ¨ï¼‰
  - æ ¸å¿ƒï¼š`PerformanceMonitorService`ï¼ˆåº”ç”¨å†…ç¼“å†² + ä»“å‚¨è®°å½• + å…¨å±€æ‹¦æˆªå™¨/è£…é¥°å™¨ï¼‰
  - å…³é”®å…¥å£ï¼š
```1:160:src/main.ts
  const performanceMonitor = app.get(PerformanceMonitorService);
  app.useGlobalInterceptors(new PerformanceInterceptor(performanceMonitor, reflector));
  global["performanceMonitorService"] = performanceMonitor;
```
  - è£…é¥°å™¨é€šè¿‡ `global["performanceMonitorService"]` é—´æ¥è°ƒç”¨ï¼š
```1:101:src/metrics/decorators/database-performance.decorator.ts
const performanceMonitor =
  this.performanceMonitor || (global["performanceMonitorService"] as PerformanceMonitorService);
```
  - æœåŠ¡å®ç°ï¼ˆèŠ‚é€‰ï¼‰ï¼š
```1:120:src/metrics/services/performance-monitor.service.ts
@Injectable()
export class PerformanceMonitorService {
  // è®°å½•æ•°æ®åº“æŸ¥è¯¢ã€ç¼“å­˜æ“ä½œã€è®¤è¯ç­‰ï¼Œå¹¶å­˜å‚¨/èšåˆåˆ°ä»“å‚¨
```

- æ–°æ¶æ„ï¼ˆPrometheus æ³¨å†Œä¸­å¿ƒç»Ÿä¸€æŒ‡æ ‡ï¼‰
  - æ ¸å¿ƒï¼š`MetricsRegistryService` + è½»é‡ `Metrics` å·¥å…·
  - ç»Ÿä¸€åœ¨æ³¨å†Œä¸­å¿ƒåˆ›å»º `Counter/Gauge/Histogram`ï¼Œå¹¶ç» `GET /monitoring/metrics` å¯¼å‡º
    - æ³¨å†Œä¸­å¿ƒï¼š
```1:120:src/monitoring/metrics/services/metrics-registry.service.ts
export class MetricsRegistryService implements OnModuleInit, OnModuleDestroy {
  constructor(private readonly featureFlags: FeatureFlags) {
    this.registry = new Registry();
    collectDefaultMetrics({ register: this.registry, prefix: 'newstock_', ... });
```
    - ä¸šåŠ¡å±‚è°ƒç”¨é€šè¿‡ `Metrics` å·¥å…·è§£è€¦ï¼š
```1:130:src/monitoring/metrics/metrics-helper.ts
export class Metrics {
  static inc(registry: MetricsRegistryService, name: string, labels?: object, value = 1, legacyCallback?: () => void)
```
    - Prometheus å¯¼å‡ºç«¯ç‚¹ï¼ˆå·²å­˜åœ¨ï¼‰ï¼š
```800:1025:src/monitoring/controller/monitoring.controller.ts
@Get("metrics")
async getPrometheusMetrics(@Res() res: Response) {
  const metricsData = await this.metricsRegistry.getMetrics();
  res.setHeader('Content-Type', 'text/plain; version=0.0.4; charset=utf-8');
  res.send(metricsData);
}
```

ç»“è®ºï¼šå½“å‰ç³»ç»ŸåŒæ—¶è¿è¡Œä¸¤å¥—æŒ‡æ ‡ä½“ç³»ï¼ˆæ—§åº”ç”¨å†…ç»Ÿè®¡ + æ–° Prometheus æ³¨å†Œä¸­å¿ƒï¼‰ï¼Œä¸”åœ¨ä¾èµ–æ³¨å…¥å±‚é¢å¯¹æ³¨å†Œä¸­å¿ƒå­˜åœ¨â€œé‡å¤å®ä¾‹åŒ–â€é£é™©ï¼Œå¯¼è‡´æŒ‡æ ‡å†™å…¥ä¸å¯¼å‡ºå¯èƒ½æ¥è‡ªä¸åŒå®ä¾‹ã€‚

## 2. é—®é¢˜æ ‡è®°ï¼ˆå«è¯æ®ä¸å†²çªè¯´æ˜ï¼‰

- ä¸¥é‡-Criticalï½œé‡å¤å®ä¾‹åŒ– `MetricsRegistryService`
  - è¯æ®1ï¼šå…¨å±€å…±äº«æ¨¡å—å·²æä¾›æ³¨å†Œä¸­å¿ƒï¼ˆGlobalï¼‰
```1:65:src/core/shared/module/shared-services.module.ts
@Global()
@Module({
  providers: [FeatureFlags, MetricsRegistryService, ...],
  exports:   [FeatureFlags, MetricsRegistryService, ...],
})
```
  - è¯æ®2ï¼š`MonitoringModule` ä¹Ÿæœ¬åœ°æä¾›/å¯¼å‡ºåŒä¸€æœåŠ¡
```1:20:src/monitoring/module/monitoring.module.ts
providers: [MetricsInitializerService, MetricsRegistryService],
exports: [MetricsInitializerService, MetricsRegistryService],
```
  - å†²çªè¯´æ˜ï¼šNestJS ä¸­ç›¸åŒ token åœ¨ä¸åŒæ¨¡å—å„è‡ªå®ä¾‹åŒ–ã€‚ä¸šåŠ¡æœåŠ¡ï¼ˆé€šè¿‡ `SharedServicesModule` æ³¨å…¥çš„å…¨å±€å®ä¾‹ï¼‰å†™å…¥ A å®ä¾‹ï¼›æ§åˆ¶å™¨ï¼ˆé€šè¿‡ `MonitoringModule` æä¾›è€…ï¼‰å¯¼å‡º B å®ä¾‹ã€‚Prometheus å¯¼å‡ºå¯èƒ½ä¸åŒ…å«ä¸šåŠ¡è®¡æ•°ï¼Œå‡ºç°â€œå†™ Aã€è¯» Bâ€ç°è±¡ã€‚

- é«˜-Highï½œæ—§ç³»ç»Ÿå¼ºä¾èµ–å…¨å±€å¯å˜çŠ¶æ€ä¸ä¸“ç”¨æ‹¦æˆªå™¨
  - è¯æ®ï¼š
```1:160:src/main.ts
global["performanceMonitorService"] = performanceMonitor;
```
```1:101:src/metrics/decorators/database-performance.decorator.ts
(global["performanceMonitorService"] as PerformanceMonitorService)
```
  - å†²çªè¯´æ˜ï¼šå…¨å±€å¯å˜çŠ¶æ€å¯¹æµ‹è¯•å¯é æ€§ã€æ¨¡å—åŒ–å’Œå¹¶å‘ç¯å¢ƒä¸å‹å¥½ï¼›ä¸”ä¸ Prometheus æ— å…³ï¼Œéš¾ä»¥ç»Ÿä¸€ã€‚

- é«˜-Highï½œç›‘æ§æ§åˆ¶å™¨æ··ç”¨ä¸¤å¥—ä½“ç³»
  - è¯æ®ï¼šåŒæ—¶æ³¨å…¥ `PerformanceMonitorService` å’Œ `MetricsRegistryService`ï¼Œå¹¶æš´éœ²ä¸¤ç±»æ¥å£
```39:47:src/monitoring/controller/monitoring.controller.ts
constructor(
  private readonly performanceMonitor: PerformanceMonitorService,
  private readonly metricsRegistry: MetricsRegistryService,
```
  - å†²çªè¯´æ˜ï¼šè°ƒç”¨æ–¹æ— æ³•æ˜ç¡®â€œæƒå¨æ•°æ®æºâ€ã€‚å¼•å…¥è¿ç§»æœŸæ•°æ®ä¸ä¸€è‡´é£é™©ã€‚

- ä¸­-Mediumï½œ`MetricsModule`ï¼ˆæ—§ï¼‰ä»è¢« `AppModule` ä¸ `MonitoringModule` å¼•å…¥
```24:116:src/app.module.ts
imports: [ ..., MonitoringModule, ..., MetricsModule, ... ]
```
```1:20:src/monitoring/module/monitoring.module.ts
imports: [ ..., MetricsModule, SharedServicesModule ]
```
  - å†²çªè¯´æ˜ï¼šæ–°æ—§æ¨¡å—äº¤å‰å¼•ç”¨ï¼Œä»¤è¿ç§»æ”¶æ•›éš¾åº¦ä¸Šå‡ã€‚

- ä¸­-Mediumï½œé»˜è®¤æŒ‡æ ‡æ³¨å†Œå¤šå®ä¾‹éšæ‚£
  - è¯æ®ï¼š`collectDefaultMetrics({ register: this.registry })` ç»‘å®šåˆ°æ„é€ çš„ registry å®ä¾‹  
  - å†²çªè¯´æ˜ï¼šè‹¥é‡å¤å®ä¾‹åŒ–ï¼Œå°†äº§ç”Ÿå¤šä»½â€œé»˜è®¤ç³»ç»ŸæŒ‡æ ‡â€ï¼Œå¯¼å‡ºç«¯ç‚¹ä¸ä¸šåŠ¡å†™å…¥é”™ä½ã€‚

## 3. åˆ†é˜¶æ®µæ›¿æ¢æ–¹æ¡ˆï¼ˆä¿æŒæ¥å£å¥‘çº¦ä¸å˜ï¼‰

- Phase 0ï¼ˆç«‹å³ï¼Œ1 å¤©ï¼‰
  - ç›®æ ‡ï¼šæ¶ˆé™¤â€œé‡å¤å®ä¾‹åŒ–â€ï¼Œå¯¹å¤–è¡Œä¸ºä¸å˜
  - åŠ¨ä½œï¼š
    - ç»Ÿä¸€ `MetricsRegistryService` çš„æä¾›è€…æ¥æºï¼Œä»…ä¿ç•™ `SharedServicesModule`ï¼ˆGlobalï¼‰æä¾›ï¼›`MonitoringModule` ä¸å†å•ç‹¬æä¾›/å¯¼å‡ºè¯¥æœåŠ¡ï¼Œæ”¹ä¸ºä¾èµ–å…¨å±€å¯¼å‡ºã€‚
    - éªŒè¯æ‰€æœ‰æ³¨å…¥ç‚¹å‡å–åˆ°åŒä¸€å®ä¾‹ï¼ˆåœ¨ä¸€å¤„è¾“å‡º `registry.metrics()` é•¿åº¦ï¼Œå¯¹æ¯”æ§åˆ¶å™¨å¯¼å‡ºçš„æŒ‡æ ‡æ•°ä¸€è‡´ï¼‰ã€‚
  - é£é™©æ§åˆ¶ï¼šçº¯ DI å±‚è°ƒæ•´ï¼Œæ— ä¸šåŠ¡é€»è¾‘å˜æ›´ã€‚è‹¥å¿…é¡»ä¸´æ—¶ä¿ç•™ `MonitoringModule` æä¾›è€…ï¼Œåˆ™æ”¹ä¸º `useExisting: MetricsRegistryService` æŒ‡å‘å…¨å±€å®ä¾‹ï¼Œé¿å…åŒå®ä¾‹ã€‚

- Phase 1ï¼ˆçŸ­æœŸï¼Œ2-3 å¤©ï¼‰
  - ç›®æ ‡ï¼šåœæ­¢æ–°å¢æ—§ä½“ç³»ä¾èµ–ã€æ”¶æŸå…¥å£
  - åŠ¨ä½œï¼š
    - åœ¨ `PerformanceMonitorService` ä¸­å¼•å…¥â€œé€‚é…å±‚â€ï¼Œå°†æ ¸å¿ƒåŸ‹ç‚¹åŒæ—¶è½¬å‘åˆ° `MetricsRegistryService`ï¼ˆé€šè¿‡ `Metrics` å·¥å…·ï¼‰ï¼Œä¿æŒåŸä»“å‚¨å†™å…¥ä¸å˜ã€‚å¯¹å¤– DTO/æ¥å£ä¿æŒä¸å˜ã€‚
    - åœ¨ `PerformanceInterceptor` å’Œè£…é¥°å™¨ä¸­å¢åŠ å¯¹ `Metrics` çš„è°ƒç”¨ï¼Œä½†ä¿ç•™åŸé€»è¾‘ï¼Œç¡®ä¿ä¸¤è¾¹æ•°æ®ä¸€è‡´æœŸã€‚
    - å°† `MetricsInitializerService` çš„ `legacyMode` å›ºå®šä¸º falseï¼ˆç°å·²å¦‚æ­¤ï¼‰ï¼Œå¹¶æ ‡æ³¨å¼ƒç”¨æ—§å†…å­˜ç»Ÿè®¡è·¯å¾„ã€‚
  - é£é™©æ§åˆ¶ï¼šåŒå†™æœŸé—´è‹¥ Prometheus æŒ‡æ ‡é—æ¼ï¼Œå¯å›æº¯æ—§ä»“å‚¨æ•°æ®ã€‚

- Phase 2ï¼ˆä¸­æœŸï¼Œ1-2 å‘¨ï¼‰
  - ç›®æ ‡ï¼šæ›¿æ¢è°ƒç”¨æ–¹åˆ°æ–°æ³¨å†Œä¸­å¿ƒï¼Œæ·¡åŒ–æ—§æœåŠ¡
  - åŠ¨ä½œï¼š
    - `MonitoringController` çš„â€œæ€§èƒ½/æ•°æ®åº“/Redis/ç³»ç»Ÿâ€æŸ¥è¯¢æ¥å£ç»´æŒ DTO ä¸å˜ï¼Œä½†å†…éƒ¨è®¡ç®—é€æ­¥æ”¹ç”¨ Prometheus æŒ‡æ ‡ï¼ˆæˆ–ä» `MetricsRegistryService.getMetricsSummary()` è¡ç”Ÿï¼‰ï¼Œä»¥å‡å°‘å¯¹æ—§ä»“å‚¨çš„å¼ºä¾èµ–ã€‚
    - å°† `main.ts` çš„å…¨å±€å˜é‡è®¿é—®æ›¿æ¢ä¸ºæ ‡å‡† DIï¼Œç”¨äºè£…é¥°å™¨/æ‹¦æˆªå™¨è·å– `PerformanceMonitorService` æˆ–ç›´æ¥æ¥å— `MetricsRegistryService` çš„è½»é‡å°è£…ã€‚
    - æ˜ç¡®â€œæƒå¨æŒ‡æ ‡æºâ€ä¸º Prometheusï¼Œæ—§ä»“å‚¨ä»…ä¸ºè¿‡æ¸¡æœŸå¤‡ä»½ã€‚
  - é£é™©æ§åˆ¶ï¼šæŒ‰ç«¯ç‚¹é€é¡¹æ›¿æ¢ï¼Œå•ç‚¹å›é€€å®¹æ˜“ã€‚

- Phase 3ï¼ˆæ”¶å°¾ï¼Œ1 å‘¨ï¼‰
  - ç›®æ ‡ï¼šç§»é™¤æ—§ä½“ç³»ã€æ¸…ç†å†—ä½™æ¨¡å—ä¸å…¨å±€çŠ¶æ€
  - åŠ¨ä½œï¼š
    - åœç”¨å…¨å±€å˜é‡ `global["performanceMonitorService"]`ï¼›å°† `DatabasePerformance`/`CachePerformance`/`AuthPerformance` è£…é¥°å™¨æ”¹ä¸ºç›´æ¥ä½¿ç”¨ `Metrics` å†™å…¥æ³¨å†Œä¸­å¿ƒã€‚
    - è¯„ä¼° `MetricsModule`ï¼ˆæ—§ï¼‰æ˜¯å¦ä»éœ€ä¿ç•™ï¼›è‹¥ä¸å†éœ€è¦ï¼Œè¿›è¡Œæ¨¡å—ä¸‹çº¿ï¼ˆå…ˆä» `MonitoringModule` ç§»é™¤ï¼Œå†ä» `AppModule` ç§»é™¤ï¼‰ã€‚
    - å»é™¤æ—§ä»“å‚¨è·¯å¾„çš„å†™å…¥ï¼Œä¿ç•™åªè¯»è¿ç§»è§‚æµ‹ä¸€æ®µæ—¶é—´åå®Œå…¨åˆ é™¤ã€‚
  - é£é™©æ§åˆ¶ï¼šä»¥å¼€å…³æˆ–ç¯å¢ƒå˜é‡æ§åˆ¶â€œæ—§ä»“å‚¨å†™å…¥æ˜¯å¦å¼€å¯â€ï¼Œç¡®ä¿ç°åº¦ä¸‹çº¿ã€‚

## 4. è¯¦ç»†é—®é¢˜é¡¹ä¸ä¿®å¤æ­¥éª¤

### 4.1 é—®é¢˜ Aï¼ˆCriticalï¼‰ï¼šMetricsRegistryService å¤šå®ä¾‹å†²çª

**é—®é¢˜è¯†åˆ«ä¸å½±å“åˆ†æ**ï¼š
- **æ ¹æœ¬åŸå› **ï¼šåŒä¸€æœåŠ¡åœ¨ä¸åŒæ¨¡å—ä¸­é‡å¤æä¾›ï¼Œå¯¼è‡´ NestJS åˆ›å»ºå¤šä¸ªå®ä¾‹
- **ä¸šåŠ¡å½±å“**ï¼šä¸šåŠ¡æœåŠ¡å†™å…¥å®ä¾‹Aï¼Œç›‘æ§ç«¯ç‚¹è¯»å–å®ä¾‹Bï¼Œé€ æˆæŒ‡æ ‡ä¸¢å¤±
- **æŠ€æœ¯å€ºåŠ¡**ï¼šè¿åå•ä¾‹åŸåˆ™ï¼Œå¢åŠ å†…å­˜å ç”¨å’Œè°ƒè¯•å¤æ‚åº¦

**ä»£ç å®šä½ä¸ç°çŠ¶**ï¼š
```typescript
// src/core/shared/module/shared-services.module.ts (å…¨å±€æä¾›)
@Global()
@Module({
  providers: [FeatureFlags, MetricsRegistryService, CommonCacheService],
  exports: [FeatureFlags, MetricsRegistryService, CommonCacheService],
})

// src/monitoring/module/monitoring.module.ts (æœ¬åœ°é‡å¤æä¾›)
@Module({
  providers: [MetricsInitializerService, MetricsRegistryService], // ğŸš¨ é‡å¤å®ä¾‹åŒ–
  exports: [MetricsInitializerService, MetricsRegistryService],
})
```

**å¢å¼ºä¿®å¤æ–¹æ¡ˆ**ï¼š

1. **ç«‹å³ä¿®å¤ï¼ˆPhase 0ï¼‰**ï¼š
```typescript
// ä¿®æ”¹ src/monitoring/module/monitoring.module.ts
@Module({
  imports: [SharedServicesModule], // ç¡®ä¿ä¾èµ–å…¨å±€æ¨¡å—
  providers: [
    MetricsInitializerService,
    // ç§»é™¤ MetricsRegistryService æˆ–ä½¿ç”¨ useExisting
    {
      provide: MetricsRegistryService,
      useExisting: MetricsRegistryService, // æŒ‡å‘å…¨å±€å®ä¾‹
    }
  ],
  exports: [MetricsInitializerService], // ä¸å†å¯¼å‡º MetricsRegistryService
  controllers: [MonitoringController],
})
export class MonitoringModule {}
```

2. **å®ä¾‹éªŒè¯è„šæœ¬**ï¼š
```typescript
// æ·»åŠ åˆ° src/monitoring/services/metrics-validation.service.ts
@Injectable()
export class MetricsValidationService {
  constructor(private readonly metricsRegistry: MetricsRegistryService) {}

  async validateSingleInstance(): Promise<boolean> {
    // ç”Ÿæˆå”¯ä¸€æ ‡è¯†ç¬¦å¹¶å†™å…¥æŒ‡æ ‡
    const testId = `test_${Date.now()}_${Math.random()}`;
    
    // ä¸šåŠ¡å±‚å†™å…¥
    Metrics.inc(this.metricsRegistry, 'validation_test_counter', {
      test_id: testId,
      source: 'business'
    });

    // ç­‰å¾…æŒ‡æ ‡å¤„ç†
    await new Promise(resolve => setTimeout(resolve, 100));

    // æ£€æŸ¥å¯¼å‡ºç«¯ç‚¹æ˜¯å¦åŒ…å«è¯¥æŒ‡æ ‡
    const metricsText = await this.metricsRegistry.getMetrics();
    const containsMetric = metricsText.includes(`validation_test_counter{test_id="${testId}"`);

    return containsMetric;
  }

  async getInstanceInfo(): Promise<{
    registryId: string;
    metricsCount: number;
    defaultMetricsEnabled: boolean;
  }> {
    const registry = (this.metricsRegistry as any).registry;
    return {
      registryId: registry._id || 'unknown',
      metricsCount: registry.getMetricsAsArray().length,
      defaultMetricsEnabled: registry._defaultLabels !== undefined,
    };
  }
}
```

3. **å¥åº·æ£€æŸ¥é›†æˆ**ï¼š
```typescript
// åœ¨ src/monitoring/controller/monitoring.controller.ts ä¸­æ·»åŠ 
@Get('metrics-health')
@Auth([UserRole.ADMIN])
async checkMetricsHealth(): Promise<{
  singleInstance: boolean;
  instanceInfo: any;
  registryConsistency: boolean;
}> {
  const singleInstance = await this.validationService.validateSingleInstance();
  const instanceInfo = await this.validationService.getInstanceInfo();
  
  return {
    singleInstance,
    instanceInfo,
    registryConsistency: singleInstance && instanceInfo.metricsCount > 0,
  };
}
```

### 4.2 é—®é¢˜ Bï¼ˆHighï¼‰ï¼šå…¨å±€çŠ¶æ€æ¶ˆé™¤ä¸ DI æ ‡å‡†åŒ–

**é—®é¢˜è¯†åˆ«ä¸æŠ€æœ¯å€ºåŠ¡**ï¼š
- **å…¨å±€æ±¡æŸ“**ï¼š`global["performanceMonitorService"]` ç ´åæ¨¡å—è¾¹ç•Œ
- **æµ‹è¯•å›°éš¾**ï¼šå…¨å±€çŠ¶æ€å¯¼è‡´æµ‹è¯•éš”ç¦»é—®é¢˜
- **å¹¶å‘é£é™©**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„ç«æ€æ¡ä»¶éšæ‚£

**ä»£ç å®šä½ä¸ç°çŠ¶**ï¼š
```typescript
// src/main.ts (çº¦78è¡Œï¼Œé160è¡Œ)
const performanceMonitor = app.get(PerformanceMonitorService);
app.useGlobalInterceptors(new PerformanceInterceptor(performanceMonitor, reflector));
global["performanceMonitorService"] = performanceMonitor; // ğŸš¨ å…¨å±€çŠ¶æ€

// src/metrics/decorators/database-performance.decorator.ts
const performanceMonitor = 
  this.performanceMonitor || (global["performanceMonitorService"] as PerformanceMonitorService);
```

**å¢å¼ºé‡æ„æ–¹æ¡ˆ**ï¼š

1. **Phase 1 - åŒå†™é€‚é…å±‚**ï¼š
```typescript
// å¢å¼º src/metrics/services/performance-monitor.service.ts
@Injectable()
export class PerformanceMonitorService implements OnModuleInit {
  private readonly logger = createLogger(PerformanceMonitorService.name);

  constructor(
    private readonly metricsRegistry: MetricsRegistryService,
    @Inject(forwardRef(() => FeatureFlags)) private readonly featureFlags: FeatureFlags,
  ) {}

  async onModuleInit() {
    // æ£€æŸ¥åŒå†™æ¨¡å¼é…ç½®
    const dualWriteEnabled = await this.featureFlags.isEnabled('metrics.dual_write_mode');
    this.logger.log(`Performance monitor initialized with dual write: ${dualWriteEnabled}`);
  }

  async recordDatabaseQuery(operation: string, duration: number, metadata?: any): Promise<void> {
    // ä¿æŒåŸæœ‰ä»“å‚¨å†™å…¥
    await this.recordToStorage(operation, duration, metadata);

    // æ–°å¢ Prometheus å†™å…¥
    if (await this.featureFlags.isEnabled('metrics.prometheus_write')) {
      Metrics.observe(this.metricsRegistry, 'database_query_duration_ms', duration, {
        operation,
        provider: metadata?.provider || 'unknown',
        success: metadata?.success ? 'true' : 'false',
      });

      Metrics.inc(this.metricsRegistry, 'database_operations_total', {
        operation,
        provider: metadata?.provider || 'unknown',
      });
    }
  }

  private async recordToStorage(operation: string, duration: number, metadata?: any): Promise<void> {
    // ç°æœ‰çš„ä»“å‚¨é€»è¾‘ä¿æŒä¸å˜
    // ... existing storage logic
  }
}
```

2. **Phase 2 - è£…é¥°å™¨ DI æ ‡å‡†åŒ–**ï¼š
```typescript
// é‡æ„ src/metrics/decorators/database-performance.decorator.ts
export function DatabasePerformance(options?: PerformanceOptions) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const startTime = Date.now();
      let result: any;
      let error: any;

      try {
        result = await originalMethod.apply(this, args);
        return result;
      } catch (err) {
        error = err;
        throw err;
      } finally {
        const duration = Date.now() - startTime;

        // ä½¿ç”¨ NestJS åº”ç”¨ä¸Šä¸‹æ–‡è·å–æœåŠ¡å®ä¾‹
        const app = await NestFactory.createApplicationContext(AppModule, { logger: false });
        const performanceMonitor = app.get(PerformanceMonitorService);
        
        await performanceMonitor.recordDatabaseQuery(
          propertyName,
          duration,
          {
            success: !error,
            operation: options?.operation || propertyName,
            provider: options?.provider,
            error: error?.message,
          }
        );

        await app.close();
      }
    };

    return descriptor;
  };
}
```

3. **Phase 2.5 - è½»é‡çº§ Metrics è£…é¥°å™¨**ï¼š
```typescript
// æ–°å¢ src/monitoring/decorators/prometheus-performance.decorator.ts
export function PrometheusPerformance(metricName: string, options?: {
  labels?: Record<string, string>;
  threshold?: number;
}) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const className = target.constructor.name;

    descriptor.value = async function (...args: any[]) {
      const startTime = Date.now();
      const labels = {
        class: className,
        method: propertyName,
        ...options?.labels,
      };

      try {
        const result = await originalMethod.apply(this, args);
        
        const duration = Date.now() - startTime;
        
        // ç›´æ¥ä½¿ç”¨æ³¨å…¥çš„ MetricsRegistryService
        if (this.metricsRegistry) {
          Metrics.observe(this.metricsRegistry, `${metricName}_duration_ms`, duration, labels);
          Metrics.inc(this.metricsRegistry, `${metricName}_total`, { ...labels, status: 'success' });
          
          // æ€§èƒ½è­¦å‘Š
          if (options?.threshold && duration > options.threshold) {
            Metrics.inc(this.metricsRegistry, `${metricName}_slow_total`, labels);
          }
        }

        return result;
      } catch (error) {
        const duration = Date.now() - startTime;
        
        if (this.metricsRegistry) {
          Metrics.observe(this.metricsRegistry, `${metricName}_duration_ms`, duration, labels);
          Metrics.inc(this.metricsRegistry, `${metricName}_total`, { 
            ...labels, 
            status: 'error',
            error_type: error.constructor.name,
          });
        }

        throw error;
      }
    };

    return descriptor;
  };
}
```

### 4.3 é—®é¢˜ Cï¼ˆHighï¼‰ï¼šç›‘æ§æ§åˆ¶å™¨åŒä½“ç³»ç»Ÿä¸€

**ç°çŠ¶åˆ†æ**ï¼š
- åŒæ—¶æ³¨å…¥ä¸¤å¥—ç›‘æ§æœåŠ¡ï¼ŒAPIå“åº”æ•°æ®æ¥æºä¸æ˜ç¡®
- è¿ç§»æœŸé—´å¯èƒ½å‡ºç°æ•°æ®ä¸ä¸€è‡´
- è°ƒç”¨æ–¹æ— æ³•åˆ¤æ–­æƒå¨æ•°æ®æº

**å¢å¼ºè¿ç§»æ–¹æ¡ˆ**ï¼š

1. **æ§åˆ¶å™¨é€‚é…å±‚é‡æ„**ï¼š
```typescript
// é‡æ„ src/monitoring/controller/monitoring.controller.ts
@Controller('monitoring')
export class MonitoringController {
  private readonly logger = createLogger(MonitoringController.name);

  constructor(
    private readonly performanceMonitor: PerformanceMonitorService,
    private readonly metricsRegistry: MetricsRegistryService,
    private readonly featureFlags: FeatureFlags,
  ) {}

  @Get('performance')
  @Auth([UserRole.ADMIN])
  async getPerformanceMetrics(
    @Query() query: PerformanceQueryDto,
  ): Promise<PerformanceMetricsDto> {
    // æ™ºèƒ½æ•°æ®æºé€‰æ‹©
    const usePrometheus = await this.featureFlags.isEnabled('metrics.prometheus_primary');
    
    if (usePrometheus) {
      return this.getPerformanceFromPrometheus(query);
    } else {
      return this.getPerformanceFromStorage(query);
    }
  }

  @Get('database')
  @Auth([UserRole.ADMIN])
  async getDatabaseMetrics(
    @Query() query: DatabaseQueryDto,
  ): Promise<DatabaseMetricsDto> {
    const usePrometheus = await this.featureFlags.isEnabled('metrics.prometheus_primary');
    
    if (usePrometheus) {
      return this.getDatabaseFromPrometheus(query);
    } else {
      return this.getDatabaseFromStorage(query);
    }
  }

  private async getPerformanceFromPrometheus(query: PerformanceQueryDto): Promise<PerformanceMetricsDto> {
    try {
      const metricsData = await this.metricsRegistry.getMetrics();
      
      // è§£æ Prometheus æ–‡æœ¬æ ¼å¼æŒ‡æ ‡
      const parsed = this.parsePrometheusMetrics(metricsData);
      
      return {
        totalRequests: this.extractCounter(parsed, 'http_requests_total'),
        averageResponseTime: this.extractHistogramAvg(parsed, 'http_request_duration_ms'),
        errorRate: this.calculateErrorRate(parsed),
        throughput: this.calculateThroughput(parsed, query.timeRange),
        dataSource: 'prometheus',
        lastUpdated: new Date(),
      };
    } catch (error) {
      this.logger.warn(`Prometheus æ•°æ®è·å–å¤±è´¥ï¼Œå›é€€åˆ°å­˜å‚¨æ•°æ®æº: ${error.message}`);
      return this.getPerformanceFromStorage(query);
    }
  }

  private async getDatabaseFromPrometheus(query: DatabaseQueryDto): Promise<DatabaseMetricsDto> {
    try {
      const metricsData = await this.metricsRegistry.getMetrics();
      const parsed = this.parsePrometheusMetrics(metricsData);
      
      return {
        queryCount: this.extractCounter(parsed, 'database_operations_total'),
        averageQueryTime: this.extractHistogramAvg(parsed, 'database_query_duration_ms'),
        slowQueries: this.extractCounter(parsed, 'database_operations_slow_total'),
        connectionPool: this.extractGauge(parsed, 'database_connections_active'),
        dataSource: 'prometheus',
        lastUpdated: new Date(),
      };
    } catch (error) {
      this.logger.warn(`Prometheus æ•°æ®åº“æŒ‡æ ‡è·å–å¤±è´¥ï¼Œå›é€€åˆ°å­˜å‚¨æ•°æ®æº: ${error.message}`);
      return this.getDatabaseFromStorage(query);
    }
  }

  // ä¿ç•™åŸæœ‰å­˜å‚¨æ•°æ®æºæ–¹æ³•ä½œä¸ºåå¤‡
  private async getPerformanceFromStorage(query: PerformanceQueryDto): Promise<PerformanceMetricsDto> {
    const data = await this.performanceMonitor.getPerformanceMetrics(query);
    return { ...data, dataSource: 'storage', lastUpdated: new Date() };
  }

  private async getDatabaseFromStorage(query: DatabaseQueryDto): Promise<DatabaseMetricsDto> {
    const data = await this.performanceMonitor.getDatabaseMetrics(query);
    return { ...data, dataSource: 'storage', lastUpdated: new Date() };
  }
}
```

2. **Prometheus æŒ‡æ ‡è§£æå·¥å…·**ï¼š
```typescript
// æ–°å¢ src/monitoring/utils/prometheus-parser.util.ts
export class PrometheusParserUtil {
  static parseMetrics(metricsText: string): Map<string, MetricData[]> {
    const lines = metricsText.split('\n');
    const metrics = new Map<string, MetricData[]>();

    for (const line of lines) {
      if (line.startsWith('#') || !line.trim()) continue;

      const match = line.match(/^([a-zA-Z_]+)(\{.*?\})?\s+([0-9.]+)(\s+[0-9]+)?$/);
      if (!match) continue;

      const [, name, labels, value, timestamp] = match;
      
      if (!metrics.has(name)) {
        metrics.set(name, []);
      }

      metrics.get(name)!.push({
        name,
        labels: this.parseLabels(labels),
        value: parseFloat(value),
        timestamp: timestamp ? parseInt(timestamp.trim()) : Date.now(),
      });
    }

    return metrics;
  }

  private static parseLabels(labelsStr?: string): Record<string, string> {
    if (!labelsStr) return {};

    const labels: Record<string, string> = {};
    const cleaned = labelsStr.slice(1, -1); // ç§»é™¤ { }

    const pairs = cleaned.split(',');
    for (const pair of pairs) {
      const [key, value] = pair.split('=');
      if (key && value) {
        labels[key.trim()] = value.trim().slice(1, -1); // ç§»é™¤å¼•å·
      }
    }

    return labels;
  }
}

interface MetricData {
  name: string;
  labels: Record<string, string>;
  value: number;
  timestamp: number;
}
```

### 4.4 å¢å¼ºéªŒè¯ä¸æµ‹è¯•æ¡†æ¶

**å¤šå±‚çº§éªŒè¯ç­–ç•¥**ï¼š

1. **å•å…ƒæµ‹è¯•å¢å¼º**ï¼š
```typescript
// test/jest/unit/monitoring/metrics-registry.service.spec.ts
describe('MetricsRegistryService å•ä¾‹éªŒè¯', () => {
  let app: TestingModule;
  let metricsRegistry1: MetricsRegistryService;
  let metricsRegistry2: MetricsRegistryService;

  beforeAll(async () => {
    app = await Test.createTestingModule({
      imports: [SharedServicesModule, MonitoringModule],
    }).compile();

    metricsRegistry1 = app.get(MetricsRegistryService);
    metricsRegistry2 = app.get(MetricsRegistryService, { strict: false });
  });

  it('åº”è¯¥ç¡®ä¿å…¨å±€å•ä¾‹', () => {
    expect(metricsRegistry1).toBe(metricsRegistry2);
  });

  it('ä¸šåŠ¡å†™å…¥åå¯¼å‡ºç«¯ç‚¹åº”åæ˜ å˜åŒ–', async () => {
    const testMetric = `test_metric_${Date.now()}`;
    
    // ä¸šåŠ¡æœåŠ¡å†™å…¥
    Metrics.inc(metricsRegistry1, testMetric, { test: 'true' });
    
    // å¯¼å‡ºç«¯ç‚¹è¯»å–
    const metricsText = await metricsRegistry2.getMetrics();
    expect(metricsText).toContain(testMetric);
  });
});
```

2. **é›†æˆæµ‹è¯•å¢å¼º**ï¼š
```typescript
// test/jest/integration/monitoring/dual-write.integration.test.ts
describe('ç›‘æ§æŒ‡æ ‡åŒå†™é›†æˆæµ‹è¯•', () => {
  it('åº”è¯¥åŒæ—¶å†™å…¥å­˜å‚¨å’Œ Prometheus', async () => {
    const operation = 'test_database_query';
    const duration = 150;

    // æ‰§è¡Œå¸¦ç›‘æ§çš„æ•°æ®åº“æ“ä½œ
    await performanceMonitor.recordDatabaseQuery(operation, duration, {
      provider: 'test',
      success: true,
    });

    // éªŒè¯å­˜å‚¨å†™å…¥
    const storageData = await performanceMonitor.getStorageMetrics();
    expect(storageData.operations.find(op => op.name === operation)).toBeDefined();

    // éªŒè¯ Prometheus å†™å…¥
    const prometheusData = await metricsRegistry.getMetrics();
    expect(prometheusData).toContain('database_query_duration_ms');
    expect(prometheusData).toContain('database_operations_total');
  });
});
```

3. **E2E å¥åº·æ£€æŸ¥**ï¼š
```typescript
// test/jest/e2e/monitoring/metrics-health.e2e.test.ts
describe('ç›‘æ§æŒ‡æ ‡å¥åº·æ£€æŸ¥ E2E', () => {
  it('GET /monitoring/metrics-health åº”è¯¥éªŒè¯ç³»ç»Ÿä¸€è‡´æ€§', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/monitoring/metrics-health')
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(200);

    expect(response.body.data).toMatchObject({
      singleInstance: true,
      registryConsistency: true,
      instanceInfo: {
        metricsCount: expect.any(Number),
        defaultMetricsEnabled: true,
      },
    });
  });
});
```

## 5. å…¼å®¹æ€§ä¸ä¸æ”¹å¥‘çº¦ç­–ç•¥

- ä¸æ”¹å¯¹å¤–æ¥å£ï¼š`/monitoring/performance`ã€`/monitoring/database` ç­‰è¿”å› DTO ä¸å˜ï¼Œä»…æ›´æ¢æ•°æ®æ¥æºã€‚
- ä¸å¼•å…¥æ–°æŠ€æœ¯æ ˆï¼šç»Ÿä¸€äºæ—¢æœ‰ `prom-client` ä¸ Nest DIã€‚
- ä¿æŒåŠŸèƒ½ç­‰ä»·ï¼šè¿ç§»æœŸé—´åŒå†™ï¼Œä»»ä¸€é€šé“å¼‚å¸¸å‡ä¸å½±å“å¯¹å¤–æŸ¥è¯¢ã€‚

## 6. å¢å¼ºæµ‹è¯•è¦†ç›–ä¸éªŒè¯ç­–ç•¥

### 6.1 å¤šå±‚çº§æµ‹è¯•æ¶æ„

**å•å…ƒæµ‹è¯•å±‚ï¼ˆ95% è¦†ç›–ç›®æ ‡ï¼‰**ï¼š
```typescript
// test/jest/unit/monitoring/feature-flag-integration.service.spec.ts
describe('FeatureFlag é›†æˆæµ‹è¯•', () => {
  let service: FeatureFlagIntegrationService;
  let mockFeatureFlags: jest.Mocked<FeatureFlags>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        FeatureFlagIntegrationService,
        {
          provide: FeatureFlags,
          useValue: {
            isEnabled: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<FeatureFlagIntegrationService>(FeatureFlagIntegrationService);
    mockFeatureFlags = module.get(FeatureFlags);
  });

  describe('åŒå†™æ¨¡å¼æ§åˆ¶', () => {
    it('åº”è¯¥æ ¹æ® feature flag æ§åˆ¶åŒå†™è¡Œä¸º', async () => {
      mockFeatureFlags.isEnabled.mockResolvedValue(true);
      
      const result = await service.shouldEnableDualWrite();
      expect(result).toBe(true);
      expect(mockFeatureFlags.isEnabled).toHaveBeenCalledWith('metrics.dual_write_mode');
    });

    it('åº”è¯¥åœ¨ feature flag ç¦ç”¨æ—¶ä»…ä½¿ç”¨æ—§ç³»ç»Ÿ', async () => {
      mockFeatureFlags.isEnabled.mockResolvedValue(false);
      
      const result = await service.shouldEnableDualWrite();
      expect(result).toBe(false);
    });
  });

  describe('æ¸è¿›å¼è¿ç§»æ§åˆ¶', () => {
    it('åº”è¯¥æ”¯æŒç™¾åˆ†æ¯”æ§åˆ¶çš„ç°åº¦å‘å¸ƒ', async () => {
      mockFeatureFlags.isEnabled
        .mockResolvedValueOnce(true) // dual_write_mode
        .mockResolvedValueOnce(false); // prometheus_primary (50% rollout)

      const result = await service.getDataSourceStrategy();
      expect(result).toEqual({
        dualWrite: true,
        primarySource: 'storage',
        fallbackEnabled: true,
      });
    });
  });
});
```

**é›†æˆæµ‹è¯•å±‚ï¼ˆç«¯åˆ°ç«¯æ•°æ®æµï¼‰**ï¼š
```typescript
// test/jest/integration/monitoring/metrics-migration-flow.integration.test.ts
describe('æŒ‡æ ‡è¿ç§»æµç¨‹é›†æˆæµ‹è¯•', () => {
  let app: TestingModule;
  let metricsRegistry: MetricsRegistryService;
  let performanceMonitor: PerformanceMonitorService;
  let featureFlags: FeatureFlags;

  beforeAll(async () => {
    app = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    metricsRegistry = app.get(MetricsRegistryService);
    performanceMonitor = app.get(PerformanceMonitorService);
    featureFlags = app.get(FeatureFlags);
  });

  describe('Phase 1: åŒå†™éªŒè¯', () => {
    beforeEach(async () => {
      // å¯ç”¨åŒå†™æ¨¡å¼
      jest.spyOn(featureFlags, 'isEnabled').mockImplementation((flag: string) => {
        const flags = {
          'metrics.dual_write_mode': true,
          'metrics.prometheus_write': true,
          'metrics.prometheus_primary': false,
        };
        return Promise.resolve(flags[flag] || false);
      });
    });

    it('åº”è¯¥åŒæ—¶å†™å…¥å­˜å‚¨å’Œ Prometheus', async () => {
      const testOperation = `integration_test_${Date.now()}`;
      const testDuration = 125;

      // æ‰§è¡Œç›‘æ§è®°å½•
      await performanceMonitor.recordDatabaseQuery(testOperation, testDuration, {
        provider: 'test',
        success: true,
      });

      // éªŒè¯å­˜å‚¨å†™å…¥
      const storageMetrics = await performanceMonitor.getStorageMetrics({
        operation: testOperation,
        timeRange: '1h',
      });
      expect(storageMetrics.operations).toContain(
        expect.objectContaining({ operation: testOperation })
      );

      // éªŒè¯ Prometheus å†™å…¥
      const prometheusText = await metricsRegistry.getMetrics();
      expect(prometheusText).toContain('database_query_duration_ms');
      expect(prometheusText).toContain(`operation="${testOperation}"`);
    });

    it('åº”è¯¥ä¿æŒæ•°æ®ä¸€è‡´æ€§', async () => {
      const operations = ['select', 'insert', 'update'];
      const promises = operations.map(op => 
        performanceMonitor.recordDatabaseQuery(op, Math.random() * 100 + 50, {
          provider: 'test',
          success: Math.random() > 0.1,
        })
      );

      await Promise.all(promises);

      // ç­‰å¾…æŒ‡æ ‡å¤„ç†
      await new Promise(resolve => setTimeout(resolve, 500));

      const storageData = await performanceMonitor.getStorageMetrics();
      const prometheusText = await metricsRegistry.getMetrics();
      
      // éªŒè¯æ“ä½œè®¡æ•°ä¸€è‡´æ€§
      operations.forEach(op => {
        const storageCount = storageData.operations.filter(item => item.operation === op).length;
        const prometheusMatch = prometheusText.match(new RegExp(`database_operations_total{.*operation="${op}".*} (\\d+)`));
        const prometheusCount = prometheusMatch ? parseInt(prometheusMatch[1]) : 0;
        
        expect(prometheusCount).toBeGreaterThanOrEqual(storageCount * 0.95); // å…è®¸ 5% çš„å¼‚æ­¥å»¶è¿Ÿå®¹å·®
      });
    });
  });

  describe('Phase 2: ä¸»æ•°æ®æºåˆ‡æ¢', () => {
    beforeEach(async () => {
      jest.spyOn(featureFlags, 'isEnabled').mockImplementation((flag: string) => {
        const flags = {
          'metrics.dual_write_mode': true,
          'metrics.prometheus_write': true,
          'metrics.prometheus_primary': true, // åˆ‡æ¢åˆ° Prometheus ä¸ºä¸»
        };
        return Promise.resolve(flags[flag] || false);
      });
    });

    it('åº”è¯¥ä¼˜å…ˆä» Prometheus è¯»å–æ•°æ®', async () => {
      const controller = app.get(MonitoringController);
      
      const performanceData = await controller.getPerformanceMetrics({
        timeRange: '1h',
      } as PerformanceQueryDto);

      expect(performanceData.dataSource).toBe('prometheus');
      expect(performanceData.lastUpdated).toBeInstanceOf(Date);
    });

    it('Prometheus æ•…éšœæ—¶åº”è¯¥è‡ªåŠ¨é™çº§', async () => {
      // æ¨¡æ‹Ÿ Prometheus è·å–å¤±è´¥
      jest.spyOn(metricsRegistry, 'getMetrics').mockRejectedValueOnce(new Error('Registry unavailable'));

      const controller = app.get(MonitoringController);
      const performanceData = await controller.getPerformanceMetrics({
        timeRange: '1h',
      } as PerformanceQueryDto);

      expect(performanceData.dataSource).toBe('storage'); // åº”è¯¥å›é€€åˆ°å­˜å‚¨
    });
  });

  describe('Phase 3: å®Œå…¨è¿ç§»éªŒè¯', () => {
    beforeEach(async () => {
      jest.spyOn(featureFlags, 'isEnabled').mockImplementation((flag: string) => {
        const flags = {
          'metrics.dual_write_mode': false, // å…³é—­åŒå†™
          'metrics.prometheus_write': true,
          'metrics.prometheus_primary': true,
          'metrics.legacy_storage_disabled': true, // å®Œå…¨ç¦ç”¨æ—§å­˜å‚¨
        };
        return Promise.resolve(flags[flag] || false);
      });
    });

    it('åº”è¯¥ä»…ä½¿ç”¨ Prometheus ç³»ç»Ÿ', async () => {
      const testOperation = `final_test_${Date.now()}`;
      
      await performanceMonitor.recordDatabaseQuery(testOperation, 100, {
        provider: 'test',
        success: true,
      });

      // éªŒè¯åªå†™å…¥ Prometheus
      const prometheusText = await metricsRegistry.getMetrics();
      expect(prometheusText).toContain(`operation="${testOperation}"`);

      // éªŒè¯ä¸å†™å…¥æ—§å­˜å‚¨ï¼ˆå¦‚æœæœ‰æ£€æŸ¥æœºåˆ¶çš„è¯ï¼‰
      // Note: è¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„å­˜å‚¨æ£€æŸ¥æœºåˆ¶è°ƒæ•´
    });
  });
});
```

### 6.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

**è´Ÿè½½æµ‹è¯•è„šæœ¬**ï¼š
```typescript
// test/jest/performance/monitoring-performance.perf.test.ts
describe('ç›‘æ§ç³»ç»Ÿæ€§èƒ½æµ‹è¯•', () => {
  describe('æŒ‡æ ‡å†™å…¥æ€§èƒ½', () => {
    it('å•çº¿ç¨‹ä¸‹æ¯ç§’åº”æ”¯æŒ >1000 æ¬¡æŒ‡æ ‡å†™å…¥', async () => {
      const iterations = 1000;
      const startTime = Date.now();

      const promises = Array.from({ length: iterations }, (_, i) => 
        Metrics.inc(metricsRegistry, 'performance_test_counter', {
          test_id: `${i}`,
          batch: 'single_thread',
        })
      );

      await Promise.all(promises);
      
      const duration = Date.now() - startTime;
      const throughput = (iterations / duration) * 1000; // ops/sec

      expect(throughput).toBeGreaterThan(1000);
      expect(duration).toBeLessThan(1000); // åº”åœ¨ 1 ç§’å†…å®Œæˆ
    });

    it('å¹¶å‘å†™å…¥ä¸åº”å‡ºç°æ•°æ®ä¸¢å¤±', async () => {
      const concurrency = 10;
      const iterationsPerThread = 100;
      const expectedTotal = concurrency * iterationsPerThread;

      const batches = Array.from({ length: concurrency }, (_, batchId) =>
        Array.from({ length: iterationsPerThread }, (_, i) =>
          Metrics.inc(metricsRegistry, 'concurrency_test_counter', {
            batch_id: `${batchId}`,
            item_id: `${i}`,
          })
        )
      );

      await Promise.all(batches.flat());

      // ç­‰å¾…æ‰€æœ‰æŒ‡æ ‡å¤„ç†å®Œæˆ
      await new Promise(resolve => setTimeout(resolve, 1000));

      const metricsText = await metricsRegistry.getMetrics();
      const matches = metricsText.match(/concurrency_test_counter\{.*?\} (\d+)/g);
      
      const actualTotal = matches?.reduce((sum, match) => {
        const value = parseInt(match.split(' ')[1]);
        return sum + value;
      }, 0) || 0;

      expect(actualTotal).toBe(expectedTotal);
    });
  });

  describe('æ•°æ®è¯»å–æ€§èƒ½', () => {
    it('æŒ‡æ ‡å¯¼å‡ºåº”åœ¨ 100ms å†…å®Œæˆ', async () => {
      const startTime = Date.now();
      const metricsText = await metricsRegistry.getMetrics();
      const duration = Date.now() - startTime;

      expect(duration).toBeLessThan(100);
      expect(metricsText.length).toBeGreaterThan(0);
    });

    it('å¤§é‡æŒ‡æ ‡ä¸‹çš„å¯¼å‡ºæ€§èƒ½', async () => {
      // é¢„å…ˆå†™å…¥å¤§é‡æŒ‡æ ‡
      const metricNames = Array.from({ length: 50 }, (_, i) => `bulk_test_metric_${i}`);
      const labelCombinations = Array.from({ length: 20 }, (_, i) => ({
        service: `service_${i % 5}`,
        environment: i < 10 ? 'prod' : 'test',
        region: `region_${i % 3}`,
      }));

      const writePromises = metricNames.flatMap(metricName =>
        labelCombinations.map(labels =>
          Metrics.inc(metricsRegistry, metricName, labels, Math.floor(Math.random() * 100))
        )
      );

      await Promise.all(writePromises);

      // æµ‹è¯•å¯¼å‡ºæ€§èƒ½
      const startTime = Date.now();
      const metricsText = await metricsRegistry.getMetrics();
      const duration = Date.now() - startTime;

      expect(duration).toBeLessThan(500); // åœ¨å¤§é‡æŒ‡æ ‡ä¸‹åº”ä¿æŒåœ¨ 500ms å†…
      expect(metricsText.split('\n').length).toBeGreaterThan(metricNames.length * labelCombinations.length);
    });
  });
});
```

### 6.3 æ•…éšœæ¢å¤æµ‹è¯•

**å®¹é”™æ€§éªŒè¯**ï¼š
```typescript
// test/jest/integration/monitoring/fault-tolerance.integration.test.ts
describe('ç›‘æ§ç³»ç»Ÿå®¹é”™æ€§æµ‹è¯•', () => {
  describe('Redis è¿æ¥æ•…éšœ', () => {
    it('Redis ä¸å¯ç”¨æ—¶åº”è¯¥é™çº§åˆ°å†…å­˜æŒ‡æ ‡', async () => {
      // æ¨¡æ‹Ÿ Redis è¿æ¥å¤±è´¥
      const originalRedis = (metricsRegistry as any).redis;
      (metricsRegistry as any).redis = null;

      try {
        await Metrics.inc(metricsRegistry, 'fault_tolerance_test', { scenario: 'redis_down' });
        
        // åº”è¯¥ä»èƒ½å¯¼å‡ºæŒ‡æ ‡ï¼ˆä½¿ç”¨å†…å­˜åå¤‡ï¼‰
        const metricsText = await metricsRegistry.getMetrics();
        expect(metricsText).toContain('fault_tolerance_test');
      } finally {
        // æ¢å¤ Redis è¿æ¥
        (metricsRegistry as any).redis = originalRedis;
      }
    });
  });

  describe('MongoDB è¿æ¥æ•…éšœ', () => {
    it('å­˜å‚¨å±‚æ•…éšœæ—¶ Prometheus åº”ç»§ç»­å·¥ä½œ', async () => {
      // å¯ç”¨åŒå†™æ¨¡å¼
      jest.spyOn(featureFlags, 'isEnabled').mockImplementation((flag: string) => {
        return Promise.resolve(flag === 'metrics.dual_write_mode' || flag === 'metrics.prometheus_write');
      });

      // æ¨¡æ‹Ÿ MongoDB è¿æ¥å¤±è´¥
      jest.spyOn(performanceMonitor, 'recordToStorage').mockRejectedValue(new Error('MongoDB connection failed'));

      await expect(
        performanceMonitor.recordDatabaseQuery('fault_test', 100, { provider: 'test' })
      ).resolves.not.toThrow();

      // Prometheus æŒ‡æ ‡åº”è¯¥ä»ç„¶å¯ç”¨
      const metricsText = await metricsRegistry.getMetrics();
      expect(metricsText).toContain('database_operations_total');
    });
  });

  describe('éƒ¨åˆ†æœåŠ¡æ•…éšœ', () => {
    it('è£…é¥°å™¨å¼‚å¸¸ä¸åº”å½±å“ä¸šåŠ¡é€»è¾‘', async () => {
      class TestService {
        constructor(public metricsRegistry: MetricsRegistryService) {}

        @PrometheusPerformance('test_method')
        async businessMethod(shouldFail: boolean): Promise<string> {
          if (shouldFail) {
            throw new Error('Business logic error');
          }
          return 'success';
        }
      }

      const testService = new TestService(metricsRegistry);

      // æ­£å¸¸æƒ…å†µ
      const result = await testService.businessMethod(false);
      expect(result).toBe('success');

      // ä¸šåŠ¡é€»è¾‘å¼‚å¸¸æ—¶è£…é¥°å™¨åº”è¯¥ä¸å½±å“å¼‚å¸¸ä¼ æ’­
      await expect(testService.businessMethod(true)).rejects.toThrow('Business logic error');

      // éªŒè¯é”™è¯¯æŒ‡æ ‡è¢«è®°å½•
      const metricsText = await metricsRegistry.getMetrics();
      expect(metricsText).toContain('test_method_total{');
    });
  });
});
```

### 6.4 æ•°æ®ä¸€è‡´æ€§éªŒè¯

**ä¸€è‡´æ€§æ£€æŸ¥å·¥å…·**ï¼š
```typescript
// src/monitoring/utils/consistency-validator.util.ts
export class ConsistencyValidatorUtil {
  constructor(
    private readonly metricsRegistry: MetricsRegistryService,
    private readonly performanceMonitor: PerformanceMonitorService,
  ) {}

  async validateConsistency(timeRange: string = '1h'): Promise<ConsistencyReport> {
    const [prometheusData, storageData] = await Promise.all([
      this.getPrometheusAggregates(),
      this.getStorageAggregates(timeRange),
    ]);

    const report: ConsistencyReport = {
      timestamp: new Date(),
      timeRange,
      metrics: [],
      overallConsistency: 0,
      recommendations: [],
    };

    // å¯¹æ¯”å…³é”®æŒ‡æ ‡
    const keyMetrics = ['database_operations_total', 'http_requests_total', 'cache_operations_total'];
    
    for (const metricName of keyMetrics) {
      const prometheusValue = this.extractMetricValue(prometheusData, metricName);
      const storageValue = this.extractStorageValue(storageData, metricName);
      
      const consistency = this.calculateConsistency(prometheusValue, storageValue);
      
      report.metrics.push({
        name: metricName,
        prometheusValue,
        storageValue,
        consistency,
        acceptable: consistency >= 0.95, // 95% ä¸€è‡´æ€§é˜ˆå€¼
      });
    }

    report.overallConsistency = report.metrics.reduce((sum, m) => sum + m.consistency, 0) / report.metrics.length;

    // ç”Ÿæˆå»ºè®®
    if (report.overallConsistency < 0.95) {
      report.recommendations.push('æ•°æ®ä¸€è‡´æ€§ä½äºé˜ˆå€¼ï¼Œå»ºè®®æ£€æŸ¥åŒå†™é…ç½®');
    }
    if (report.overallConsistency < 0.85) {
      report.recommendations.push('ä¸¥é‡ä¸ä¸€è‡´ï¼Œå»ºè®®æš‚åœè¿ç§»å¹¶æ’æŸ¥é—®é¢˜');
    }

    return report;
  }

  private calculateConsistency(prometheusValue: number, storageValue: number): number {
    if (prometheusValue === 0 && storageValue === 0) return 1;
    if (prometheusValue === 0 || storageValue === 0) return 0;
    
    const diff = Math.abs(prometheusValue - storageValue);
    const avg = (prometheusValue + storageValue) / 2;
    
    return Math.max(0, 1 - (diff / avg));
  }
}

interface ConsistencyReport {
  timestamp: Date;
  timeRange: string;
  metrics: MetricConsistency[];
  overallConsistency: number;
  recommendations: string[];
}

interface MetricConsistency {
  name: string;
  prometheusValue: number;
  storageValue: number;
  consistency: number;
  acceptable: boolean;
}
```

## 7. å¢å¼ºç›‘æ§æŒ‡æ ‡ä¸æ€§èƒ½è¯„ä¼°

### 7.1 å…³é”®æ€§èƒ½æŒ‡æ ‡ (KPIs)

**ç³»ç»Ÿæ€§èƒ½ç›‘æ§**ï¼š
```typescript
// src/monitoring/services/migration-metrics.service.ts
@Injectable()
export class MigrationMetricsService {
  private readonly logger = createLogger(MigrationMetricsService.name);

  constructor(
    private readonly metricsRegistry: MetricsRegistryService,
    private readonly consistencyValidator: ConsistencyValidatorUtil,
  ) {}

  async collectMigrationMetrics(): Promise<MigrationMetricsDto> {
    const startTime = Date.now();

    // 1. æ€§èƒ½æŒ‡æ ‡æ”¶é›†
    const performanceMetrics = await this.collectPerformanceMetrics();
    
    // 2. ä¸€è‡´æ€§æ£€æŸ¥
    const consistencyReport = await this.consistencyValidator.validateConsistency('1h');
    
    // 3. èµ„æºä½¿ç”¨æƒ…å†µ
    const resourceUsage = await this.collectResourceMetrics();
    
    // 4. é”™è¯¯ç‡ç»Ÿè®¡
    const errorMetrics = await this.collectErrorMetrics();

    const collectionTime = Date.now() - startTime;

    return {
      timestamp: new Date(),
      collectionTimeMs: collectionTime,
      performance: performanceMetrics,
      consistency: consistencyReport,
      resources: resourceUsage,
      errors: errorMetrics,
      overallHealth: this.calculateOverallHealth(performanceMetrics, consistencyReport, errorMetrics),
    };
  }

  private async collectPerformanceMetrics(): Promise<PerformanceMetricsSnapshot> {
    const metricsText = await this.metricsRegistry.getMetrics();
    const metrics = PrometheusParserUtil.parseMetrics(metricsText);

    return {
      // å†™å…¥æ€§èƒ½
      metricsWriteRate: this.calculateRate(metrics, 'metrics_write_operations_total'),
      avgWriteLatency: this.extractHistogramAvg(metrics, 'metrics_write_duration_ms'),
      
      // è¯»å–æ€§èƒ½
      metricsReadRate: this.calculateRate(metrics, 'metrics_read_operations_total'),
      avgReadLatency: this.extractHistogramAvg(metrics, 'metrics_read_duration_ms'),
      
      // ç¼“å­˜æ€§èƒ½
      cacheHitRate: this.calculateHitRate(metrics, 'metrics_cache_hits_total', 'metrics_cache_requests_total'),
      
      // å¯¼å‡ºæ€§èƒ½
      exportLatency: this.extractHistogramAvg(metrics, 'metrics_export_duration_ms'),
      exportSize: this.extractGauge(metrics, 'metrics_export_size_bytes'),
      
      // æ‰¹é‡å¤„ç†æ€§èƒ½
      batchProcessingRate: this.calculateRate(metrics, 'metrics_batch_processed_total'),
      avgBatchSize: this.extractHistogramAvg(metrics, 'metrics_batch_size'),
    };
  }

  private async collectResourceMetrics(): Promise<ResourceUsageSnapshot> {
    const metricsText = await this.metricsRegistry.getMetrics();
    const metrics = PrometheusParserUtil.parseMetrics(metricsText);

    return {
      // å†…å­˜ä½¿ç”¨
      heapUsedMB: this.extractGauge(metrics, 'nodejs_heap_size_used_bytes') / 1024 / 1024,
      heapTotalMB: this.extractGauge(metrics, 'nodejs_heap_size_total_bytes') / 1024 / 1024,
      heapUtilization: this.extractGauge(metrics, 'nodejs_heap_size_used_bytes') / 
                       this.extractGauge(metrics, 'nodejs_heap_size_total_bytes'),
      
      // CPU ä½¿ç”¨ç‡
      cpuUsagePercent: this.extractGauge(metrics, 'process_cpu_user_seconds_total') * 100,
      
      // ç½‘ç»œè¿æ¥
      activeConnections: this.extractGauge(metrics, 'nodejs_active_handles_total'),
      
      // æ•°æ®åº“è¿æ¥
      dbConnectionsActive: this.extractGauge(metrics, 'mongodb_connections_active'),
      dbConnectionsAvailable: this.extractGauge(metrics, 'mongodb_connections_available'),
      
      // Redis è¿æ¥
      redisConnectionsActive: this.extractGauge(metrics, 'redis_connections_active'),
      
      // æŒ‡æ ‡å­˜å‚¨å ç”¨
      prometheusMetricsCount: this.extractGauge(metrics, 'prometheus_metrics_total'),
      metricsMemoryUsageMB: this.extractGauge(metrics, 'metrics_memory_usage_bytes') / 1024 / 1024,
    };
  }

  private async collectErrorMetrics(): Promise<ErrorMetricsSnapshot> {
    const metricsText = await this.metricsRegistry.getMetrics();
    const metrics = PrometheusParserUtil.parseMetrics(metricsText);

    return {
      // å†™å…¥é”™è¯¯
      metricsWriteErrors: this.extractCounter(metrics, 'metrics_write_errors_total'),
      metricsWriteErrorRate: this.calculateErrorRate(metrics, 'metrics_write_errors_total', 'metrics_write_operations_total'),
      
      // è¯»å–é”™è¯¯
      metricsReadErrors: this.extractCounter(metrics, 'metrics_read_errors_total'),
      metricsReadErrorRate: this.calculateErrorRate(metrics, 'metrics_read_errors_total', 'metrics_read_operations_total'),
      
      // å¯¼å‡ºé”™è¯¯
      exportErrors: this.extractCounter(metrics, 'metrics_export_errors_total'),
      exportErrorRate: this.calculateErrorRate(metrics, 'metrics_export_errors_total', 'metrics_export_operations_total'),
      
      // ä¸€è‡´æ€§é”™è¯¯
      consistencyFailures: this.extractCounter(metrics, 'metrics_consistency_failures_total'),
      
      // è¶…æ—¶é”™è¯¯
      timeoutErrors: this.extractCounter(metrics, 'metrics_timeout_errors_total'),
      
      // è¿æ¥é”™è¯¯
      connectionErrors: this.extractCounter(metrics, 'metrics_connection_errors_total'),
    };
  }

  private calculateOverallHealth(
    performance: PerformanceMetricsSnapshot,
    consistency: ConsistencyReport,
    errors: ErrorMetricsSnapshot,
  ): HealthScore {
    let score = 100;
    const issues: string[] = [];

    // æ€§èƒ½è¯„åˆ† (40%)
    if (performance.avgWriteLatency > 100) {
      score -= 15;
      issues.push('å†™å…¥å»¶è¿Ÿè¿‡é«˜');
    }
    if (performance.cacheHitRate < 0.8) {
      score -= 10;
      issues.push('ç¼“å­˜å‘½ä¸­ç‡ä½');
    }
    if (performance.exportLatency > 500) {
      score -= 15;
      issues.push('å¯¼å‡ºæ€§èƒ½å·®');
    }

    // ä¸€è‡´æ€§è¯„åˆ† (35%)
    if (consistency.overallConsistency < 0.95) {
      score -= 20;
      issues.push('æ•°æ®ä¸€è‡´æ€§é—®é¢˜');
    }
    if (consistency.overallConsistency < 0.85) {
      score -= 15;
      issues.push('ä¸¥é‡ä¸€è‡´æ€§é—®é¢˜');
    }

    // é”™è¯¯ç‡è¯„åˆ† (25%)
    if (errors.metricsWriteErrorRate > 0.01) {
      score -= 15;
      issues.push('å†™å…¥é”™è¯¯ç‡é«˜');
    }
    if (errors.exportErrorRate > 0.005) {
      score -= 10;
      issues.push('å¯¼å‡ºé”™è¯¯ç‡é«˜');
    }

    return {
      score: Math.max(0, score),
      level: this.getHealthLevel(score),
      issues,
      recommendations: this.generateRecommendations(score, issues),
    };
  }

  private getHealthLevel(score: number): 'excellent' | 'good' | 'fair' | 'poor' | 'critical' {
    if (score >= 95) return 'excellent';
    if (score >= 85) return 'good';
    if (score >= 70) return 'fair';
    if (score >= 50) return 'poor';
    return 'critical';
  }

  private generateRecommendations(score: number, issues: string[]): string[] {
    const recommendations: string[] = [];

    if (issues.includes('å†™å…¥å»¶è¿Ÿè¿‡é«˜')) {
      recommendations.push('è€ƒè™‘å¯ç”¨æ‰¹é‡å†™å…¥æ¨¡å¼');
      recommendations.push('æ£€æŸ¥æ•°æ®åº“è¿æ¥æ± é…ç½®');
    }
    if (issues.includes('ç¼“å­˜å‘½ä¸­ç‡ä½')) {
      recommendations.push('è°ƒæ•´ç¼“å­˜TTLç­–ç•¥');
      recommendations.push('å¢åŠ ç¼“å­˜é¢„çƒ­æœºåˆ¶');
    }
    if (issues.includes('æ•°æ®ä¸€è‡´æ€§é—®é¢˜')) {
      recommendations.push('æ£€æŸ¥åŒå†™é…ç½®');
      recommendations.push('å¢åŠ åŒæ­¥æ£€æŸ¥ç‚¹');
    }
    if (score < 70) {
      recommendations.push('å»ºè®®æš‚åœè¿ç§»å¹¶æ’æŸ¥é—®é¢˜');
    }

    return recommendations;
  }
}

// DTOs
interface MigrationMetricsDto {
  timestamp: Date;
  collectionTimeMs: number;
  performance: PerformanceMetricsSnapshot;
  consistency: ConsistencyReport;
  resources: ResourceUsageSnapshot;
  errors: ErrorMetricsSnapshot;
  overallHealth: HealthScore;
}

interface PerformanceMetricsSnapshot {
  metricsWriteRate: number;
  avgWriteLatency: number;
  metricsReadRate: number;
  avgReadLatency: number;
  cacheHitRate: number;
  exportLatency: number;
  exportSize: number;
  batchProcessingRate: number;
  avgBatchSize: number;
}

interface ResourceUsageSnapshot {
  heapUsedMB: number;
  heapTotalMB: number;
  heapUtilization: number;
  cpuUsagePercent: number;
  activeConnections: number;
  dbConnectionsActive: number;
  dbConnectionsAvailable: number;
  redisConnectionsActive: number;
  prometheusMetricsCount: number;
  metricsMemoryUsageMB: number;
}

interface ErrorMetricsSnapshot {
  metricsWriteErrors: number;
  metricsWriteErrorRate: number;
  metricsReadErrors: number;
  metricsReadErrorRate: number;
  exportErrors: number;
  exportErrorRate: number;
  consistencyFailures: number;
  timeoutErrors: number;
  connectionErrors: number;
}

interface HealthScore {
  score: number;
  level: 'excellent' | 'good' | 'fair' | 'poor' | 'critical';
  issues: string[];
  recommendations: string[];
}
```

### 7.2 å®æ—¶ç›‘æ§ä»ªè¡¨æ¿

**ç›‘æ§ç«¯ç‚¹å¢å¼º**ï¼š
```typescript
// src/monitoring/controller/migration-monitoring.controller.ts
@Controller('monitoring/migration')
export class MigrationMonitoringController {
  constructor(
    private readonly migrationMetrics: MigrationMetricsService,
    private readonly consistencyValidator: ConsistencyValidatorUtil,
  ) {}

  @Get('dashboard')
  @Auth([UserRole.ADMIN])
  async getDashboardData(): Promise<MigrationDashboardDto> {
    const [currentMetrics, trends] = await Promise.all([
      this.migrationMetrics.collectMigrationMetrics(),
      this.getTrendData(),
    ]);

    return {
      current: currentMetrics,
      trends,
      alerts: this.generateAlerts(currentMetrics),
      lastUpdated: new Date(),
    };
  }

  @Get('health')
  @Auth([UserRole.ADMIN])
  async getHealthSummary(): Promise<HealthSummaryDto> {
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    
    return {
      overall: metrics.overallHealth,
      components: {
        performance: this.assessPerformanceHealth(metrics.performance),
        consistency: this.assessConsistencyHealth(metrics.consistency),
        resources: this.assessResourceHealth(metrics.resources),
        errors: this.assessErrorHealth(metrics.errors),
      },
      timestamp: metrics.timestamp,
    };
  }

  @Get('alerts')
  @Auth([UserRole.ADMIN])
  async getActiveAlerts(): Promise<AlertDto[]> {
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    return this.generateAlerts(metrics);
  }

  @Post('consistency-check')
  @Auth([UserRole.ADMIN])
  async performConsistencyCheck(@Body() request: ConsistencyCheckRequestDto): Promise<ConsistencyReport> {
    return this.consistencyValidator.validateConsistency(request.timeRange || '1h');
  }

  private async getTrendData(): Promise<TrendDataDto> {
    // è·å–å†å²è¶‹åŠ¿æ•°æ®ï¼ˆç®€åŒ–å®ç°ï¼‰
    return {
      performanceTrend: [], // å®é™…å®ç°ä¸­ä»æ—¶åºæ•°æ®åº“è·å–
      consistencyTrend: [],
      errorTrend: [],
      resourceTrend: [],
    };
  }

  private generateAlerts(metrics: MigrationMetricsDto): AlertDto[] {
    const alerts: AlertDto[] = [];

    // æ€§èƒ½å‘Šè­¦
    if (metrics.performance.avgWriteLatency > 200) {
      alerts.push({
        level: 'warning',
        type: 'performance',
        message: `æŒ‡æ ‡å†™å…¥å»¶è¿Ÿè¿‡é«˜: ${metrics.performance.avgWriteLatency}ms`,
        recommendations: ['æ£€æŸ¥æ•°æ®åº“è¿æ¥', 'è€ƒè™‘å¯ç”¨æ‰¹é‡å†™å…¥'],
      });
    }

    // ä¸€è‡´æ€§å‘Šè­¦
    if (metrics.consistency.overallConsistency < 0.9) {
      alerts.push({
        level: 'critical',
        type: 'consistency',
        message: `æ•°æ®ä¸€è‡´æ€§ä½äºé˜ˆå€¼: ${(metrics.consistency.overallConsistency * 100).toFixed(1)}%`,
        recommendations: metrics.consistency.recommendations,
      });
    }

    // èµ„æºå‘Šè­¦
    if (metrics.resources.heapUtilization > 0.85) {
      alerts.push({
        level: 'warning',
        type: 'resource',
        message: `å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: ${(metrics.resources.heapUtilization * 100).toFixed(1)}%`,
        recommendations: ['å¢åŠ å†…å­˜åˆ†é…', 'æ£€æŸ¥å†…å­˜æ³„æ¼'],
      });
    }

    // é”™è¯¯ç‡å‘Šè­¦
    if (metrics.errors.metricsWriteErrorRate > 0.01) {
      alerts.push({
        level: 'error',
        type: 'error',
        message: `æŒ‡æ ‡å†™å…¥é”™è¯¯ç‡è¿‡é«˜: ${(metrics.errors.metricsWriteErrorRate * 100).toFixed(2)}%`,
        recommendations: ['æ£€æŸ¥è¿æ¥ç¨³å®šæ€§', 'åˆ†æé”™è¯¯æ—¥å¿—'],
      });
    }

    return alerts;
  }
}
```

### 7.3 è‡ªåŠ¨åŒ–é¢„è­¦ç³»ç»Ÿ

**æ™ºèƒ½é¢„è­¦æœºåˆ¶**ï¼š
```typescript
// src/monitoring/services/alert-manager.service.ts
@Injectable()
export class AlertManagerService implements OnModuleInit {
  private readonly logger = createLogger(AlertManagerService.name);
  private alertHistory: Map<string, AlertHistoryItem> = new Map();
  private monitoringInterval: NodeJS.Timer | null = null;

  constructor(
    private readonly migrationMetrics: MigrationMetricsService,
    private readonly notificationService: NotificationService, // å‡è®¾å­˜åœ¨é€šçŸ¥æœåŠ¡
  ) {}

  async onModuleInit() {
    // å¯åŠ¨æŒç»­ç›‘æ§
    this.startContinuousMonitoring();
  }

  private startContinuousMonitoring() {
    this.monitoringInterval = setInterval(async () => {
      try {
        await this.performHealthCheck();
      } catch (error) {
        this.logger.error('å¥åº·æ£€æŸ¥å¤±è´¥', { error: error.message });
      }
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  }

  private async performHealthCheck() {
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    const alerts = this.evaluateAlerts(metrics);

    for (const alert of alerts) {
      await this.processAlert(alert);
    }

    // æ¸…ç†å·²è§£å†³çš„å‘Šè­¦
    this.cleanupResolvedAlerts(alerts);
  }

  private evaluateAlerts(metrics: MigrationMetricsDto): Alert[] {
    const alerts: Alert[] = [];

    // å®šä¹‰å‘Šè­¦è§„åˆ™
    const rules: AlertRule[] = [
      {
        name: 'high_write_latency',
        condition: () => metrics.performance.avgWriteLatency > 150,
        severity: 'warning',
        message: `å†™å…¥å»¶è¿Ÿè¿‡é«˜: ${metrics.performance.avgWriteLatency}ms`,
        threshold: 150,
        cooldown: 300000, // 5åˆ†é’Ÿå†·å´æœŸ
      },
      {
        name: 'low_consistency',
        condition: () => metrics.consistency.overallConsistency < 0.95,
        severity: 'critical',
        message: `æ•°æ®ä¸€è‡´æ€§ä½: ${(metrics.consistency.overallConsistency * 100).toFixed(1)}%`,
        threshold: 0.95,
        cooldown: 600000, // 10åˆ†é’Ÿå†·å´æœŸ
      },
      {
        name: 'high_error_rate',
        condition: () => metrics.errors.metricsWriteErrorRate > 0.005,
        severity: 'error',
        message: `é”™è¯¯ç‡è¿‡é«˜: ${(metrics.errors.metricsWriteErrorRate * 100).toFixed(2)}%`,
        threshold: 0.005,
        cooldown: 180000, // 3åˆ†é’Ÿå†·å´æœŸ
      },
      {
        name: 'memory_pressure',
        condition: () => metrics.resources.heapUtilization > 0.9,
        severity: 'warning',
        message: `å†…å­˜å‹åŠ›è¿‡é«˜: ${(metrics.resources.heapUtilization * 100).toFixed(1)}%`,
        threshold: 0.9,
        cooldown: 300000,
      }
    ];

    for (const rule of rules) {
      if (rule.condition()) {
        const alertKey = rule.name;
        const lastAlert = this.alertHistory.get(alertKey);
        
        // æ£€æŸ¥å†·å´æœŸ
        if (!lastAlert || (Date.now() - lastAlert.lastFired) > rule.cooldown) {
          alerts.push({
            id: `${rule.name}_${Date.now()}`,
            name: rule.name,
            severity: rule.severity,
            message: rule.message,
            timestamp: new Date(),
            source: 'migration_monitor',
            metadata: {
              currentValue: this.extractCurrentValue(metrics, rule),
              threshold: rule.threshold,
            },
          });
        }
      }
    }

    return alerts;
  }

  private async processAlert(alert: Alert) {
    // è®°å½•å‘Šè­¦å†å²
    this.alertHistory.set(alert.name, {
      lastFired: Date.now(),
      count: (this.alertHistory.get(alert.name)?.count || 0) + 1,
    });

    // æ—¥å¿—è®°å½•
    this.logger.warn(`å‘Šè­¦è§¦å‘: ${alert.name}`, {
      severity: alert.severity,
      message: alert.message,
      metadata: alert.metadata,
    });

    // å‘é€é€šçŸ¥ï¼ˆæ ¹æ®ä¸¥é‡ç¨‹åº¦ï¼‰
    if (alert.severity === 'critical') {
      await this.notificationService.sendCriticalAlert(alert);
    } else if (alert.severity === 'error') {
      await this.notificationService.sendErrorAlert(alert);
    }

    // è‡ªåŠ¨æ¢å¤æ“ä½œ
    await this.attemptAutoRemediation(alert);
  }

  private async attemptAutoRemediation(alert: Alert) {
    switch (alert.name) {
      case 'high_write_latency':
        // è‡ªåŠ¨å¯ç”¨æ‰¹é‡å†™å…¥æ¨¡å¼
        await this.enableBatchWriteMode();
        break;
        
      case 'low_consistency':
        // è§¦å‘ä¸€è‡´æ€§ä¿®å¤
        await this.triggerConsistencyRepair();
        break;
        
      case 'memory_pressure':
        // è§¦å‘åƒåœ¾å›æ”¶
        if (global.gc) {
          global.gc();
        }
        break;
    }
  }

  private async enableBatchWriteMode() {
    // å®ç°æ‰¹é‡å†™å…¥æ¨¡å¼åˆ‡æ¢é€»è¾‘
    this.logger.info('è‡ªåŠ¨å¯ç”¨æ‰¹é‡å†™å…¥æ¨¡å¼ä»¥æ”¹å–„æ€§èƒ½');
  }

  private async triggerConsistencyRepair() {
    // å®ç°ä¸€è‡´æ€§ä¿®å¤é€»è¾‘
    this.logger.info('è§¦å‘æ•°æ®ä¸€è‡´æ€§ä¿®å¤æµç¨‹');
  }

  onModuleDestroy() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
    }
  }
}

interface AlertRule {
  name: string;
  condition: () => boolean;
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  threshold: number;
  cooldown: number;
}

interface Alert {
  id: string;
  name: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  timestamp: Date;
  source: string;
  metadata: any;
}

interface AlertHistoryItem {
  lastFired: number;
  count: number;
}
```

## 8. å¢å¼ºé£é™©ç®¡æ§ä¸å›æ»šç­–ç•¥

### 8.1 å¤šå±‚çº§é£é™©è¯„ä¼°çŸ©é˜µ

**é£é™©åˆ†ç±»ä¸å½±å“è¯„ä¼°**ï¼š

| é£é™©ç­‰çº§ | é£é™©ç±»å‹ | å…·ä½“é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£ç­–ç•¥ | å›æ»šæ—¶é—´ |
|---------|---------|---------|------|------|---------|---------|
| **Critical** | æ•°æ®ä¸€è‡´æ€§ | åŒå†™æœŸé—´æ•°æ®ä¸¢å¤±æˆ–ä¸ä¸€è‡´ | ä¸­ | é«˜ | å®æ—¶ä¸€è‡´æ€§ç›‘æ§ + è‡ªåŠ¨ä¿®å¤ | < 5åˆ†é’Ÿ |
| **High** | æ€§èƒ½ä¸‹é™ | ç›‘æ§ç³»ç»Ÿæ‹–ç´¯ä¸šåŠ¡æ€§èƒ½ | ä¸­ | ä¸­ | æ€§èƒ½é˜ˆå€¼å‘Šè­¦ + è‡ªåŠ¨é™çº§ | < 2åˆ†é’Ÿ |
| **High** | ç³»ç»Ÿç¨³å®šæ€§ | æ–°ç›‘æ§ç»„ä»¶å¯¼è‡´ç³»ç»Ÿå´©æºƒ | ä½ | é«˜ | å¥åº·æ£€æŸ¥ + ç†”æ–­æœºåˆ¶ | < 1åˆ†é’Ÿ |
| **Medium** | æ•°æ®è´¨é‡ | å†å²æŠ¥è¡¨æ•°æ®ä¸­æ–­ | ä¸­ | ä¸­ | æ•°æ®å¤‡ä»½ + æ¸è¿›å¼è¿ç§» | < 10åˆ†é’Ÿ |
| **Medium** | è¿ç»´å¤æ‚æ€§ | åŒç³»ç»Ÿå¢åŠ è¿ç»´è´Ÿæ‹… | é«˜ | ä½ | è‡ªåŠ¨åŒ–å·¥å…· + æ–‡æ¡£å®Œå–„ | N/A |
| **Low** | èµ„æºæ¶ˆè€— | å†…å­˜/CPUå ç”¨å¢åŠ  | é«˜ | ä½ | èµ„æºç›‘æ§ + ä¼˜åŒ–é…ç½® | < 30åˆ†é’Ÿ |

### 8.2 æ™ºèƒ½å›æ»šå†³ç­–ç³»ç»Ÿ

**è‡ªåŠ¨å›æ»šè§¦å‘æ¡ä»¶**ï¼š
```typescript
// src/monitoring/services/rollback-manager.service.ts
@Injectable()
export class RollbackManagerService {
  private readonly logger = createLogger(RollbackManagerService.name);
  private rollbackHistory: Map<string, RollbackRecord> = new Map();

  constructor(
    private readonly migrationMetrics: MigrationMetricsService,
    private readonly featureFlags: FeatureFlags,
    private readonly alertManager: AlertManagerService,
  ) {}

  async evaluateRollbackConditions(): Promise<RollbackDecision> {
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    const decision: RollbackDecision = {
      shouldRollback: false,
      severity: 'info',
      reasons: [],
      actions: [],
      estimatedRecoveryTime: 0,
    };

    // Critical: æ•°æ®ä¸€è‡´æ€§ä½äº85%
    if (metrics.consistency.overallConsistency < 0.85) {
      decision.shouldRollback = true;
      decision.severity = 'critical';
      decision.reasons.push(`æ•°æ®ä¸€è‡´æ€§ä¸¥é‡é—®é¢˜: ${(metrics.consistency.overallConsistency * 100).toFixed(1)}%`);
      decision.actions.push('ç«‹å³åœæ­¢åŒå†™æ¨¡å¼');
      decision.actions.push('æ¢å¤åˆ°æ—§ç›‘æ§ç³»ç»Ÿ');
      decision.estimatedRecoveryTime = 300; // 5åˆ†é’Ÿ
    }

    // High: é”™è¯¯ç‡æŒç»­è¶…è¿‡1%
    if (metrics.errors.metricsWriteErrorRate > 0.01) {
      const errorHistory = await this.getErrorRateHistory();
      if (this.isErrorRateSustained(errorHistory, 0.01, 300000)) { // æŒç»­5åˆ†é’Ÿ
        decision.shouldRollback = true;
        decision.severity = 'high';
        decision.reasons.push(`æŒç»­é«˜é”™è¯¯ç‡: ${(metrics.errors.metricsWriteErrorRate * 100).toFixed(2)}%`);
        decision.actions.push('ç¦ç”¨Prometheuså†™å…¥');
        decision.estimatedRecoveryTime = 120; // 2åˆ†é’Ÿ
      }
    }

    // High: æ€§èƒ½é€€åŒ–è¶…è¿‡50%
    const performanceBaseline = await this.getPerformanceBaseline();
    if (metrics.performance.avgWriteLatency > performanceBaseline.writeLatency * 1.5) {
      decision.shouldRollback = true;
      decision.severity = 'high';
      decision.reasons.push(`æ€§èƒ½ä¸¥é‡é€€åŒ–: ${metrics.performance.avgWriteLatency}ms vs åŸºçº¿${performanceBaseline.writeLatency}ms`);
      decision.actions.push('åˆ‡æ¢åˆ°å•ä¸€ç›‘æ§æ¨¡å¼');
      decision.estimatedRecoveryTime = 180; // 3åˆ†é’Ÿ
    }

    // Medium: ç³»ç»Ÿèµ„æºå‹åŠ›è¿‡å¤§
    if (metrics.resources.heapUtilization > 0.95 && metrics.resources.cpuUsagePercent > 90) {
      decision.shouldRollback = true;
      decision.severity = 'medium';
      decision.reasons.push('ç³»ç»Ÿèµ„æºå‹åŠ›è¿‡å¤§');
      decision.actions.push('å‡å°‘ç›‘æ§é¢‘ç‡');
      decision.actions.push('å¯ç”¨æ‰¹é‡å¤„ç†æ¨¡å¼');
      decision.estimatedRecoveryTime = 60; // 1åˆ†é’Ÿ
    }

    return decision;
  }

  async executeRollback(decision: RollbackDecision): Promise<RollbackResult> {
    const rollbackId = `rollback_${Date.now()}`;
    const startTime = Date.now();

    this.logger.error('æ‰§è¡Œè‡ªåŠ¨å›æ»š', {
      rollbackId,
      severity: decision.severity,
      reasons: decision.reasons,
    });

    const result: RollbackResult = {
      rollbackId,
      startTime: new Date(),
      actions: [],
      success: true,
      errors: [],
      completionTime: null,
      recoveryValidation: null,
    };

    try {
      // 1. ç«‹å³åœæ­¢æ–°åŠŸèƒ½
      if (decision.actions.includes('ç«‹å³åœæ­¢åŒå†™æ¨¡å¼')) {
        await this.stopDualWriteMode();
        result.actions.push({ action: 'stop_dual_write', success: true, duration: Date.now() - startTime });
      }

      // 2. æ¢å¤åˆ°å®‰å…¨é…ç½®
      if (decision.actions.includes('æ¢å¤åˆ°æ—§ç›‘æ§ç³»ç»Ÿ')) {
        await this.revertToLegacySystem();
        result.actions.push({ action: 'revert_to_legacy', success: true, duration: Date.now() - startTime });
      }

      // 3. ç¦ç”¨æœ‰é—®é¢˜çš„åŠŸèƒ½
      if (decision.actions.includes('ç¦ç”¨Prometheuså†™å…¥')) {
        await this.disablePrometheusWrite();
        result.actions.push({ action: 'disable_prometheus_write', success: true, duration: Date.now() - startTime });
      }

      // 4. éªŒè¯æ¢å¤çŠ¶æ€
      result.recoveryValidation = await this.validateRecovery();
      result.completionTime = new Date();

      // 5. è®°å½•å›æ»šå†å²
      this.recordRollbackHistory(rollbackId, decision, result);

    } catch (error) {
      result.success = false;
      result.errors.push(error.message);
      this.logger.error('å›æ»šè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯', { rollbackId, error: error.message });
    }

    return result;
  }

  private async stopDualWriteMode(): Promise<void> {
    await this.featureFlags.setFlag('metrics.dual_write_mode', false);
    this.logger.info('åŒå†™æ¨¡å¼å·²åœæ­¢');
  }

  private async revertToLegacySystem(): Promise<void> {
    await this.featureFlags.setFlag('metrics.prometheus_primary', false);
    await this.featureFlags.setFlag('metrics.legacy_storage_disabled', false);
    this.logger.info('å·²æ¢å¤åˆ°æ—§ç›‘æ§ç³»ç»Ÿ');
  }

  private async disablePrometheusWrite(): Promise<void> {
    await this.featureFlags.setFlag('metrics.prometheus_write', false);
    this.logger.info('Prometheuså†™å…¥å·²ç¦ç”¨');
  }

  private async validateRecovery(): Promise<RecoveryValidationResult> {
    // ç­‰å¾…ç³»ç»Ÿç¨³å®š
    await new Promise(resolve => setTimeout(resolve, 30000));

    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    
    return {
      systemStable: metrics.errors.metricsWriteErrorRate < 0.001,
      performanceRecovered: metrics.performance.avgWriteLatency < 100,
      consistencyRestored: metrics.consistency.overallConsistency > 0.98,
      resourcePressureRelieved: metrics.resources.heapUtilization < 0.8,
      validationTime: new Date(),
    };
  }
}

// æ¥å£å®šä¹‰
interface RollbackDecision {
  shouldRollback: boolean;
  severity: 'info' | 'warning' | 'high' | 'critical';
  reasons: string[];
  actions: string[];
  estimatedRecoveryTime: number; // ç§’
}

interface RollbackResult {
  rollbackId: string;
  startTime: Date;
  actions: RollbackActionResult[];
  success: boolean;
  errors: string[];
  completionTime: Date | null;
  recoveryValidation: RecoveryValidationResult | null;
}

interface RollbackActionResult {
  action: string;
  success: boolean;
  duration: number;
  error?: string;
}

interface RecoveryValidationResult {
  systemStable: boolean;
  performanceRecovered: boolean;
  consistencyRestored: boolean;
  resourcePressureRelieved: boolean;
  validationTime: Date;
}
```

### 8.3 æ¸è¿›å¼è¿ç§»æ§åˆ¶

**Feature Flag é©±åŠ¨çš„å®‰å…¨è¿ç§»**ï¼š
```typescript
// src/monitoring/services/migration-controller.service.ts
@Injectable()
export class MigrationControllerService implements OnModuleInit {
  private readonly logger = createLogger(MigrationControllerService.name);
  private migrationState: MigrationState = 'not_started';
  private phaseStartTimes: Map<string, number> = new Map();

  constructor(
    private readonly featureFlags: FeatureFlags,
    private readonly migrationMetrics: MigrationMetricsService,
    private readonly rollbackManager: RollbackManagerService,
  ) {}

  async onModuleInit() {
    // å¯åŠ¨è¿ç§»çŠ¶æ€ç›‘æ§
    this.startMigrationMonitoring();
  }

  async getCurrentPhase(): Promise<MigrationPhaseStatus> {
    const flags = await this.getAllMigrationFlags();
    
    if (!flags.dualWriteEnabled) {
      return { phase: 'phase_0', status: 'not_started', description: 'è¿ç§»æœªå¼€å§‹' };
    } else if (flags.dualWriteEnabled && !flags.prometheusAsPrimary) {
      return { phase: 'phase_1', status: 'in_progress', description: 'åŒå†™æ¨¡å¼è¿è¡Œä¸­' };
    } else if (flags.prometheusAsPrimary && !flags.legacyDisabled) {
      return { phase: 'phase_2', status: 'in_progress', description: 'Prometheusä¸ºä¸»æ•°æ®æº' };
    } else if (flags.legacyDisabled) {
      return { phase: 'phase_3', status: 'completed', description: 'å®Œå…¨è¿ç§»åˆ°Prometheus' };
    }

    return { phase: 'unknown', status: 'error', description: 'æœªçŸ¥è¿ç§»çŠ¶æ€' };
  }

  async advanceToNextPhase(): Promise<PhaseTransitionResult> {
    const currentPhase = await this.getCurrentPhase();
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    
    // æ£€æŸ¥å½“å‰é˜¶æ®µæ˜¯å¦ç¨³å®š
    const stabilityCheck = await this.validatePhaseStability(currentPhase.phase, metrics);
    if (!stabilityCheck.stable) {
      return {
        success: false,
        fromPhase: currentPhase.phase,
        toPhase: currentPhase.phase,
        reason: `å½“å‰é˜¶æ®µä¸ç¨³å®š: ${stabilityCheck.issues.join(', ')}`,
        recommendation: 'ç­‰å¾…ç³»ç»Ÿç¨³å®šåå†è¿›è¡Œä¸‹ä¸€é˜¶æ®µ',
      };
    }

    switch (currentPhase.phase) {
      case 'phase_0':
        return this.transitionToPhase1();
      case 'phase_1':
        return this.transitionToPhase2(metrics);
      case 'phase_2':
        return this.transitionToPhase3(metrics);
      default:
        return {
          success: false,
          fromPhase: currentPhase.phase,
          toPhase: currentPhase.phase,
          reason: 'æ— æ³•ç¡®å®šä¸‹ä¸€é˜¶æ®µ',
        };
    }
  }

  private async transitionToPhase1(): Promise<PhaseTransitionResult> {
    try {
      // å¯ç”¨åŒå†™æ¨¡å¼
      await this.featureFlags.setFlag('metrics.dual_write_mode', true);
      await this.featureFlags.setFlag('metrics.prometheus_write', true);
      
      this.phaseStartTimes.set('phase_1', Date.now());
      this.logger.info('å·²è¿›å…¥Phase 1: åŒå†™æ¨¡å¼');

      return {
        success: true,
        fromPhase: 'phase_0',
        toPhase: 'phase_1',
        actions: ['å¯ç”¨åŒå†™æ¨¡å¼', 'å¯ç”¨Prometheuså†™å…¥'],
        nextReviewTime: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24å°æ—¶åè¯„ä¼°
      };
    } catch (error) {
      return { success: false, fromPhase: 'phase_0', toPhase: 'phase_0', reason: error.message };
    }
  }

  private async transitionToPhase2(metrics: MigrationMetricsDto): Promise<PhaseTransitionResult> {
    // æ£€æŸ¥åŒå†™æ¨¡å¼è¿è¡Œæ—¶é—´å’Œç¨³å®šæ€§
    const phase1StartTime = this.phaseStartTimes.get('phase_1') || 0;
    const phase1Duration = Date.now() - phase1StartTime;
    
    if (phase1Duration < 48 * 60 * 60 * 1000) { // è‡³å°‘è¿è¡Œ48å°æ—¶
      return {
        success: false,
        fromPhase: 'phase_1',
        toPhase: 'phase_1',
        reason: `åŒå†™æ¨¡å¼è¿è¡Œæ—¶é—´ä¸è¶³48å°æ—¶ (å½“å‰: ${Math.round(phase1Duration / (60 * 60 * 1000))}å°æ—¶)`,
        recommendation: 'ç»§ç»­è§‚å¯ŸåŒå†™æ¨¡å¼ç¨³å®šæ€§',
      };
    }

    if (metrics.consistency.overallConsistency < 0.98) {
      return {
        success: false,
        fromPhase: 'phase_1',
        toPhase: 'phase_1',
        reason: `æ•°æ®ä¸€è‡´æ€§ä¸è¶³98% (å½“å‰: ${(metrics.consistency.overallConsistency * 100).toFixed(1)}%)`,
        recommendation: 'ä¿®å¤æ•°æ®ä¸€è‡´æ€§é—®é¢˜åå†è¿›è¡Œåˆ‡æ¢',
      };
    }

    try {
      // åˆ‡æ¢åˆ°Prometheusä¸ºä¸»æ•°æ®æº
      await this.featureFlags.setFlag('metrics.prometheus_primary', true);
      
      this.phaseStartTimes.set('phase_2', Date.now());
      this.logger.info('å·²è¿›å…¥Phase 2: Prometheusä¸ºä¸»æ•°æ®æº');

      return {
        success: true,
        fromPhase: 'phase_1',
        toPhase: 'phase_2',
        actions: ['åˆ‡æ¢Prometheusä¸ºä¸»æ•°æ®æº'],
        nextReviewTime: new Date(Date.now() + 72 * 60 * 60 * 1000), // 72å°æ—¶åè¯„ä¼°
      };
    } catch (error) {
      return { success: false, fromPhase: 'phase_1', toPhase: 'phase_1', reason: error.message };
    }
  }

  private async transitionToPhase3(metrics: MigrationMetricsDto): Promise<PhaseTransitionResult> {
    // ä¸¥æ ¼çš„æœ€ç»ˆè¿ç§»æ¡ä»¶æ£€æŸ¥
    const phase2StartTime = this.phaseStartTimes.get('phase_2') || 0;
    const phase2Duration = Date.now() - phase2StartTime;
    
    if (phase2Duration < 72 * 60 * 60 * 1000) { // è‡³å°‘è¿è¡Œ72å°æ—¶
      return {
        success: false,
        fromPhase: 'phase_2',
        toPhase: 'phase_2',
        reason: `Prometheusä¸»æ¨¡å¼è¿è¡Œæ—¶é—´ä¸è¶³72å°æ—¶`,
      };
    }

    const requiredConditions = [
      { condition: metrics.consistency.overallConsistency >= 0.99, name: 'æ•°æ®ä¸€è‡´æ€§ >= 99%' },
      { condition: metrics.errors.metricsWriteErrorRate < 0.001, name: 'é”™è¯¯ç‡ < 0.1%' },
      { condition: metrics.performance.avgWriteLatency < 50, name: 'å†™å…¥å»¶è¿Ÿ < 50ms' },
      { condition: metrics.overallHealth.score >= 95, name: 'æ€»ä½“å¥åº·åˆ†æ•° >= 95' },
    ];

    const failedConditions = requiredConditions.filter(c => !c.condition);
    if (failedConditions.length > 0) {
      return {
        success: false,
        fromPhase: 'phase_2',
        toPhase: 'phase_2',
        reason: `æœªæ»¡è¶³æœ€ç»ˆè¿ç§»æ¡ä»¶: ${failedConditions.map(c => c.name).join(', ')}`,
        recommendation: 'ç»§ç»­ä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½å’Œç¨³å®šæ€§',
      };
    }

    try {
      // å®Œå…¨ç¦ç”¨æ—§ç³»ç»Ÿ
      await this.featureFlags.setFlag('metrics.legacy_storage_disabled', true);
      await this.featureFlags.setFlag('metrics.dual_write_mode', false);
      
      this.phaseStartTimes.set('phase_3', Date.now());
      this.logger.info('å·²è¿›å…¥Phase 3: å®Œå…¨è¿ç§»åˆ°Prometheus');

      return {
        success: true,
        fromPhase: 'phase_2',
        toPhase: 'phase_3',
        actions: ['ç¦ç”¨æ—§å­˜å‚¨ç³»ç»Ÿ', 'å…³é—­åŒå†™æ¨¡å¼'],
        migrationCompleted: true,
      };
    } catch (error) {
      return { success: false, fromPhase: 'phase_2', toPhase: 'phase_2', reason: error.message };
    }
  }

  private async startMigrationMonitoring() {
    setInterval(async () => {
      try {
        const rollbackDecision = await this.rollbackManager.evaluateRollbackConditions();
        if (rollbackDecision.shouldRollback) {
          this.logger.warn('è‡ªåŠ¨å›æ»šæ¡ä»¶è§¦å‘', rollbackDecision);
          await this.rollbackManager.executeRollback(rollbackDecision);
        }
      } catch (error) {
        this.logger.error('è¿ç§»ç›‘æ§å¤±è´¥', { error: error.message });
      }
    }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
  }
}

// æ¥å£å®šä¹‰
type MigrationState = 'not_started' | 'phase_1' | 'phase_2' | 'phase_3' | 'completed' | 'rolled_back';

interface MigrationPhaseStatus {
  phase: string;
  status: 'not_started' | 'in_progress' | 'completed' | 'error';
  description: string;
}

interface PhaseTransitionResult {
  success: boolean;
  fromPhase: string;
  toPhase: string;
  reason?: string;
  actions?: string[];
  recommendation?: string;
  nextReviewTime?: Date;
  migrationCompleted?: boolean;
}
```

### 8.4 ç”Ÿäº§å°±ç»ªæ£€æŸ¥æ¸…å•

**éƒ¨ç½²å‰éªŒè¯æ¸…å•**ï¼š
```typescript
// src/monitoring/services/production-readiness.service.ts
@Injectable()
export class ProductionReadinessService {
  private readonly logger = createLogger(ProductionReadinessService.name);

  async performReadinessCheck(): Promise<ProductionReadinessReport> {
    const report: ProductionReadinessReport = {
      timestamp: new Date(),
      overallReady: false,
      categories: [],
      criticalIssues: [],
      recommendations: [],
    };

    const categories = [
      await this.checkArchitectureReadiness(),
      await this.checkPerformanceReadiness(),
      await this.checkSecurityReadiness(),
      await this.checkMonitoringReadiness(),
      await this.checkOperationalReadiness(),
    ];

    report.categories = categories;
    report.overallReady = categories.every(c => c.ready);
    report.criticalIssues = categories.flatMap(c => c.criticalIssues);
    report.recommendations = categories.flatMap(c => c.recommendations);

    return report;
  }

  private async checkArchitectureReadiness(): Promise<ReadinessCategory> {
    const checks = [
      { name: 'å•ä¾‹MetricsRegistryService', check: () => this.validateSingletonRegistry() },
      { name: 'å…¨å±€çŠ¶æ€æ¶ˆé™¤', check: () => this.validateNoGlobalState() },
      { name: 'å¾ªç¯ä¾èµ–æ£€æŸ¥', check: () => this.validateNoCyclicDependencies() },
      { name: 'æ¨¡å—è¾¹ç•Œæ¸…æ™°', check: () => this.validateModuleBoundaries() },
    ];

    const results = await Promise.allSettled(checks.map(c => c.check()));
    const passed = results.filter(r => r.status === 'fulfilled').length;

    return {
      name: 'æ¶æ„è®¾è®¡',
      ready: passed === checks.length,
      passedChecks: passed,
      totalChecks: checks.length,
      criticalIssues: results
        .filter((r, i) => r.status === 'rejected')
        .map((r, i) => `${checks[i].name}: ${r.reason}`),
      recommendations: passed < checks.length ? ['ä¿®å¤æ¶æ„è®¾è®¡é—®é¢˜åå†éƒ¨ç½²'] : [],
    };
  }

  private async checkPerformanceReadiness(): Promise<ReadinessCategory> {
    const metrics = await this.collectCurrentMetrics();
    const issues = [];
    const recommendations = [];

    if (metrics.avgWriteLatency > 100) {
      issues.push(`å†™å…¥å»¶è¿Ÿè¿‡é«˜: ${metrics.avgWriteLatency}ms`);
      recommendations.push('ä¼˜åŒ–å†™å…¥æ€§èƒ½æˆ–å¯ç”¨æ‰¹é‡æ¨¡å¼');
    }

    if (metrics.exportLatency > 500) {
      issues.push(`å¯¼å‡ºå»¶è¿Ÿè¿‡é«˜: ${metrics.exportLatency}ms`);
      recommendations.push('ä¼˜åŒ–æŒ‡æ ‡å¯¼å‡ºé€»è¾‘');
    }

    if (metrics.cacheHitRate < 0.7) {
      issues.push(`ç¼“å­˜å‘½ä¸­ç‡ä½: ${(metrics.cacheHitRate * 100).toFixed(1)}%`);
      recommendations.push('è°ƒæ•´ç¼“å­˜ç­–ç•¥');
    }

    return {
      name: 'æ€§èƒ½æŒ‡æ ‡',
      ready: issues.length === 0,
      passedChecks: 3 - issues.length,
      totalChecks: 3,
      criticalIssues: issues,
      recommendations,
    };
  }

  private async checkSecurityReadiness(): Promise<ReadinessCategory> {
    // å®‰å…¨æ£€æŸ¥é€»è¾‘
    return {
      name: 'å®‰å…¨é…ç½®',
      ready: true,
      passedChecks: 4,
      totalChecks: 4,
      criticalIssues: [],
      recommendations: [],
    };
  }

  private async checkMonitoringReadiness(): Promise<ReadinessCategory> {
    // ç›‘æ§ç³»ç»Ÿæ£€æŸ¥é€»è¾‘
    return {
      name: 'ç›‘æ§ç³»ç»Ÿ',
      ready: true,
      passedChecks: 5,
      totalChecks: 5,
      criticalIssues: [],
      recommendations: [],
    };
  }

  private async checkOperationalReadiness(): Promise<ReadinessCategory> {
    // è¿ç»´å‡†å¤‡æ£€æŸ¥é€»è¾‘
    return {
      name: 'è¿ç»´å‡†å¤‡',
      ready: true,
      passedChecks: 6,
      totalChecks: 6,
      criticalIssues: [],
      recommendations: [],
    };
  }
}

interface ProductionReadinessReport {
  timestamp: Date;
  overallReady: boolean;
  categories: ReadinessCategory[];
  criticalIssues: string[];
  recommendations: string[];
}

interface ReadinessCategory {
  name: string;
  ready: boolean;
  passedChecks: number;
  totalChecks: number;
  criticalIssues: string[];
  recommendations: string[];
}
```

## 9. åˆ†é˜¶æ®µå®æ–½è·¯çº¿å›¾

### 9.1 Sprint è§„åˆ’ä¸é‡Œç¨‹ç¢‘

**Sprint 1 (ç¬¬1å‘¨) - åŸºç¡€è®¾æ–½ä¿®å¤**ï¼š
- âœ… ä»»åŠ¡ A1ï¼šä¿®å¤ `MetricsRegistryService` åŒå®ä¾‹é—®é¢˜
- âœ… ä»»åŠ¡ A2ï¼šå®æ–½å®ä¾‹ä¸€è‡´æ€§éªŒè¯
- âœ… ä»»åŠ¡ A3ï¼š`PerformanceMonitorService` åŒå†™é€‚é…å±‚
- ğŸ¯ **é‡Œç¨‹ç¢‘**ï¼šåŸºç¡€æ¶æ„ç¨³å®šï¼ŒåŒå†™æœºåˆ¶å°±ç»ª

**Sprint 2 (ç¬¬2-3å‘¨) - æ¸è¿›å¼è¿ç§»**ï¼š
- âœ… ä»»åŠ¡ B1ï¼šæ§åˆ¶å™¨æ™ºèƒ½æ•°æ®æºåˆ‡æ¢
- âœ… ä»»åŠ¡ B2ï¼šè£…é¥°å™¨DIæ ‡å‡†åŒ–æ”¹é€   
- âœ… ä»»åŠ¡ B3ï¼šPrometheusæŒ‡æ ‡è§£æå·¥å…·
- ğŸ¯ **é‡Œç¨‹ç¢‘**ï¼šåŒç³»ç»Ÿå¹¶è¡Œè¿è¡Œï¼Œæ•°æ®ä¸€è‡´æ€§>95%

**Sprint 3 (ç¬¬4å‘¨) - å®Œæ•´è¿ç§»**ï¼š
- âœ… ä»»åŠ¡ C1ï¼šç§»é™¤å…¨å±€çŠ¶æ€ä¾èµ–
- âœ… ä»»åŠ¡ C2ï¼šæ¸…ç†å†—ä½™æ¨¡å—å¼•ç”¨
- âœ… ä»»åŠ¡ C3ï¼šç”Ÿäº§ç¯å¢ƒéªŒè¯
- ğŸ¯ **é‡Œç¨‹ç¢‘**ï¼šå®Œå…¨è¿ç§»åˆ°Prometheusï¼Œæ€§èƒ½æå‡20%

**Sprint 4 (ç¬¬5å‘¨) - ç›‘æ§å¢å¼º**ï¼š
- âœ… ä»»åŠ¡ D1ï¼šå®æ—¶ç›‘æ§ä»ªè¡¨æ¿
- âœ… ä»»åŠ¡ D2ï¼šè‡ªåŠ¨é¢„è­¦ç³»ç»Ÿ
- âœ… ä»»åŠ¡ D3ï¼šæ€§èƒ½åŸºå‡†å»ºç«‹
- ğŸ¯ **é‡Œç¨‹ç¢‘**ï¼šç›‘æ§ä½“ç³»å®Œå–„ï¼Œè¿ç»´è‡ªåŠ¨åŒ–

### 9.2 å…³é”®å†³ç­–èŠ‚ç‚¹

1. **Phase 0 â†’ Phase 1**: åŒå®ä¾‹é—®é¢˜è§£å†³ç¡®è®¤
2. **Phase 1 â†’ Phase 2**: æ•°æ®ä¸€è‡´æ€§è¾¾åˆ°98%+ï¼Œè¿è¡Œç¨³å®š48å°æ—¶
3. **Phase 2 â†’ Phase 3**: ç³»ç»Ÿå¥åº·åˆ†æ•°95+ï¼Œæ— å…³é”®å‘Šè­¦72å°æ—¶
4. **æœ€ç»ˆéªŒæ”¶**: æ€§èƒ½æå‡ç¡®è®¤ï¼Œå›æ»šèƒ½åŠ›éªŒè¯

### 9.3 æˆåŠŸæ ‡å‡†ä¸éªŒæ”¶æ¡ä»¶

**æŠ€æœ¯æŒ‡æ ‡**ï¼š
- æ•°æ®ä¸€è‡´æ€§ â‰¥ 99%
- å†™å…¥å»¶è¿Ÿ < 50ms (P95)
- å¯¼å‡ºå»¶è¿Ÿ < 200ms (P99)
- é”™è¯¯ç‡ < 0.1%
- ç³»ç»Ÿå¯ç”¨æ€§ â‰¥ 99.9%

**ä¸šåŠ¡æŒ‡æ ‡**ï¼š
- ç›‘æ§æ•°æ®å®Œæ•´æ€§ 100%
- å†å²æ•°æ®æ— ä¸¢å¤±
- APIå“åº”å¥‘çº¦ä¸å˜
- è¿ç»´æ“ä½œæ— å¢åŠ 

â€”â€”

**ğŸ¯ å…³é”®æé†’**ï¼šå½“å‰ç›‘æ§æŒ‡æ ‡æ¨¡å—é‡æ„æ–¹æ¡ˆå·²å…¨é¢å¢å¼ºï¼ŒåŒ…å«ï¼š
- âœ… **P0é—®é¢˜è§£å†³æ–¹æ¡ˆ**ï¼šè¯¦ç»†çš„ä»£ç ä¿®å¤æ­¥éª¤å’ŒéªŒè¯æ–¹æ³•
- âœ… **Feature Flagæ§åˆ¶**ï¼šæ¸è¿›å¼è¿ç§»å’Œæ™ºèƒ½å›æ»š
- âœ… **å…¨é¢æµ‹è¯•ç­–ç•¥**ï¼šå•å…ƒã€é›†æˆã€E2Eã€æ€§èƒ½æµ‹è¯•
- âœ… **å®æ—¶ç›‘æ§ç³»ç»Ÿ**ï¼šKPIæ”¶é›†ã€å‘Šè­¦ç®¡ç†ã€è‡ªåŠ¨æ¢å¤
- âœ… **é£é™©ç®¡æ§æœºåˆ¶**ï¼šå¤šå±‚çº§é£é™©è¯„ä¼°å’Œè‡ªåŠ¨å›æ»š
- âœ… **ç”Ÿäº§éƒ¨ç½²æŒ‡å—**ï¼šå°±ç»ªæ£€æŸ¥å’Œåˆ†é˜¶æ®µå®æ–½

å»ºè®®**ç«‹å³å¼€å§‹ä»»åŠ¡A1**ï¼ˆMetricsRegistryServiceå•ä¾‹ä¿®å¤ï¼‰ï¼Œè¿™æ˜¯è§£å†³"å†™Aè¯»B"é—®é¢˜çš„å…³é”®ç¬¬ä¸€æ­¥ã€‚ 