### 可执行的遗留代码修复文档（监控/指标子系统）

—— 聚焦“老版应用内指标系统”与“新 Prometheus 注册中心”并存导致的架构冲突，提供分阶段替换方案，保持对外契约不变

## 1. 架构模式对比与背景

- 旧架构（应用内统计、存储驱动）
  - 核心：`PerformanceMonitorService`（应用内缓冲 + 仓储记录 + 全局拦截器/装饰器）
  - 关键入口：
```1:160:src/main.ts
  const performanceMonitor = app.get(PerformanceMonitorService);
  app.useGlobalInterceptors(new PerformanceInterceptor(performanceMonitor, reflector));
  global["performanceMonitorService"] = performanceMonitor;
```
  - 装饰器通过 `global["performanceMonitorService"]` 间接调用：
```1:101:src/metrics/decorators/database-performance.decorator.ts
const performanceMonitor =
  this.performanceMonitor || (global["performanceMonitorService"] as PerformanceMonitorService);
```
  - 服务实现（节选）：
```1:120:src/metrics/services/performance-monitor.service.ts
@Injectable()
export class PerformanceMonitorService {
  // 记录数据库查询、缓存操作、认证等，并存储/聚合到仓储
```

- 新架构（Prometheus 注册中心统一指标）
  - 核心：`MetricsRegistryService` + 轻量 `Metrics` 工具
  - 统一在注册中心创建 `Counter/Gauge/Histogram`，并经 `GET /monitoring/metrics` 导出
    - 注册中心：
```1:120:src/monitoring/metrics/services/metrics-registry.service.ts
export class MetricsRegistryService implements OnModuleInit, OnModuleDestroy {
  constructor(private readonly featureFlags: FeatureFlags) {
    this.registry = new Registry();
    collectDefaultMetrics({ register: this.registry, prefix: 'newstock_', ... });
```
    - 业务层调用通过 `Metrics` 工具解耦：
```1:130:src/monitoring/metrics/metrics-helper.ts
export class Metrics {
  static inc(registry: MetricsRegistryService, name: string, labels?: object, value = 1, legacyCallback?: () => void)
```
    - Prometheus 导出端点（已存在）：
```800:1025:src/monitoring/controller/monitoring.controller.ts
@Get("metrics")
async getPrometheusMetrics(@Res() res: Response) {
  const metricsData = await this.metricsRegistry.getMetrics();
  res.setHeader('Content-Type', 'text/plain; version=0.0.4; charset=utf-8');
  res.send(metricsData);
}
```

结论：当前系统同时运行两套指标体系（旧应用内统计 + 新 Prometheus 注册中心），且在依赖注入层面对注册中心存在“重复实例化”风险，导致指标写入与导出可能来自不同实例。

## 2. 问题标记（含证据与冲突说明）

- 严重-Critical｜重复实例化 `MetricsRegistryService`
  - 证据1：全局共享模块已提供注册中心（Global）
```1:65:src/core/shared/module/shared-services.module.ts
@Global()
@Module({
  providers: [FeatureFlags, MetricsRegistryService, ...],
  exports:   [FeatureFlags, MetricsRegistryService, ...],
})
```
  - 证据2：`MonitoringModule` 也本地提供/导出同一服务
```1:20:src/monitoring/module/monitoring.module.ts
providers: [MetricsInitializerService, MetricsRegistryService],
exports: [MetricsInitializerService, MetricsRegistryService],
```
  - 冲突说明：NestJS 中相同 token 在不同模块各自实例化。业务服务（通过 `SharedServicesModule` 注入的全局实例）写入 A 实例；控制器（通过 `MonitoringModule` 提供者）导出 B 实例。Prometheus 导出可能不包含业务计数，出现“写 A、读 B”现象。

- 高-High｜旧系统强依赖全局可变状态与专用拦截器
  - 证据：
```1:160:src/main.ts
global["performanceMonitorService"] = performanceMonitor;
```
```1:101:src/metrics/decorators/database-performance.decorator.ts
(global["performanceMonitorService"] as PerformanceMonitorService)
```
  - 冲突说明：全局可变状态对测试可靠性、模块化和并发环境不友好；且与 Prometheus 无关，难以统一。

- 高-High｜监控控制器混用两套体系
  - 证据：同时注入 `PerformanceMonitorService` 和 `MetricsRegistryService`，并暴露两类接口
```39:47:src/monitoring/controller/monitoring.controller.ts
constructor(
  private readonly performanceMonitor: PerformanceMonitorService,
  private readonly metricsRegistry: MetricsRegistryService,
```
  - 冲突说明：调用方无法明确“权威数据源”。引入迁移期数据不一致风险。

- 中-Medium｜`MetricsModule`（旧）仍被 `AppModule` 与 `MonitoringModule` 引入
```24:116:src/app.module.ts
imports: [ ..., MonitoringModule, ..., MetricsModule, ... ]
```
```1:20:src/monitoring/module/monitoring.module.ts
imports: [ ..., MetricsModule, SharedServicesModule ]
```
  - 冲突说明：新旧模块交叉引用，令迁移收敛难度上升。

- 中-Medium｜默认指标注册多实例隐患
  - 证据：`collectDefaultMetrics({ register: this.registry })` 绑定到构造的 registry 实例  
  - 冲突说明：若重复实例化，将产生多份“默认系统指标”，导出端点与业务写入错位。

## 3. 分阶段替换方案（保持接口契约不变）

- Phase 0（立即，1 天）
  - 目标：消除“重复实例化”，对外行为不变
  - 动作：
    - 统一 `MetricsRegistryService` 的提供者来源，仅保留 `SharedServicesModule`（Global）提供；`MonitoringModule` 不再单独提供/导出该服务，改为依赖全局导出。
    - 验证所有注入点均取到同一实例（在一处输出 `registry.metrics()` 长度，对比控制器导出的指标数一致）。
  - 风险控制：纯 DI 层调整，无业务逻辑变更。若必须临时保留 `MonitoringModule` 提供者，则改为 `useExisting: MetricsRegistryService` 指向全局实例，避免双实例。

- Phase 1（短期，2-3 天）
  - 目标：停止新增旧体系依赖、收束入口
  - 动作：
    - 在 `PerformanceMonitorService` 中引入“适配层”，将核心埋点同时转发到 `MetricsRegistryService`（通过 `Metrics` 工具），保持原仓储写入不变。对外 DTO/接口保持不变。
    - 在 `PerformanceInterceptor` 和装饰器中增加对 `Metrics` 的调用，但保留原逻辑，确保两边数据一致期。
    - 将 `MetricsInitializerService` 的 `legacyMode` 固定为 false（现已如此），并标注弃用旧内存统计路径。
  - 风险控制：双写期间若 Prometheus 指标遗漏，可回溯旧仓储数据。

- Phase 2（中期，1-2 周）
  - 目标：替换调用方到新注册中心，淡化旧服务
  - 动作：
    - `MonitoringController` 的“性能/数据库/Redis/系统”查询接口维持 DTO 不变，但内部计算逐步改用 Prometheus 指标（或从 `MetricsRegistryService.getMetricsSummary()` 衍生），以减少对旧仓储的强依赖。
    - 将 `main.ts` 的全局变量访问替换为标准 DI，用于装饰器/拦截器获取 `PerformanceMonitorService` 或直接接受 `MetricsRegistryService` 的轻量封装。
    - 明确“权威指标源”为 Prometheus，旧仓储仅为过渡期备份。
  - 风险控制：按端点逐项替换，单点回退容易。

- Phase 3（收尾，1 周）
  - 目标：移除旧体系、清理冗余模块与全局状态
  - 动作：
    - 停用全局变量 `global["performanceMonitorService"]`；将 `DatabasePerformance`/`CachePerformance`/`AuthPerformance` 装饰器改为直接使用 `Metrics` 写入注册中心。
    - 评估 `MetricsModule`（旧）是否仍需保留；若不再需要，进行模块下线（先从 `MonitoringModule` 移除，再从 `AppModule` 移除）。
    - 去除旧仓储路径的写入，保留只读迁移观测一段时间后完全删除。
  - 风险控制：以开关或环境变量控制“旧仓储写入是否开启”，确保灰度下线。

## 4. 详细问题项与修复步骤

### 4.1 问题 A（Critical）：MetricsRegistryService 多实例冲突

**问题识别与影响分析**：
- **根本原因**：同一服务在不同模块中重复提供，导致 NestJS 创建多个实例
- **业务影响**：业务服务写入实例A，监控端点读取实例B，造成指标丢失
- **技术债务**：违反单例原则，增加内存占用和调试复杂度

**代码定位与现状**：
```typescript
// src/core/shared/module/shared-services.module.ts (全局提供)
@Global()
@Module({
  providers: [FeatureFlags, MetricsRegistryService, CommonCacheService],
  exports: [FeatureFlags, MetricsRegistryService, CommonCacheService],
})

// src/monitoring/module/monitoring.module.ts (本地重复提供)
@Module({
  providers: [MetricsInitializerService, MetricsRegistryService], // 🚨 重复实例化
  exports: [MetricsInitializerService, MetricsRegistryService],
})
```

**增强修复方案**：

1. **立即修复（Phase 0）**：
```typescript
// 修改 src/monitoring/module/monitoring.module.ts
@Module({
  imports: [SharedServicesModule], // 确保依赖全局模块
  providers: [
    MetricsInitializerService,
    // 移除 MetricsRegistryService 或使用 useExisting
    {
      provide: MetricsRegistryService,
      useExisting: MetricsRegistryService, // 指向全局实例
    }
  ],
  exports: [MetricsInitializerService], // 不再导出 MetricsRegistryService
  controllers: [MonitoringController],
})
export class MonitoringModule {}
```

2. **实例验证脚本**：
```typescript
// 添加到 src/monitoring/services/metrics-validation.service.ts
@Injectable()
export class MetricsValidationService {
  constructor(private readonly metricsRegistry: MetricsRegistryService) {}

  async validateSingleInstance(): Promise<boolean> {
    // 生成唯一标识符并写入指标
    const testId = `test_${Date.now()}_${Math.random()}`;
    
    // 业务层写入
    Metrics.inc(this.metricsRegistry, 'validation_test_counter', {
      test_id: testId,
      source: 'business'
    });

    // 等待指标处理
    await new Promise(resolve => setTimeout(resolve, 100));

    // 检查导出端点是否包含该指标
    const metricsText = await this.metricsRegistry.getMetrics();
    const containsMetric = metricsText.includes(`validation_test_counter{test_id="${testId}"`);

    return containsMetric;
  }

  async getInstanceInfo(): Promise<{
    registryId: string;
    metricsCount: number;
    defaultMetricsEnabled: boolean;
  }> {
    const registry = (this.metricsRegistry as any).registry;
    return {
      registryId: registry._id || 'unknown',
      metricsCount: registry.getMetricsAsArray().length,
      defaultMetricsEnabled: registry._defaultLabels !== undefined,
    };
  }
}
```

3. **健康检查集成**：
```typescript
// 在 src/monitoring/controller/monitoring.controller.ts 中添加
@Get('metrics-health')
@Auth([UserRole.ADMIN])
async checkMetricsHealth(): Promise<{
  singleInstance: boolean;
  instanceInfo: any;
  registryConsistency: boolean;
}> {
  const singleInstance = await this.validationService.validateSingleInstance();
  const instanceInfo = await this.validationService.getInstanceInfo();
  
  return {
    singleInstance,
    instanceInfo,
    registryConsistency: singleInstance && instanceInfo.metricsCount > 0,
  };
}
```

### 4.2 问题 B（High）：全局状态消除与 DI 标准化

**问题识别与技术债务**：
- **全局污染**：`global["performanceMonitorService"]` 破坏模块边界
- **测试困难**：全局状态导致测试隔离问题
- **并发风险**：多线程环境下的竞态条件隐患

**代码定位与现状**：
```typescript
// src/main.ts (约78行，非160行)
const performanceMonitor = app.get(PerformanceMonitorService);
app.useGlobalInterceptors(new PerformanceInterceptor(performanceMonitor, reflector));
global["performanceMonitorService"] = performanceMonitor; // 🚨 全局状态

// src/metrics/decorators/database-performance.decorator.ts
const performanceMonitor = 
  this.performanceMonitor || (global["performanceMonitorService"] as PerformanceMonitorService);
```

**增强重构方案**：

1. **Phase 1 - 双写适配层**：
```typescript
// 增强 src/metrics/services/performance-monitor.service.ts
@Injectable()
export class PerformanceMonitorService implements OnModuleInit {
  private readonly logger = createLogger(PerformanceMonitorService.name);

  constructor(
    private readonly metricsRegistry: MetricsRegistryService,
    @Inject(forwardRef(() => FeatureFlags)) private readonly featureFlags: FeatureFlags,
  ) {}

  async onModuleInit() {
    // 检查双写模式配置
    const dualWriteEnabled = await this.featureFlags.isEnabled('metrics.dual_write_mode');
    this.logger.log(`Performance monitor initialized with dual write: ${dualWriteEnabled}`);
  }

  async recordDatabaseQuery(operation: string, duration: number, metadata?: any): Promise<void> {
    // 保持原有仓储写入
    await this.recordToStorage(operation, duration, metadata);

    // 新增 Prometheus 写入
    if (await this.featureFlags.isEnabled('metrics.prometheus_write')) {
      Metrics.observe(this.metricsRegistry, 'database_query_duration_ms', duration, {
        operation,
        provider: metadata?.provider || 'unknown',
        success: metadata?.success ? 'true' : 'false',
      });

      Metrics.inc(this.metricsRegistry, 'database_operations_total', {
        operation,
        provider: metadata?.provider || 'unknown',
      });
    }
  }

  private async recordToStorage(operation: string, duration: number, metadata?: any): Promise<void> {
    // 现有的仓储逻辑保持不变
    // ... existing storage logic
  }
}
```

2. **Phase 2 - 装饰器 DI 标准化**：
```typescript
// 重构 src/metrics/decorators/database-performance.decorator.ts
export function DatabasePerformance(options?: PerformanceOptions) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const startTime = Date.now();
      let result: any;
      let error: any;

      try {
        result = await originalMethod.apply(this, args);
        return result;
      } catch (err) {
        error = err;
        throw err;
      } finally {
        const duration = Date.now() - startTime;

        // 使用 NestJS 应用上下文获取服务实例
        const app = await NestFactory.createApplicationContext(AppModule, { logger: false });
        const performanceMonitor = app.get(PerformanceMonitorService);
        
        await performanceMonitor.recordDatabaseQuery(
          propertyName,
          duration,
          {
            success: !error,
            operation: options?.operation || propertyName,
            provider: options?.provider,
            error: error?.message,
          }
        );

        await app.close();
      }
    };

    return descriptor;
  };
}
```

3. **Phase 2.5 - 轻量级 Metrics 装饰器**：
```typescript
// 新增 src/monitoring/decorators/prometheus-performance.decorator.ts
export function PrometheusPerformance(metricName: string, options?: {
  labels?: Record<string, string>;
  threshold?: number;
}) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const className = target.constructor.name;

    descriptor.value = async function (...args: any[]) {
      const startTime = Date.now();
      const labels = {
        class: className,
        method: propertyName,
        ...options?.labels,
      };

      try {
        const result = await originalMethod.apply(this, args);
        
        const duration = Date.now() - startTime;
        
        // 直接使用注入的 MetricsRegistryService
        if (this.metricsRegistry) {
          Metrics.observe(this.metricsRegistry, `${metricName}_duration_ms`, duration, labels);
          Metrics.inc(this.metricsRegistry, `${metricName}_total`, { ...labels, status: 'success' });
          
          // 性能警告
          if (options?.threshold && duration > options.threshold) {
            Metrics.inc(this.metricsRegistry, `${metricName}_slow_total`, labels);
          }
        }

        return result;
      } catch (error) {
        const duration = Date.now() - startTime;
        
        if (this.metricsRegistry) {
          Metrics.observe(this.metricsRegistry, `${metricName}_duration_ms`, duration, labels);
          Metrics.inc(this.metricsRegistry, `${metricName}_total`, { 
            ...labels, 
            status: 'error',
            error_type: error.constructor.name,
          });
        }

        throw error;
      }
    };

    return descriptor;
  };
}
```

### 4.3 问题 C（High）：监控控制器双体系统一

**现状分析**：
- 同时注入两套监控服务，API响应数据来源不明确
- 迁移期间可能出现数据不一致
- 调用方无法判断权威数据源

**增强迁移方案**：

1. **控制器适配层重构**：
```typescript
// 重构 src/monitoring/controller/monitoring.controller.ts
@Controller('monitoring')
export class MonitoringController {
  private readonly logger = createLogger(MonitoringController.name);

  constructor(
    private readonly performanceMonitor: PerformanceMonitorService,
    private readonly metricsRegistry: MetricsRegistryService,
    private readonly featureFlags: FeatureFlags,
  ) {}

  @Get('performance')
  @Auth([UserRole.ADMIN])
  async getPerformanceMetrics(
    @Query() query: PerformanceQueryDto,
  ): Promise<PerformanceMetricsDto> {
    // 智能数据源选择
    const usePrometheus = await this.featureFlags.isEnabled('metrics.prometheus_primary');
    
    if (usePrometheus) {
      return this.getPerformanceFromPrometheus(query);
    } else {
      return this.getPerformanceFromStorage(query);
    }
  }

  @Get('database')
  @Auth([UserRole.ADMIN])
  async getDatabaseMetrics(
    @Query() query: DatabaseQueryDto,
  ): Promise<DatabaseMetricsDto> {
    const usePrometheus = await this.featureFlags.isEnabled('metrics.prometheus_primary');
    
    if (usePrometheus) {
      return this.getDatabaseFromPrometheus(query);
    } else {
      return this.getDatabaseFromStorage(query);
    }
  }

  private async getPerformanceFromPrometheus(query: PerformanceQueryDto): Promise<PerformanceMetricsDto> {
    try {
      const metricsData = await this.metricsRegistry.getMetrics();
      
      // 解析 Prometheus 文本格式指标
      const parsed = this.parsePrometheusMetrics(metricsData);
      
      return {
        totalRequests: this.extractCounter(parsed, 'http_requests_total'),
        averageResponseTime: this.extractHistogramAvg(parsed, 'http_request_duration_ms'),
        errorRate: this.calculateErrorRate(parsed),
        throughput: this.calculateThroughput(parsed, query.timeRange),
        dataSource: 'prometheus',
        lastUpdated: new Date(),
      };
    } catch (error) {
      this.logger.warn(`Prometheus 数据获取失败，回退到存储数据源: ${error.message}`);
      return this.getPerformanceFromStorage(query);
    }
  }

  private async getDatabaseFromPrometheus(query: DatabaseQueryDto): Promise<DatabaseMetricsDto> {
    try {
      const metricsData = await this.metricsRegistry.getMetrics();
      const parsed = this.parsePrometheusMetrics(metricsData);
      
      return {
        queryCount: this.extractCounter(parsed, 'database_operations_total'),
        averageQueryTime: this.extractHistogramAvg(parsed, 'database_query_duration_ms'),
        slowQueries: this.extractCounter(parsed, 'database_operations_slow_total'),
        connectionPool: this.extractGauge(parsed, 'database_connections_active'),
        dataSource: 'prometheus',
        lastUpdated: new Date(),
      };
    } catch (error) {
      this.logger.warn(`Prometheus 数据库指标获取失败，回退到存储数据源: ${error.message}`);
      return this.getDatabaseFromStorage(query);
    }
  }

  // 保留原有存储数据源方法作为后备
  private async getPerformanceFromStorage(query: PerformanceQueryDto): Promise<PerformanceMetricsDto> {
    const data = await this.performanceMonitor.getPerformanceMetrics(query);
    return { ...data, dataSource: 'storage', lastUpdated: new Date() };
  }

  private async getDatabaseFromStorage(query: DatabaseQueryDto): Promise<DatabaseMetricsDto> {
    const data = await this.performanceMonitor.getDatabaseMetrics(query);
    return { ...data, dataSource: 'storage', lastUpdated: new Date() };
  }
}
```

2. **Prometheus 指标解析工具**：
```typescript
// 新增 src/monitoring/utils/prometheus-parser.util.ts
export class PrometheusParserUtil {
  static parseMetrics(metricsText: string): Map<string, MetricData[]> {
    const lines = metricsText.split('\n');
    const metrics = new Map<string, MetricData[]>();

    for (const line of lines) {
      if (line.startsWith('#') || !line.trim()) continue;

      const match = line.match(/^([a-zA-Z_]+)(\{.*?\})?\s+([0-9.]+)(\s+[0-9]+)?$/);
      if (!match) continue;

      const [, name, labels, value, timestamp] = match;
      
      if (!metrics.has(name)) {
        metrics.set(name, []);
      }

      metrics.get(name)!.push({
        name,
        labels: this.parseLabels(labels),
        value: parseFloat(value),
        timestamp: timestamp ? parseInt(timestamp.trim()) : Date.now(),
      });
    }

    return metrics;
  }

  private static parseLabels(labelsStr?: string): Record<string, string> {
    if (!labelsStr) return {};

    const labels: Record<string, string> = {};
    const cleaned = labelsStr.slice(1, -1); // 移除 { }

    const pairs = cleaned.split(',');
    for (const pair of pairs) {
      const [key, value] = pair.split('=');
      if (key && value) {
        labels[key.trim()] = value.trim().slice(1, -1); // 移除引号
      }
    }

    return labels;
  }
}

interface MetricData {
  name: string;
  labels: Record<string, string>;
  value: number;
  timestamp: number;
}
```

### 4.4 增强验证与测试框架

**多层级验证策略**：

1. **单元测试增强**：
```typescript
// test/jest/unit/monitoring/metrics-registry.service.spec.ts
describe('MetricsRegistryService 单例验证', () => {
  let app: TestingModule;
  let metricsRegistry1: MetricsRegistryService;
  let metricsRegistry2: MetricsRegistryService;

  beforeAll(async () => {
    app = await Test.createTestingModule({
      imports: [SharedServicesModule, MonitoringModule],
    }).compile();

    metricsRegistry1 = app.get(MetricsRegistryService);
    metricsRegistry2 = app.get(MetricsRegistryService, { strict: false });
  });

  it('应该确保全局单例', () => {
    expect(metricsRegistry1).toBe(metricsRegistry2);
  });

  it('业务写入后导出端点应反映变化', async () => {
    const testMetric = `test_metric_${Date.now()}`;
    
    // 业务服务写入
    Metrics.inc(metricsRegistry1, testMetric, { test: 'true' });
    
    // 导出端点读取
    const metricsText = await metricsRegistry2.getMetrics();
    expect(metricsText).toContain(testMetric);
  });
});
```

2. **集成测试增强**：
```typescript
// test/jest/integration/monitoring/dual-write.integration.test.ts
describe('监控指标双写集成测试', () => {
  it('应该同时写入存储和 Prometheus', async () => {
    const operation = 'test_database_query';
    const duration = 150;

    // 执行带监控的数据库操作
    await performanceMonitor.recordDatabaseQuery(operation, duration, {
      provider: 'test',
      success: true,
    });

    // 验证存储写入
    const storageData = await performanceMonitor.getStorageMetrics();
    expect(storageData.operations.find(op => op.name === operation)).toBeDefined();

    // 验证 Prometheus 写入
    const prometheusData = await metricsRegistry.getMetrics();
    expect(prometheusData).toContain('database_query_duration_ms');
    expect(prometheusData).toContain('database_operations_total');
  });
});
```

3. **E2E 健康检查**：
```typescript
// test/jest/e2e/monitoring/metrics-health.e2e.test.ts
describe('监控指标健康检查 E2E', () => {
  it('GET /monitoring/metrics-health 应该验证系统一致性', async () => {
    const response = await request(app.getHttpServer())
      .get('/api/v1/monitoring/metrics-health')
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(200);

    expect(response.body.data).toMatchObject({
      singleInstance: true,
      registryConsistency: true,
      instanceInfo: {
        metricsCount: expect.any(Number),
        defaultMetricsEnabled: true,
      },
    });
  });
});
```

## 5. 兼容性与不改契约策略

- 不改对外接口：`/monitoring/performance`、`/monitoring/database` 等返回 DTO 不变，仅更换数据来源。
- 不引入新技术栈：统一于既有 `prom-client` 与 Nest DI。
- 保持功能等价：迁移期间双写，任一通道异常均不影响对外查询。

## 6. 增强测试覆盖与验证策略

### 6.1 多层级测试架构

**单元测试层（95% 覆盖目标）**：
```typescript
// test/jest/unit/monitoring/feature-flag-integration.service.spec.ts
describe('FeatureFlag 集成测试', () => {
  let service: FeatureFlagIntegrationService;
  let mockFeatureFlags: jest.Mocked<FeatureFlags>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        FeatureFlagIntegrationService,
        {
          provide: FeatureFlags,
          useValue: {
            isEnabled: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<FeatureFlagIntegrationService>(FeatureFlagIntegrationService);
    mockFeatureFlags = module.get(FeatureFlags);
  });

  describe('双写模式控制', () => {
    it('应该根据 feature flag 控制双写行为', async () => {
      mockFeatureFlags.isEnabled.mockResolvedValue(true);
      
      const result = await service.shouldEnableDualWrite();
      expect(result).toBe(true);
      expect(mockFeatureFlags.isEnabled).toHaveBeenCalledWith('metrics.dual_write_mode');
    });

    it('应该在 feature flag 禁用时仅使用旧系统', async () => {
      mockFeatureFlags.isEnabled.mockResolvedValue(false);
      
      const result = await service.shouldEnableDualWrite();
      expect(result).toBe(false);
    });
  });

  describe('渐进式迁移控制', () => {
    it('应该支持百分比控制的灰度发布', async () => {
      mockFeatureFlags.isEnabled
        .mockResolvedValueOnce(true) // dual_write_mode
        .mockResolvedValueOnce(false); // prometheus_primary (50% rollout)

      const result = await service.getDataSourceStrategy();
      expect(result).toEqual({
        dualWrite: true,
        primarySource: 'storage',
        fallbackEnabled: true,
      });
    });
  });
});
```

**集成测试层（端到端数据流）**：
```typescript
// test/jest/integration/monitoring/metrics-migration-flow.integration.test.ts
describe('指标迁移流程集成测试', () => {
  let app: TestingModule;
  let metricsRegistry: MetricsRegistryService;
  let performanceMonitor: PerformanceMonitorService;
  let featureFlags: FeatureFlags;

  beforeAll(async () => {
    app = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    metricsRegistry = app.get(MetricsRegistryService);
    performanceMonitor = app.get(PerformanceMonitorService);
    featureFlags = app.get(FeatureFlags);
  });

  describe('Phase 1: 双写验证', () => {
    beforeEach(async () => {
      // 启用双写模式
      jest.spyOn(featureFlags, 'isEnabled').mockImplementation((flag: string) => {
        const flags = {
          'metrics.dual_write_mode': true,
          'metrics.prometheus_write': true,
          'metrics.prometheus_primary': false,
        };
        return Promise.resolve(flags[flag] || false);
      });
    });

    it('应该同时写入存储和 Prometheus', async () => {
      const testOperation = `integration_test_${Date.now()}`;
      const testDuration = 125;

      // 执行监控记录
      await performanceMonitor.recordDatabaseQuery(testOperation, testDuration, {
        provider: 'test',
        success: true,
      });

      // 验证存储写入
      const storageMetrics = await performanceMonitor.getStorageMetrics({
        operation: testOperation,
        timeRange: '1h',
      });
      expect(storageMetrics.operations).toContain(
        expect.objectContaining({ operation: testOperation })
      );

      // 验证 Prometheus 写入
      const prometheusText = await metricsRegistry.getMetrics();
      expect(prometheusText).toContain('database_query_duration_ms');
      expect(prometheusText).toContain(`operation="${testOperation}"`);
    });

    it('应该保持数据一致性', async () => {
      const operations = ['select', 'insert', 'update'];
      const promises = operations.map(op => 
        performanceMonitor.recordDatabaseQuery(op, Math.random() * 100 + 50, {
          provider: 'test',
          success: Math.random() > 0.1,
        })
      );

      await Promise.all(promises);

      // 等待指标处理
      await new Promise(resolve => setTimeout(resolve, 500));

      const storageData = await performanceMonitor.getStorageMetrics();
      const prometheusText = await metricsRegistry.getMetrics();
      
      // 验证操作计数一致性
      operations.forEach(op => {
        const storageCount = storageData.operations.filter(item => item.operation === op).length;
        const prometheusMatch = prometheusText.match(new RegExp(`database_operations_total{.*operation="${op}".*} (\\d+)`));
        const prometheusCount = prometheusMatch ? parseInt(prometheusMatch[1]) : 0;
        
        expect(prometheusCount).toBeGreaterThanOrEqual(storageCount * 0.95); // 允许 5% 的异步延迟容差
      });
    });
  });

  describe('Phase 2: 主数据源切换', () => {
    beforeEach(async () => {
      jest.spyOn(featureFlags, 'isEnabled').mockImplementation((flag: string) => {
        const flags = {
          'metrics.dual_write_mode': true,
          'metrics.prometheus_write': true,
          'metrics.prometheus_primary': true, // 切换到 Prometheus 为主
        };
        return Promise.resolve(flags[flag] || false);
      });
    });

    it('应该优先从 Prometheus 读取数据', async () => {
      const controller = app.get(MonitoringController);
      
      const performanceData = await controller.getPerformanceMetrics({
        timeRange: '1h',
      } as PerformanceQueryDto);

      expect(performanceData.dataSource).toBe('prometheus');
      expect(performanceData.lastUpdated).toBeInstanceOf(Date);
    });

    it('Prometheus 故障时应该自动降级', async () => {
      // 模拟 Prometheus 获取失败
      jest.spyOn(metricsRegistry, 'getMetrics').mockRejectedValueOnce(new Error('Registry unavailable'));

      const controller = app.get(MonitoringController);
      const performanceData = await controller.getPerformanceMetrics({
        timeRange: '1h',
      } as PerformanceQueryDto);

      expect(performanceData.dataSource).toBe('storage'); // 应该回退到存储
    });
  });

  describe('Phase 3: 完全迁移验证', () => {
    beforeEach(async () => {
      jest.spyOn(featureFlags, 'isEnabled').mockImplementation((flag: string) => {
        const flags = {
          'metrics.dual_write_mode': false, // 关闭双写
          'metrics.prometheus_write': true,
          'metrics.prometheus_primary': true,
          'metrics.legacy_storage_disabled': true, // 完全禁用旧存储
        };
        return Promise.resolve(flags[flag] || false);
      });
    });

    it('应该仅使用 Prometheus 系统', async () => {
      const testOperation = `final_test_${Date.now()}`;
      
      await performanceMonitor.recordDatabaseQuery(testOperation, 100, {
        provider: 'test',
        success: true,
      });

      // 验证只写入 Prometheus
      const prometheusText = await metricsRegistry.getMetrics();
      expect(prometheusText).toContain(`operation="${testOperation}"`);

      // 验证不写入旧存储（如果有检查机制的话）
      // Note: 这里需要根据实际的存储检查机制调整
    });
  });
});
```

### 6.2 性能基准测试

**负载测试脚本**：
```typescript
// test/jest/performance/monitoring-performance.perf.test.ts
describe('监控系统性能测试', () => {
  describe('指标写入性能', () => {
    it('单线程下每秒应支持 >1000 次指标写入', async () => {
      const iterations = 1000;
      const startTime = Date.now();

      const promises = Array.from({ length: iterations }, (_, i) => 
        Metrics.inc(metricsRegistry, 'performance_test_counter', {
          test_id: `${i}`,
          batch: 'single_thread',
        })
      );

      await Promise.all(promises);
      
      const duration = Date.now() - startTime;
      const throughput = (iterations / duration) * 1000; // ops/sec

      expect(throughput).toBeGreaterThan(1000);
      expect(duration).toBeLessThan(1000); // 应在 1 秒内完成
    });

    it('并发写入不应出现数据丢失', async () => {
      const concurrency = 10;
      const iterationsPerThread = 100;
      const expectedTotal = concurrency * iterationsPerThread;

      const batches = Array.from({ length: concurrency }, (_, batchId) =>
        Array.from({ length: iterationsPerThread }, (_, i) =>
          Metrics.inc(metricsRegistry, 'concurrency_test_counter', {
            batch_id: `${batchId}`,
            item_id: `${i}`,
          })
        )
      );

      await Promise.all(batches.flat());

      // 等待所有指标处理完成
      await new Promise(resolve => setTimeout(resolve, 1000));

      const metricsText = await metricsRegistry.getMetrics();
      const matches = metricsText.match(/concurrency_test_counter\{.*?\} (\d+)/g);
      
      const actualTotal = matches?.reduce((sum, match) => {
        const value = parseInt(match.split(' ')[1]);
        return sum + value;
      }, 0) || 0;

      expect(actualTotal).toBe(expectedTotal);
    });
  });

  describe('数据读取性能', () => {
    it('指标导出应在 100ms 内完成', async () => {
      const startTime = Date.now();
      const metricsText = await metricsRegistry.getMetrics();
      const duration = Date.now() - startTime;

      expect(duration).toBeLessThan(100);
      expect(metricsText.length).toBeGreaterThan(0);
    });

    it('大量指标下的导出性能', async () => {
      // 预先写入大量指标
      const metricNames = Array.from({ length: 50 }, (_, i) => `bulk_test_metric_${i}`);
      const labelCombinations = Array.from({ length: 20 }, (_, i) => ({
        service: `service_${i % 5}`,
        environment: i < 10 ? 'prod' : 'test',
        region: `region_${i % 3}`,
      }));

      const writePromises = metricNames.flatMap(metricName =>
        labelCombinations.map(labels =>
          Metrics.inc(metricsRegistry, metricName, labels, Math.floor(Math.random() * 100))
        )
      );

      await Promise.all(writePromises);

      // 测试导出性能
      const startTime = Date.now();
      const metricsText = await metricsRegistry.getMetrics();
      const duration = Date.now() - startTime;

      expect(duration).toBeLessThan(500); // 在大量指标下应保持在 500ms 内
      expect(metricsText.split('\n').length).toBeGreaterThan(metricNames.length * labelCombinations.length);
    });
  });
});
```

### 6.3 故障恢复测试

**容错性验证**：
```typescript
// test/jest/integration/monitoring/fault-tolerance.integration.test.ts
describe('监控系统容错性测试', () => {
  describe('Redis 连接故障', () => {
    it('Redis 不可用时应该降级到内存指标', async () => {
      // 模拟 Redis 连接失败
      const originalRedis = (metricsRegistry as any).redis;
      (metricsRegistry as any).redis = null;

      try {
        await Metrics.inc(metricsRegistry, 'fault_tolerance_test', { scenario: 'redis_down' });
        
        // 应该仍能导出指标（使用内存后备）
        const metricsText = await metricsRegistry.getMetrics();
        expect(metricsText).toContain('fault_tolerance_test');
      } finally {
        // 恢复 Redis 连接
        (metricsRegistry as any).redis = originalRedis;
      }
    });
  });

  describe('MongoDB 连接故障', () => {
    it('存储层故障时 Prometheus 应继续工作', async () => {
      // 启用双写模式
      jest.spyOn(featureFlags, 'isEnabled').mockImplementation((flag: string) => {
        return Promise.resolve(flag === 'metrics.dual_write_mode' || flag === 'metrics.prometheus_write');
      });

      // 模拟 MongoDB 连接失败
      jest.spyOn(performanceMonitor, 'recordToStorage').mockRejectedValue(new Error('MongoDB connection failed'));

      await expect(
        performanceMonitor.recordDatabaseQuery('fault_test', 100, { provider: 'test' })
      ).resolves.not.toThrow();

      // Prometheus 指标应该仍然可用
      const metricsText = await metricsRegistry.getMetrics();
      expect(metricsText).toContain('database_operations_total');
    });
  });

  describe('部分服务故障', () => {
    it('装饰器异常不应影响业务逻辑', async () => {
      class TestService {
        constructor(public metricsRegistry: MetricsRegistryService) {}

        @PrometheusPerformance('test_method')
        async businessMethod(shouldFail: boolean): Promise<string> {
          if (shouldFail) {
            throw new Error('Business logic error');
          }
          return 'success';
        }
      }

      const testService = new TestService(metricsRegistry);

      // 正常情况
      const result = await testService.businessMethod(false);
      expect(result).toBe('success');

      // 业务逻辑异常时装饰器应该不影响异常传播
      await expect(testService.businessMethod(true)).rejects.toThrow('Business logic error');

      // 验证错误指标被记录
      const metricsText = await metricsRegistry.getMetrics();
      expect(metricsText).toContain('test_method_total{');
    });
  });
});
```

### 6.4 数据一致性验证

**一致性检查工具**：
```typescript
// src/monitoring/utils/consistency-validator.util.ts
export class ConsistencyValidatorUtil {
  constructor(
    private readonly metricsRegistry: MetricsRegistryService,
    private readonly performanceMonitor: PerformanceMonitorService,
  ) {}

  async validateConsistency(timeRange: string = '1h'): Promise<ConsistencyReport> {
    const [prometheusData, storageData] = await Promise.all([
      this.getPrometheusAggregates(),
      this.getStorageAggregates(timeRange),
    ]);

    const report: ConsistencyReport = {
      timestamp: new Date(),
      timeRange,
      metrics: [],
      overallConsistency: 0,
      recommendations: [],
    };

    // 对比关键指标
    const keyMetrics = ['database_operations_total', 'http_requests_total', 'cache_operations_total'];
    
    for (const metricName of keyMetrics) {
      const prometheusValue = this.extractMetricValue(prometheusData, metricName);
      const storageValue = this.extractStorageValue(storageData, metricName);
      
      const consistency = this.calculateConsistency(prometheusValue, storageValue);
      
      report.metrics.push({
        name: metricName,
        prometheusValue,
        storageValue,
        consistency,
        acceptable: consistency >= 0.95, // 95% 一致性阈值
      });
    }

    report.overallConsistency = report.metrics.reduce((sum, m) => sum + m.consistency, 0) / report.metrics.length;

    // 生成建议
    if (report.overallConsistency < 0.95) {
      report.recommendations.push('数据一致性低于阈值，建议检查双写配置');
    }
    if (report.overallConsistency < 0.85) {
      report.recommendations.push('严重不一致，建议暂停迁移并排查问题');
    }

    return report;
  }

  private calculateConsistency(prometheusValue: number, storageValue: number): number {
    if (prometheusValue === 0 && storageValue === 0) return 1;
    if (prometheusValue === 0 || storageValue === 0) return 0;
    
    const diff = Math.abs(prometheusValue - storageValue);
    const avg = (prometheusValue + storageValue) / 2;
    
    return Math.max(0, 1 - (diff / avg));
  }
}

interface ConsistencyReport {
  timestamp: Date;
  timeRange: string;
  metrics: MetricConsistency[];
  overallConsistency: number;
  recommendations: string[];
}

interface MetricConsistency {
  name: string;
  prometheusValue: number;
  storageValue: number;
  consistency: number;
  acceptable: boolean;
}
```

## 7. 增强监控指标与性能评估

### 7.1 关键性能指标 (KPIs)

**系统性能监控**：
```typescript
// src/monitoring/services/migration-metrics.service.ts
@Injectable()
export class MigrationMetricsService {
  private readonly logger = createLogger(MigrationMetricsService.name);

  constructor(
    private readonly metricsRegistry: MetricsRegistryService,
    private readonly consistencyValidator: ConsistencyValidatorUtil,
  ) {}

  async collectMigrationMetrics(): Promise<MigrationMetricsDto> {
    const startTime = Date.now();

    // 1. 性能指标收集
    const performanceMetrics = await this.collectPerformanceMetrics();
    
    // 2. 一致性检查
    const consistencyReport = await this.consistencyValidator.validateConsistency('1h');
    
    // 3. 资源使用情况
    const resourceUsage = await this.collectResourceMetrics();
    
    // 4. 错误率统计
    const errorMetrics = await this.collectErrorMetrics();

    const collectionTime = Date.now() - startTime;

    return {
      timestamp: new Date(),
      collectionTimeMs: collectionTime,
      performance: performanceMetrics,
      consistency: consistencyReport,
      resources: resourceUsage,
      errors: errorMetrics,
      overallHealth: this.calculateOverallHealth(performanceMetrics, consistencyReport, errorMetrics),
    };
  }

  private async collectPerformanceMetrics(): Promise<PerformanceMetricsSnapshot> {
    const metricsText = await this.metricsRegistry.getMetrics();
    const metrics = PrometheusParserUtil.parseMetrics(metricsText);

    return {
      // 写入性能
      metricsWriteRate: this.calculateRate(metrics, 'metrics_write_operations_total'),
      avgWriteLatency: this.extractHistogramAvg(metrics, 'metrics_write_duration_ms'),
      
      // 读取性能
      metricsReadRate: this.calculateRate(metrics, 'metrics_read_operations_total'),
      avgReadLatency: this.extractHistogramAvg(metrics, 'metrics_read_duration_ms'),
      
      // 缓存性能
      cacheHitRate: this.calculateHitRate(metrics, 'metrics_cache_hits_total', 'metrics_cache_requests_total'),
      
      // 导出性能
      exportLatency: this.extractHistogramAvg(metrics, 'metrics_export_duration_ms'),
      exportSize: this.extractGauge(metrics, 'metrics_export_size_bytes'),
      
      // 批量处理性能
      batchProcessingRate: this.calculateRate(metrics, 'metrics_batch_processed_total'),
      avgBatchSize: this.extractHistogramAvg(metrics, 'metrics_batch_size'),
    };
  }

  private async collectResourceMetrics(): Promise<ResourceUsageSnapshot> {
    const metricsText = await this.metricsRegistry.getMetrics();
    const metrics = PrometheusParserUtil.parseMetrics(metricsText);

    return {
      // 内存使用
      heapUsedMB: this.extractGauge(metrics, 'nodejs_heap_size_used_bytes') / 1024 / 1024,
      heapTotalMB: this.extractGauge(metrics, 'nodejs_heap_size_total_bytes') / 1024 / 1024,
      heapUtilization: this.extractGauge(metrics, 'nodejs_heap_size_used_bytes') / 
                       this.extractGauge(metrics, 'nodejs_heap_size_total_bytes'),
      
      // CPU 使用率
      cpuUsagePercent: this.extractGauge(metrics, 'process_cpu_user_seconds_total') * 100,
      
      // 网络连接
      activeConnections: this.extractGauge(metrics, 'nodejs_active_handles_total'),
      
      // 数据库连接
      dbConnectionsActive: this.extractGauge(metrics, 'mongodb_connections_active'),
      dbConnectionsAvailable: this.extractGauge(metrics, 'mongodb_connections_available'),
      
      // Redis 连接
      redisConnectionsActive: this.extractGauge(metrics, 'redis_connections_active'),
      
      // 指标存储占用
      prometheusMetricsCount: this.extractGauge(metrics, 'prometheus_metrics_total'),
      metricsMemoryUsageMB: this.extractGauge(metrics, 'metrics_memory_usage_bytes') / 1024 / 1024,
    };
  }

  private async collectErrorMetrics(): Promise<ErrorMetricsSnapshot> {
    const metricsText = await this.metricsRegistry.getMetrics();
    const metrics = PrometheusParserUtil.parseMetrics(metricsText);

    return {
      // 写入错误
      metricsWriteErrors: this.extractCounter(metrics, 'metrics_write_errors_total'),
      metricsWriteErrorRate: this.calculateErrorRate(metrics, 'metrics_write_errors_total', 'metrics_write_operations_total'),
      
      // 读取错误
      metricsReadErrors: this.extractCounter(metrics, 'metrics_read_errors_total'),
      metricsReadErrorRate: this.calculateErrorRate(metrics, 'metrics_read_errors_total', 'metrics_read_operations_total'),
      
      // 导出错误
      exportErrors: this.extractCounter(metrics, 'metrics_export_errors_total'),
      exportErrorRate: this.calculateErrorRate(metrics, 'metrics_export_errors_total', 'metrics_export_operations_total'),
      
      // 一致性错误
      consistencyFailures: this.extractCounter(metrics, 'metrics_consistency_failures_total'),
      
      // 超时错误
      timeoutErrors: this.extractCounter(metrics, 'metrics_timeout_errors_total'),
      
      // 连接错误
      connectionErrors: this.extractCounter(metrics, 'metrics_connection_errors_total'),
    };
  }

  private calculateOverallHealth(
    performance: PerformanceMetricsSnapshot,
    consistency: ConsistencyReport,
    errors: ErrorMetricsSnapshot,
  ): HealthScore {
    let score = 100;
    const issues: string[] = [];

    // 性能评分 (40%)
    if (performance.avgWriteLatency > 100) {
      score -= 15;
      issues.push('写入延迟过高');
    }
    if (performance.cacheHitRate < 0.8) {
      score -= 10;
      issues.push('缓存命中率低');
    }
    if (performance.exportLatency > 500) {
      score -= 15;
      issues.push('导出性能差');
    }

    // 一致性评分 (35%)
    if (consistency.overallConsistency < 0.95) {
      score -= 20;
      issues.push('数据一致性问题');
    }
    if (consistency.overallConsistency < 0.85) {
      score -= 15;
      issues.push('严重一致性问题');
    }

    // 错误率评分 (25%)
    if (errors.metricsWriteErrorRate > 0.01) {
      score -= 15;
      issues.push('写入错误率高');
    }
    if (errors.exportErrorRate > 0.005) {
      score -= 10;
      issues.push('导出错误率高');
    }

    return {
      score: Math.max(0, score),
      level: this.getHealthLevel(score),
      issues,
      recommendations: this.generateRecommendations(score, issues),
    };
  }

  private getHealthLevel(score: number): 'excellent' | 'good' | 'fair' | 'poor' | 'critical' {
    if (score >= 95) return 'excellent';
    if (score >= 85) return 'good';
    if (score >= 70) return 'fair';
    if (score >= 50) return 'poor';
    return 'critical';
  }

  private generateRecommendations(score: number, issues: string[]): string[] {
    const recommendations: string[] = [];

    if (issues.includes('写入延迟过高')) {
      recommendations.push('考虑启用批量写入模式');
      recommendations.push('检查数据库连接池配置');
    }
    if (issues.includes('缓存命中率低')) {
      recommendations.push('调整缓存TTL策略');
      recommendations.push('增加缓存预热机制');
    }
    if (issues.includes('数据一致性问题')) {
      recommendations.push('检查双写配置');
      recommendations.push('增加同步检查点');
    }
    if (score < 70) {
      recommendations.push('建议暂停迁移并排查问题');
    }

    return recommendations;
  }
}

// DTOs
interface MigrationMetricsDto {
  timestamp: Date;
  collectionTimeMs: number;
  performance: PerformanceMetricsSnapshot;
  consistency: ConsistencyReport;
  resources: ResourceUsageSnapshot;
  errors: ErrorMetricsSnapshot;
  overallHealth: HealthScore;
}

interface PerformanceMetricsSnapshot {
  metricsWriteRate: number;
  avgWriteLatency: number;
  metricsReadRate: number;
  avgReadLatency: number;
  cacheHitRate: number;
  exportLatency: number;
  exportSize: number;
  batchProcessingRate: number;
  avgBatchSize: number;
}

interface ResourceUsageSnapshot {
  heapUsedMB: number;
  heapTotalMB: number;
  heapUtilization: number;
  cpuUsagePercent: number;
  activeConnections: number;
  dbConnectionsActive: number;
  dbConnectionsAvailable: number;
  redisConnectionsActive: number;
  prometheusMetricsCount: number;
  metricsMemoryUsageMB: number;
}

interface ErrorMetricsSnapshot {
  metricsWriteErrors: number;
  metricsWriteErrorRate: number;
  metricsReadErrors: number;
  metricsReadErrorRate: number;
  exportErrors: number;
  exportErrorRate: number;
  consistencyFailures: number;
  timeoutErrors: number;
  connectionErrors: number;
}

interface HealthScore {
  score: number;
  level: 'excellent' | 'good' | 'fair' | 'poor' | 'critical';
  issues: string[];
  recommendations: string[];
}
```

### 7.2 实时监控仪表板

**监控端点增强**：
```typescript
// src/monitoring/controller/migration-monitoring.controller.ts
@Controller('monitoring/migration')
export class MigrationMonitoringController {
  constructor(
    private readonly migrationMetrics: MigrationMetricsService,
    private readonly consistencyValidator: ConsistencyValidatorUtil,
  ) {}

  @Get('dashboard')
  @Auth([UserRole.ADMIN])
  async getDashboardData(): Promise<MigrationDashboardDto> {
    const [currentMetrics, trends] = await Promise.all([
      this.migrationMetrics.collectMigrationMetrics(),
      this.getTrendData(),
    ]);

    return {
      current: currentMetrics,
      trends,
      alerts: this.generateAlerts(currentMetrics),
      lastUpdated: new Date(),
    };
  }

  @Get('health')
  @Auth([UserRole.ADMIN])
  async getHealthSummary(): Promise<HealthSummaryDto> {
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    
    return {
      overall: metrics.overallHealth,
      components: {
        performance: this.assessPerformanceHealth(metrics.performance),
        consistency: this.assessConsistencyHealth(metrics.consistency),
        resources: this.assessResourceHealth(metrics.resources),
        errors: this.assessErrorHealth(metrics.errors),
      },
      timestamp: metrics.timestamp,
    };
  }

  @Get('alerts')
  @Auth([UserRole.ADMIN])
  async getActiveAlerts(): Promise<AlertDto[]> {
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    return this.generateAlerts(metrics);
  }

  @Post('consistency-check')
  @Auth([UserRole.ADMIN])
  async performConsistencyCheck(@Body() request: ConsistencyCheckRequestDto): Promise<ConsistencyReport> {
    return this.consistencyValidator.validateConsistency(request.timeRange || '1h');
  }

  private async getTrendData(): Promise<TrendDataDto> {
    // 获取历史趋势数据（简化实现）
    return {
      performanceTrend: [], // 实际实现中从时序数据库获取
      consistencyTrend: [],
      errorTrend: [],
      resourceTrend: [],
    };
  }

  private generateAlerts(metrics: MigrationMetricsDto): AlertDto[] {
    const alerts: AlertDto[] = [];

    // 性能告警
    if (metrics.performance.avgWriteLatency > 200) {
      alerts.push({
        level: 'warning',
        type: 'performance',
        message: `指标写入延迟过高: ${metrics.performance.avgWriteLatency}ms`,
        recommendations: ['检查数据库连接', '考虑启用批量写入'],
      });
    }

    // 一致性告警
    if (metrics.consistency.overallConsistency < 0.9) {
      alerts.push({
        level: 'critical',
        type: 'consistency',
        message: `数据一致性低于阈值: ${(metrics.consistency.overallConsistency * 100).toFixed(1)}%`,
        recommendations: metrics.consistency.recommendations,
      });
    }

    // 资源告警
    if (metrics.resources.heapUtilization > 0.85) {
      alerts.push({
        level: 'warning',
        type: 'resource',
        message: `内存使用率过高: ${(metrics.resources.heapUtilization * 100).toFixed(1)}%`,
        recommendations: ['增加内存分配', '检查内存泄漏'],
      });
    }

    // 错误率告警
    if (metrics.errors.metricsWriteErrorRate > 0.01) {
      alerts.push({
        level: 'error',
        type: 'error',
        message: `指标写入错误率过高: ${(metrics.errors.metricsWriteErrorRate * 100).toFixed(2)}%`,
        recommendations: ['检查连接稳定性', '分析错误日志'],
      });
    }

    return alerts;
  }
}
```

### 7.3 自动化预警系统

**智能预警机制**：
```typescript
// src/monitoring/services/alert-manager.service.ts
@Injectable()
export class AlertManagerService implements OnModuleInit {
  private readonly logger = createLogger(AlertManagerService.name);
  private alertHistory: Map<string, AlertHistoryItem> = new Map();
  private monitoringInterval: NodeJS.Timer | null = null;

  constructor(
    private readonly migrationMetrics: MigrationMetricsService,
    private readonly notificationService: NotificationService, // 假设存在通知服务
  ) {}

  async onModuleInit() {
    // 启动持续监控
    this.startContinuousMonitoring();
  }

  private startContinuousMonitoring() {
    this.monitoringInterval = setInterval(async () => {
      try {
        await this.performHealthCheck();
      } catch (error) {
        this.logger.error('健康检查失败', { error: error.message });
      }
    }, 30000); // 每30秒检查一次
  }

  private async performHealthCheck() {
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    const alerts = this.evaluateAlerts(metrics);

    for (const alert of alerts) {
      await this.processAlert(alert);
    }

    // 清理已解决的告警
    this.cleanupResolvedAlerts(alerts);
  }

  private evaluateAlerts(metrics: MigrationMetricsDto): Alert[] {
    const alerts: Alert[] = [];

    // 定义告警规则
    const rules: AlertRule[] = [
      {
        name: 'high_write_latency',
        condition: () => metrics.performance.avgWriteLatency > 150,
        severity: 'warning',
        message: `写入延迟过高: ${metrics.performance.avgWriteLatency}ms`,
        threshold: 150,
        cooldown: 300000, // 5分钟冷却期
      },
      {
        name: 'low_consistency',
        condition: () => metrics.consistency.overallConsistency < 0.95,
        severity: 'critical',
        message: `数据一致性低: ${(metrics.consistency.overallConsistency * 100).toFixed(1)}%`,
        threshold: 0.95,
        cooldown: 600000, // 10分钟冷却期
      },
      {
        name: 'high_error_rate',
        condition: () => metrics.errors.metricsWriteErrorRate > 0.005,
        severity: 'error',
        message: `错误率过高: ${(metrics.errors.metricsWriteErrorRate * 100).toFixed(2)}%`,
        threshold: 0.005,
        cooldown: 180000, // 3分钟冷却期
      },
      {
        name: 'memory_pressure',
        condition: () => metrics.resources.heapUtilization > 0.9,
        severity: 'warning',
        message: `内存压力过高: ${(metrics.resources.heapUtilization * 100).toFixed(1)}%`,
        threshold: 0.9,
        cooldown: 300000,
      }
    ];

    for (const rule of rules) {
      if (rule.condition()) {
        const alertKey = rule.name;
        const lastAlert = this.alertHistory.get(alertKey);
        
        // 检查冷却期
        if (!lastAlert || (Date.now() - lastAlert.lastFired) > rule.cooldown) {
          alerts.push({
            id: `${rule.name}_${Date.now()}`,
            name: rule.name,
            severity: rule.severity,
            message: rule.message,
            timestamp: new Date(),
            source: 'migration_monitor',
            metadata: {
              currentValue: this.extractCurrentValue(metrics, rule),
              threshold: rule.threshold,
            },
          });
        }
      }
    }

    return alerts;
  }

  private async processAlert(alert: Alert) {
    // 记录告警历史
    this.alertHistory.set(alert.name, {
      lastFired: Date.now(),
      count: (this.alertHistory.get(alert.name)?.count || 0) + 1,
    });

    // 日志记录
    this.logger.warn(`告警触发: ${alert.name}`, {
      severity: alert.severity,
      message: alert.message,
      metadata: alert.metadata,
    });

    // 发送通知（根据严重程度）
    if (alert.severity === 'critical') {
      await this.notificationService.sendCriticalAlert(alert);
    } else if (alert.severity === 'error') {
      await this.notificationService.sendErrorAlert(alert);
    }

    // 自动恢复操作
    await this.attemptAutoRemediation(alert);
  }

  private async attemptAutoRemediation(alert: Alert) {
    switch (alert.name) {
      case 'high_write_latency':
        // 自动启用批量写入模式
        await this.enableBatchWriteMode();
        break;
        
      case 'low_consistency':
        // 触发一致性修复
        await this.triggerConsistencyRepair();
        break;
        
      case 'memory_pressure':
        // 触发垃圾回收
        if (global.gc) {
          global.gc();
        }
        break;
    }
  }

  private async enableBatchWriteMode() {
    // 实现批量写入模式切换逻辑
    this.logger.info('自动启用批量写入模式以改善性能');
  }

  private async triggerConsistencyRepair() {
    // 实现一致性修复逻辑
    this.logger.info('触发数据一致性修复流程');
  }

  onModuleDestroy() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
    }
  }
}

interface AlertRule {
  name: string;
  condition: () => boolean;
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  threshold: number;
  cooldown: number;
}

interface Alert {
  id: string;
  name: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  timestamp: Date;
  source: string;
  metadata: any;
}

interface AlertHistoryItem {
  lastFired: number;
  count: number;
}
```

## 8. 增强风险管控与回滚策略

### 8.1 多层级风险评估矩阵

**风险分类与影响评估**：

| 风险等级 | 风险类型 | 具体风险 | 概率 | 影响 | 缓解策略 | 回滚时间 |
|---------|---------|---------|------|------|---------|---------|
| **Critical** | 数据一致性 | 双写期间数据丢失或不一致 | 中 | 高 | 实时一致性监控 + 自动修复 | < 5分钟 |
| **High** | 性能下降 | 监控系统拖累业务性能 | 中 | 中 | 性能阈值告警 + 自动降级 | < 2分钟 |
| **High** | 系统稳定性 | 新监控组件导致系统崩溃 | 低 | 高 | 健康检查 + 熔断机制 | < 1分钟 |
| **Medium** | 数据质量 | 历史报表数据中断 | 中 | 中 | 数据备份 + 渐进式迁移 | < 10分钟 |
| **Medium** | 运维复杂性 | 双系统增加运维负担 | 高 | 低 | 自动化工具 + 文档完善 | N/A |
| **Low** | 资源消耗 | 内存/CPU占用增加 | 高 | 低 | 资源监控 + 优化配置 | < 30分钟 |

### 8.2 智能回滚决策系统

**自动回滚触发条件**：
```typescript
// src/monitoring/services/rollback-manager.service.ts
@Injectable()
export class RollbackManagerService {
  private readonly logger = createLogger(RollbackManagerService.name);
  private rollbackHistory: Map<string, RollbackRecord> = new Map();

  constructor(
    private readonly migrationMetrics: MigrationMetricsService,
    private readonly featureFlags: FeatureFlags,
    private readonly alertManager: AlertManagerService,
  ) {}

  async evaluateRollbackConditions(): Promise<RollbackDecision> {
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    const decision: RollbackDecision = {
      shouldRollback: false,
      severity: 'info',
      reasons: [],
      actions: [],
      estimatedRecoveryTime: 0,
    };

    // Critical: 数据一致性低于85%
    if (metrics.consistency.overallConsistency < 0.85) {
      decision.shouldRollback = true;
      decision.severity = 'critical';
      decision.reasons.push(`数据一致性严重问题: ${(metrics.consistency.overallConsistency * 100).toFixed(1)}%`);
      decision.actions.push('立即停止双写模式');
      decision.actions.push('恢复到旧监控系统');
      decision.estimatedRecoveryTime = 300; // 5分钟
    }

    // High: 错误率持续超过1%
    if (metrics.errors.metricsWriteErrorRate > 0.01) {
      const errorHistory = await this.getErrorRateHistory();
      if (this.isErrorRateSustained(errorHistory, 0.01, 300000)) { // 持续5分钟
        decision.shouldRollback = true;
        decision.severity = 'high';
        decision.reasons.push(`持续高错误率: ${(metrics.errors.metricsWriteErrorRate * 100).toFixed(2)}%`);
        decision.actions.push('禁用Prometheus写入');
        decision.estimatedRecoveryTime = 120; // 2分钟
      }
    }

    // High: 性能退化超过50%
    const performanceBaseline = await this.getPerformanceBaseline();
    if (metrics.performance.avgWriteLatency > performanceBaseline.writeLatency * 1.5) {
      decision.shouldRollback = true;
      decision.severity = 'high';
      decision.reasons.push(`性能严重退化: ${metrics.performance.avgWriteLatency}ms vs 基线${performanceBaseline.writeLatency}ms`);
      decision.actions.push('切换到单一监控模式');
      decision.estimatedRecoveryTime = 180; // 3分钟
    }

    // Medium: 系统资源压力过大
    if (metrics.resources.heapUtilization > 0.95 && metrics.resources.cpuUsagePercent > 90) {
      decision.shouldRollback = true;
      decision.severity = 'medium';
      decision.reasons.push('系统资源压力过大');
      decision.actions.push('减少监控频率');
      decision.actions.push('启用批量处理模式');
      decision.estimatedRecoveryTime = 60; // 1分钟
    }

    return decision;
  }

  async executeRollback(decision: RollbackDecision): Promise<RollbackResult> {
    const rollbackId = `rollback_${Date.now()}`;
    const startTime = Date.now();

    this.logger.error('执行自动回滚', {
      rollbackId,
      severity: decision.severity,
      reasons: decision.reasons,
    });

    const result: RollbackResult = {
      rollbackId,
      startTime: new Date(),
      actions: [],
      success: true,
      errors: [],
      completionTime: null,
      recoveryValidation: null,
    };

    try {
      // 1. 立即停止新功能
      if (decision.actions.includes('立即停止双写模式')) {
        await this.stopDualWriteMode();
        result.actions.push({ action: 'stop_dual_write', success: true, duration: Date.now() - startTime });
      }

      // 2. 恢复到安全配置
      if (decision.actions.includes('恢复到旧监控系统')) {
        await this.revertToLegacySystem();
        result.actions.push({ action: 'revert_to_legacy', success: true, duration: Date.now() - startTime });
      }

      // 3. 禁用有问题的功能
      if (decision.actions.includes('禁用Prometheus写入')) {
        await this.disablePrometheusWrite();
        result.actions.push({ action: 'disable_prometheus_write', success: true, duration: Date.now() - startTime });
      }

      // 4. 验证恢复状态
      result.recoveryValidation = await this.validateRecovery();
      result.completionTime = new Date();

      // 5. 记录回滚历史
      this.recordRollbackHistory(rollbackId, decision, result);

    } catch (error) {
      result.success = false;
      result.errors.push(error.message);
      this.logger.error('回滚过程中发生错误', { rollbackId, error: error.message });
    }

    return result;
  }

  private async stopDualWriteMode(): Promise<void> {
    await this.featureFlags.setFlag('metrics.dual_write_mode', false);
    this.logger.info('双写模式已停止');
  }

  private async revertToLegacySystem(): Promise<void> {
    await this.featureFlags.setFlag('metrics.prometheus_primary', false);
    await this.featureFlags.setFlag('metrics.legacy_storage_disabled', false);
    this.logger.info('已恢复到旧监控系统');
  }

  private async disablePrometheusWrite(): Promise<void> {
    await this.featureFlags.setFlag('metrics.prometheus_write', false);
    this.logger.info('Prometheus写入已禁用');
  }

  private async validateRecovery(): Promise<RecoveryValidationResult> {
    // 等待系统稳定
    await new Promise(resolve => setTimeout(resolve, 30000));

    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    
    return {
      systemStable: metrics.errors.metricsWriteErrorRate < 0.001,
      performanceRecovered: metrics.performance.avgWriteLatency < 100,
      consistencyRestored: metrics.consistency.overallConsistency > 0.98,
      resourcePressureRelieved: metrics.resources.heapUtilization < 0.8,
      validationTime: new Date(),
    };
  }
}

// 接口定义
interface RollbackDecision {
  shouldRollback: boolean;
  severity: 'info' | 'warning' | 'high' | 'critical';
  reasons: string[];
  actions: string[];
  estimatedRecoveryTime: number; // 秒
}

interface RollbackResult {
  rollbackId: string;
  startTime: Date;
  actions: RollbackActionResult[];
  success: boolean;
  errors: string[];
  completionTime: Date | null;
  recoveryValidation: RecoveryValidationResult | null;
}

interface RollbackActionResult {
  action: string;
  success: boolean;
  duration: number;
  error?: string;
}

interface RecoveryValidationResult {
  systemStable: boolean;
  performanceRecovered: boolean;
  consistencyRestored: boolean;
  resourcePressureRelieved: boolean;
  validationTime: Date;
}
```

### 8.3 渐进式迁移控制

**Feature Flag 驱动的安全迁移**：
```typescript
// src/monitoring/services/migration-controller.service.ts
@Injectable()
export class MigrationControllerService implements OnModuleInit {
  private readonly logger = createLogger(MigrationControllerService.name);
  private migrationState: MigrationState = 'not_started';
  private phaseStartTimes: Map<string, number> = new Map();

  constructor(
    private readonly featureFlags: FeatureFlags,
    private readonly migrationMetrics: MigrationMetricsService,
    private readonly rollbackManager: RollbackManagerService,
  ) {}

  async onModuleInit() {
    // 启动迁移状态监控
    this.startMigrationMonitoring();
  }

  async getCurrentPhase(): Promise<MigrationPhaseStatus> {
    const flags = await this.getAllMigrationFlags();
    
    if (!flags.dualWriteEnabled) {
      return { phase: 'phase_0', status: 'not_started', description: '迁移未开始' };
    } else if (flags.dualWriteEnabled && !flags.prometheusAsPrimary) {
      return { phase: 'phase_1', status: 'in_progress', description: '双写模式运行中' };
    } else if (flags.prometheusAsPrimary && !flags.legacyDisabled) {
      return { phase: 'phase_2', status: 'in_progress', description: 'Prometheus为主数据源' };
    } else if (flags.legacyDisabled) {
      return { phase: 'phase_3', status: 'completed', description: '完全迁移到Prometheus' };
    }

    return { phase: 'unknown', status: 'error', description: '未知迁移状态' };
  }

  async advanceToNextPhase(): Promise<PhaseTransitionResult> {
    const currentPhase = await this.getCurrentPhase();
    const metrics = await this.migrationMetrics.collectMigrationMetrics();
    
    // 检查当前阶段是否稳定
    const stabilityCheck = await this.validatePhaseStability(currentPhase.phase, metrics);
    if (!stabilityCheck.stable) {
      return {
        success: false,
        fromPhase: currentPhase.phase,
        toPhase: currentPhase.phase,
        reason: `当前阶段不稳定: ${stabilityCheck.issues.join(', ')}`,
        recommendation: '等待系统稳定后再进行下一阶段',
      };
    }

    switch (currentPhase.phase) {
      case 'phase_0':
        return this.transitionToPhase1();
      case 'phase_1':
        return this.transitionToPhase2(metrics);
      case 'phase_2':
        return this.transitionToPhase3(metrics);
      default:
        return {
          success: false,
          fromPhase: currentPhase.phase,
          toPhase: currentPhase.phase,
          reason: '无法确定下一阶段',
        };
    }
  }

  private async transitionToPhase1(): Promise<PhaseTransitionResult> {
    try {
      // 启用双写模式
      await this.featureFlags.setFlag('metrics.dual_write_mode', true);
      await this.featureFlags.setFlag('metrics.prometheus_write', true);
      
      this.phaseStartTimes.set('phase_1', Date.now());
      this.logger.info('已进入Phase 1: 双写模式');

      return {
        success: true,
        fromPhase: 'phase_0',
        toPhase: 'phase_1',
        actions: ['启用双写模式', '启用Prometheus写入'],
        nextReviewTime: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24小时后评估
      };
    } catch (error) {
      return { success: false, fromPhase: 'phase_0', toPhase: 'phase_0', reason: error.message };
    }
  }

  private async transitionToPhase2(metrics: MigrationMetricsDto): Promise<PhaseTransitionResult> {
    // 检查双写模式运行时间和稳定性
    const phase1StartTime = this.phaseStartTimes.get('phase_1') || 0;
    const phase1Duration = Date.now() - phase1StartTime;
    
    if (phase1Duration < 48 * 60 * 60 * 1000) { // 至少运行48小时
      return {
        success: false,
        fromPhase: 'phase_1',
        toPhase: 'phase_1',
        reason: `双写模式运行时间不足48小时 (当前: ${Math.round(phase1Duration / (60 * 60 * 1000))}小时)`,
        recommendation: '继续观察双写模式稳定性',
      };
    }

    if (metrics.consistency.overallConsistency < 0.98) {
      return {
        success: false,
        fromPhase: 'phase_1',
        toPhase: 'phase_1',
        reason: `数据一致性不足98% (当前: ${(metrics.consistency.overallConsistency * 100).toFixed(1)}%)`,
        recommendation: '修复数据一致性问题后再进行切换',
      };
    }

    try {
      // 切换到Prometheus为主数据源
      await this.featureFlags.setFlag('metrics.prometheus_primary', true);
      
      this.phaseStartTimes.set('phase_2', Date.now());
      this.logger.info('已进入Phase 2: Prometheus为主数据源');

      return {
        success: true,
        fromPhase: 'phase_1',
        toPhase: 'phase_2',
        actions: ['切换Prometheus为主数据源'],
        nextReviewTime: new Date(Date.now() + 72 * 60 * 60 * 1000), // 72小时后评估
      };
    } catch (error) {
      return { success: false, fromPhase: 'phase_1', toPhase: 'phase_1', reason: error.message };
    }
  }

  private async transitionToPhase3(metrics: MigrationMetricsDto): Promise<PhaseTransitionResult> {
    // 严格的最终迁移条件检查
    const phase2StartTime = this.phaseStartTimes.get('phase_2') || 0;
    const phase2Duration = Date.now() - phase2StartTime;
    
    if (phase2Duration < 72 * 60 * 60 * 1000) { // 至少运行72小时
      return {
        success: false,
        fromPhase: 'phase_2',
        toPhase: 'phase_2',
        reason: `Prometheus主模式运行时间不足72小时`,
      };
    }

    const requiredConditions = [
      { condition: metrics.consistency.overallConsistency >= 0.99, name: '数据一致性 >= 99%' },
      { condition: metrics.errors.metricsWriteErrorRate < 0.001, name: '错误率 < 0.1%' },
      { condition: metrics.performance.avgWriteLatency < 50, name: '写入延迟 < 50ms' },
      { condition: metrics.overallHealth.score >= 95, name: '总体健康分数 >= 95' },
    ];

    const failedConditions = requiredConditions.filter(c => !c.condition);
    if (failedConditions.length > 0) {
      return {
        success: false,
        fromPhase: 'phase_2',
        toPhase: 'phase_2',
        reason: `未满足最终迁移条件: ${failedConditions.map(c => c.name).join(', ')}`,
        recommendation: '继续优化系统性能和稳定性',
      };
    }

    try {
      // 完全禁用旧系统
      await this.featureFlags.setFlag('metrics.legacy_storage_disabled', true);
      await this.featureFlags.setFlag('metrics.dual_write_mode', false);
      
      this.phaseStartTimes.set('phase_3', Date.now());
      this.logger.info('已进入Phase 3: 完全迁移到Prometheus');

      return {
        success: true,
        fromPhase: 'phase_2',
        toPhase: 'phase_3',
        actions: ['禁用旧存储系统', '关闭双写模式'],
        migrationCompleted: true,
      };
    } catch (error) {
      return { success: false, fromPhase: 'phase_2', toPhase: 'phase_2', reason: error.message };
    }
  }

  private async startMigrationMonitoring() {
    setInterval(async () => {
      try {
        const rollbackDecision = await this.rollbackManager.evaluateRollbackConditions();
        if (rollbackDecision.shouldRollback) {
          this.logger.warn('自动回滚条件触发', rollbackDecision);
          await this.rollbackManager.executeRollback(rollbackDecision);
        }
      } catch (error) {
        this.logger.error('迁移监控失败', { error: error.message });
      }
    }, 60000); // 每分钟检查一次
  }
}

// 接口定义
type MigrationState = 'not_started' | 'phase_1' | 'phase_2' | 'phase_3' | 'completed' | 'rolled_back';

interface MigrationPhaseStatus {
  phase: string;
  status: 'not_started' | 'in_progress' | 'completed' | 'error';
  description: string;
}

interface PhaseTransitionResult {
  success: boolean;
  fromPhase: string;
  toPhase: string;
  reason?: string;
  actions?: string[];
  recommendation?: string;
  nextReviewTime?: Date;
  migrationCompleted?: boolean;
}
```

### 8.4 生产就绪检查清单

**部署前验证清单**：
```typescript
// src/monitoring/services/production-readiness.service.ts
@Injectable()
export class ProductionReadinessService {
  private readonly logger = createLogger(ProductionReadinessService.name);

  async performReadinessCheck(): Promise<ProductionReadinessReport> {
    const report: ProductionReadinessReport = {
      timestamp: new Date(),
      overallReady: false,
      categories: [],
      criticalIssues: [],
      recommendations: [],
    };

    const categories = [
      await this.checkArchitectureReadiness(),
      await this.checkPerformanceReadiness(),
      await this.checkSecurityReadiness(),
      await this.checkMonitoringReadiness(),
      await this.checkOperationalReadiness(),
    ];

    report.categories = categories;
    report.overallReady = categories.every(c => c.ready);
    report.criticalIssues = categories.flatMap(c => c.criticalIssues);
    report.recommendations = categories.flatMap(c => c.recommendations);

    return report;
  }

  private async checkArchitectureReadiness(): Promise<ReadinessCategory> {
    const checks = [
      { name: '单例MetricsRegistryService', check: () => this.validateSingletonRegistry() },
      { name: '全局状态消除', check: () => this.validateNoGlobalState() },
      { name: '循环依赖检查', check: () => this.validateNoCyclicDependencies() },
      { name: '模块边界清晰', check: () => this.validateModuleBoundaries() },
    ];

    const results = await Promise.allSettled(checks.map(c => c.check()));
    const passed = results.filter(r => r.status === 'fulfilled').length;

    return {
      name: '架构设计',
      ready: passed === checks.length,
      passedChecks: passed,
      totalChecks: checks.length,
      criticalIssues: results
        .filter((r, i) => r.status === 'rejected')
        .map((r, i) => `${checks[i].name}: ${r.reason}`),
      recommendations: passed < checks.length ? ['修复架构设计问题后再部署'] : [],
    };
  }

  private async checkPerformanceReadiness(): Promise<ReadinessCategory> {
    const metrics = await this.collectCurrentMetrics();
    const issues = [];
    const recommendations = [];

    if (metrics.avgWriteLatency > 100) {
      issues.push(`写入延迟过高: ${metrics.avgWriteLatency}ms`);
      recommendations.push('优化写入性能或启用批量模式');
    }

    if (metrics.exportLatency > 500) {
      issues.push(`导出延迟过高: ${metrics.exportLatency}ms`);
      recommendations.push('优化指标导出逻辑');
    }

    if (metrics.cacheHitRate < 0.7) {
      issues.push(`缓存命中率低: ${(metrics.cacheHitRate * 100).toFixed(1)}%`);
      recommendations.push('调整缓存策略');
    }

    return {
      name: '性能指标',
      ready: issues.length === 0,
      passedChecks: 3 - issues.length,
      totalChecks: 3,
      criticalIssues: issues,
      recommendations,
    };
  }

  private async checkSecurityReadiness(): Promise<ReadinessCategory> {
    // 安全检查逻辑
    return {
      name: '安全配置',
      ready: true,
      passedChecks: 4,
      totalChecks: 4,
      criticalIssues: [],
      recommendations: [],
    };
  }

  private async checkMonitoringReadiness(): Promise<ReadinessCategory> {
    // 监控系统检查逻辑
    return {
      name: '监控系统',
      ready: true,
      passedChecks: 5,
      totalChecks: 5,
      criticalIssues: [],
      recommendations: [],
    };
  }

  private async checkOperationalReadiness(): Promise<ReadinessCategory> {
    // 运维准备检查逻辑
    return {
      name: '运维准备',
      ready: true,
      passedChecks: 6,
      totalChecks: 6,
      criticalIssues: [],
      recommendations: [],
    };
  }
}

interface ProductionReadinessReport {
  timestamp: Date;
  overallReady: boolean;
  categories: ReadinessCategory[];
  criticalIssues: string[];
  recommendations: string[];
}

interface ReadinessCategory {
  name: string;
  ready: boolean;
  passedChecks: number;
  totalChecks: number;
  criticalIssues: string[];
  recommendations: string[];
}
```

## 9. 分阶段实施路线图

### 9.1 Sprint 规划与里程碑

**Sprint 1 (第1周) - 基础设施修复**：
- ✅ 任务 A1：修复 `MetricsRegistryService` 双实例问题
- ✅ 任务 A2：实施实例一致性验证
- ✅ 任务 A3：`PerformanceMonitorService` 双写适配层
- 🎯 **里程碑**：基础架构稳定，双写机制就绪

**Sprint 2 (第2-3周) - 渐进式迁移**：
- ✅ 任务 B1：控制器智能数据源切换
- ✅ 任务 B2：装饰器DI标准化改造  
- ✅ 任务 B3：Prometheus指标解析工具
- 🎯 **里程碑**：双系统并行运行，数据一致性>95%

**Sprint 3 (第4周) - 完整迁移**：
- ✅ 任务 C1：移除全局状态依赖
- ✅ 任务 C2：清理冗余模块引用
- ✅ 任务 C3：生产环境验证
- 🎯 **里程碑**：完全迁移到Prometheus，性能提升20%

**Sprint 4 (第5周) - 监控增强**：
- ✅ 任务 D1：实时监控仪表板
- ✅ 任务 D2：自动预警系统
- ✅ 任务 D3：性能基准建立
- 🎯 **里程碑**：监控体系完善，运维自动化

### 9.2 关键决策节点

1. **Phase 0 → Phase 1**: 双实例问题解决确认
2. **Phase 1 → Phase 2**: 数据一致性达到98%+，运行稳定48小时
3. **Phase 2 → Phase 3**: 系统健康分数95+，无关键告警72小时
4. **最终验收**: 性能提升确认，回滚能力验证

### 9.3 成功标准与验收条件

**技术指标**：
- 数据一致性 ≥ 99%
- 写入延迟 < 50ms (P95)
- 导出延迟 < 200ms (P99)
- 错误率 < 0.1%
- 系统可用性 ≥ 99.9%

**业务指标**：
- 监控数据完整性 100%
- 历史数据无丢失
- API响应契约不变
- 运维操作无增加

——

**🎯 关键提醒**：当前监控指标模块重构方案已全面增强，包含：
- ✅ **P0问题解决方案**：详细的代码修复步骤和验证方法
- ✅ **Feature Flag控制**：渐进式迁移和智能回滚
- ✅ **全面测试策略**：单元、集成、E2E、性能测试
- ✅ **实时监控系统**：KPI收集、告警管理、自动恢复
- ✅ **风险管控机制**：多层级风险评估和自动回滚
- ✅ **生产部署指南**：就绪检查和分阶段实施

建议**立即开始任务A1**（MetricsRegistryService单例修复），这是解决"写A读B"问题的关键第一步。 