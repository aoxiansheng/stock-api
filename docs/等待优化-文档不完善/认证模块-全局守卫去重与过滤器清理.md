### 认证模块：全局守卫去重与过滤器清理修复文档

#### 背景
- 近期重构将认证（JWT / API Key）、权限校验与频率限制整合为全局守卫（`APP_GUARD`）。
- 同时，部分控制器装饰器仍在使用 `UseGuards(...)` 叠加相同守卫，导致重复执行与冗余日志。
- `RateLimitExceptionFilter` 在模块中注册与导出，但未被任何控制器通过 `UseFilters` 使用，属于未使用的 Provider 导出。

#### 核心结论（与重构目标的直接冲突）
- 全局统一：`ApiKeyAuthGuard`、`JwtAuthGuard`、`RateLimitGuard`、`UnifiedPermissionsGuard` 已通过 `APP_GUARD` 全局生效。
- 装饰器内重复：`Auth` / `ApiKeyAuth` / `MixedAuth` 中再次 `UseGuards(...)`，导致相同的认证/授权逻辑重复执行（功能等价但冗余）。
- 未使用的过滤器：`RateLimitExceptionFilter` 未被任何路由使用，仅在模块中提供与导出，建议清理。

#### 证据定位（代码引用）
- 全局守卫注册：
```120:140:/Users/honor/Documents/code/newstockapi/backend/src/app.module.ts
    {
      provide: APP_GUARD,
      useClass: ApiKeyAuthGuard, // 确保API Key认证先执行
    },
    {
      provide: APP_GUARD,
      useClass: JwtAuthGuard, // JWT认证后执行
    },
    {
      provide: APP_GUARD,
      useClass: RateLimitGuard, // API Key频率限制
    },
    {
      provide: APP_GUARD,
      useClass: UnifiedPermissionsGuard, // 权限检查最后执行
    },
```

- 装饰器内重复 `UseGuards`：
```49:51:/Users/honor/Documents/code/newstockapi/backend/src/auth/decorators/auth.decorator.ts
  const decorators = [
    UseGuards(JwtAuthGuard, UnifiedPermissionsGuard),
    ApiBearerAuth(),
```
```92:98:/Users/honor/Documents/code/newstockapi/backend/src/auth/decorators/auth.decorator.ts
  const decorators = [
    // RateLimitGuard 现在是全局守卫，不需要在这里重复使用
    UseGuards(ApiKeyAuthGuard, UnifiedPermissionsGuard),
    RequireApiKey(),
    ApiSecurity("ApiKey"),
    ApiSecurity("AccessToken"),
  ];
```
```136:146:/Users/honor/Documents/code/newstockapi/backend/src/auth/decorators/auth.decorator.ts
  const decorators = [
    // RateLimitGuard 现在是全局守卫，不需要在这里重复使用
    UseGuards(
      JwtAuthGuard,
      ApiKeyAuthGuard,
      UnifiedPermissionsGuard,
    ),
    ApiBearerAuth(),
    ApiSecurity("ApiKey"),
    ApiSecurity("AccessToken"),
  ];
```

- 未使用的过滤器注册与导出：
```67:71:/Users/honor/Documents/code/newstockapi/backend/src/auth/module/auth.module.ts
    UnifiedPermissionsGuard,
    RateLimitGuard,
    RateLimitExceptionFilter,
    ApiKeyRepository,
    UserRepository,
```
```84:88:/Users/honor/Documents/code/newstockapi/backend/src/auth/module/auth.module.ts
    UnifiedPermissionsGuard,
    RateLimitGuard,
    RateLimitExceptionFilter,
    ApiKeyRepository,
    UserRepository,
```

- WebSocket 路径独立实现（不与 HTTP 全局守卫冲突）：
```76:91:/Users/honor/Documents/code/newstockapi/backend/src/core/01-entry/stream-receiver/guards/ws-auth.guard.ts
  private async validateApiKey(
    apiKey: string,
    accessToken: string,
    client: Socket,
  ): Promise<boolean> {
    try {
      // 复用现有的ApiKeyService验证逻辑
      const apiKeyDoc = await this.apiKeyService.validateApiKey(apiKey, accessToken);

      if (!apiKeyDoc) {
        ... // 省略
      }
```

#### 问题说明
- 认证与权限重复执行：全局与装饰器双处触发相同守卫，带来重复日志与潜在副作用（如重复设置响应头、重复读取请求属性、重复异常栈）。
- 过滤器未使用：增加 DI 复杂度与导出噪音。

#### 修复方案（分阶段，功能等价）
- 阶段 A（当前迭代）：装饰器去重，仅保留元数据与文档标记
  - `Auth(...)`：移除 `UseGuards(JwtAuthGuard, UnifiedPermissionsGuard)`，保留 `ApiBearerAuth()`、`Roles(...)`、`RequirePermissions(...)`。
  - `ApiKeyAuth(...)`：移除 `UseGuards(ApiKeyAuthGuard, UnifiedPermissionsGuard)`，保留 `RequireApiKey()`、`ApiSecurity("ApiKey")`、`ApiSecurity("AccessToken")`、`RequirePermissions(...)`。
  - `MixedAuth(...)`：移除 `UseGuards(JwtAuthGuard, ApiKeyAuthGuard, UnifiedPermissionsGuard)`，保留 `ApiBearerAuth()`、`ApiSecurity(...)`、`Roles(...)`、`RequirePermissions(...)`。
  - 结果：认证、授权、限流仍由 `APP_GUARD` 严格控制；装饰器仅承担声明性元数据与 OpenAPI 文档职责。

- 阶段 B（非关键，可择期）：清理未使用 Provider
  - 从 `auth.module.ts` 的 `providers` 与 `exports` 移除 `RateLimitExceptionFilter`。
  - 后续如需启用过滤器，请在对应控制器上使用 `UseFilters(...)` 或配置为全局过滤器。

- 阶段 C（规范与防回归）
  - 团队规范：统一通过 `APP_GUARD` 处理认证/授权/限流；装饰器不再二次 `UseGuards`。
  - PR 模版增加检查项：变更是否引入装饰器层守卫；如有，说明必要性或改为元数据表达。

#### 影响范围与兼容性
- 接口契约不变：请求头/令牌/权限元数据一致。
- 行为等价：
  - `JwtAuthGuard`/`ApiKeyAuthGuard` 均已实现按需短路（`@Public`、`@RequireApiKey`、请求头探测），移除装饰器去重不改变鉴权路径。
  - `UnifiedPermissionsGuard` 仍在全局执行，权限元数据继续生效。
  - WebSocket 认证/限流由 `WsAuthGuard` 内部复用服务实现，不受改动影响。
- 风险：仅减少冗余日志与重复触发，业务语义保持一致。

#### 验证步骤
1. 单测/集成/黑盒测试：
   - 路由类型：JWT-only / APIKey-only / Mixed / Public。
   - 权限：通过与拒绝各一例，确认日志仅出现一次，返回语义不变。
   - 限流：HTTP 由 `RateLimitGuard` 生效；WS 由 `WsAuthGuard` 的 `RateLimitService` 生效。
2. 人工回归：
   - 通过 Swagger & 脚本访问关键端点，观察响应头与返回码与重构前一致，日志无重复。

#### 开发者执行清单
- 去重守卫（高优先级）
  - 编辑 `src/auth/decorators/auth.decorator.ts`：删除三处 `UseGuards(...)`，保留 `ApiBearerAuth` / `ApiSecurity` / `Roles` / `RequirePermissions` / `RequireApiKey`。
- 过滤器清理（可延期）
  - 编辑 `src/auth/module/auth.module.ts`：从 `providers` 与 `exports` 移除 `RateLimitExceptionFilter`。

#### 回滚策略
- 如出现未预期影响，可临时恢复装饰器内 `UseGuards(...)`，但建议同时定位依赖重复守卫的具体用例并改为元数据方式表达，避免长期耦合。

#### 备注
- 本文档仅处理认证/授权/限流与装饰器去重的直接冲突，未涉及性能优化与 UI 相关改动。 