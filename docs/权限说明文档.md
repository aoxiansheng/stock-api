# API Key 管理系统文档

## 概述

API Key管理系统为第三方应用提供安全、可控的API访问机制。通过统一的权限验证架构和细粒度的权限控制，确保系统资源的合理使用。系统使用UnifiedPermissionsGuard进行统一的权限验证。

## 系统架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web Console   │───▶│  AuthController │───▶│   AuthService   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │                        │
                                ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │ JWT Validation  │    │  MongoDB Store  │
                       └─────────────────┘    └─────────────────┘

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ Client Request  │───▶│ ApiKeyAuthGuard │───▶│ ApiKeyStrategy  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │                        │
                                ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │UnifiedPermGuard │    │  Permission     │
                       └─────────────────┘    │  Service        │
                                │             └─────────────────┘
                                ▼
                       ┌─────────────────┐
                       │  RateLimitGuard │
                       └─────────────────┘
```

---

## UnifiedPermissionsGuard 统一权限验证机制

UnifiedPermissionsGuard 是系统权限架构的核心组件，提供统一的权限验证逻辑，适用于JWT用户和API Key两种认证主体。

### 设计目的

- **统一验证逻辑**：避免为不同认证方式维护多套权限验证代码
- **确保一致性**：保证所有接入点的权限验证行为一致
- **提升维护性**：权限变更只需修改一处代码
- **详细审计**：提供完整的权限验证日志记录

### 工作原理

```typescript
@Injectable()
export class UnifiedPermissionsGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    // 获取端点所需的角色和权限
    const requiredRoles = this.getRequiredRoles(context);
    const requiredPermissions = this.getRequiredPermissions(context);

    // 无权限要求时直接放行
    if (requiredRoles.length === 0 && requiredPermissions.length === 0) {
      return true;
    }

    // 获取认证主体
    const authSubject = AuthSubjectFactory.createFromRequest(request);

    // 执行权限验证
    const checkResult = await this.permissionService.checkPermissions(
      authSubject,
      requiredPermissions,
      requiredRoles,
    );

    // 权限验证失败时抛出异常
    if (!checkResult.allowed) {
      throw new ForbiddenException({
        message: this.generatePermissionDeniedMessage(
          authSubject,
          checkResult
        ),
        details: {
          type: authSubject.type === AuthSubjectType.JWT_USER
            ? "JWT_USER_PERMISSION_DENIED"
            : "API_KEY_PERMISSION_DENIED",
          // ...其他详情
        }
      });
    }
    
    return true;
  }
}
```

### 认证主体抽象

UnifiedPermissionsGuard 使用工厂模式创建统一的认证主体接口：

```typescript
interface AuthSubject {
  id: string;
  type: AuthSubjectType;
  permissions: Permission[];
  role?: UserRole;
  getDisplayName(): string;
}

enum AuthSubjectType {
  JWT_USER = 'jwt_user',
  API_KEY = 'api_key'
}

class AuthSubjectFactory {
  static createFromRequest(request: Request): AuthSubject {
    if (request.user?.type === 'jwt') {
      return new JwtUserSubject(request.user);
    } else if (request.apiKey) {
      return new ApiKeySubject(request.apiKey);
    }
    throw new UnauthorizedException('未找到有效的认证主体');
  }
}
```

### 差异化权限验证

UnifiedPermissionsGuard 对不同类型的认证主体采用不同的验证策略：

| 主体类型 | 角色验证 | 权限验证 | 错误类型 |
|---------|---------|---------|---------|
| JWT用户 | ✅ 检查 | ✅ 检查 | JWT_USER_PERMISSION_DENIED |
| API Key | ❌ 跳过 | ✅ 检查 | API_KEY_PERMISSION_DENIED |

### 与守卫链的集成

UnifiedPermissionsGuard 在守卫链中的执行顺序：

1. **ThrottlerGuard**: 全局请求限制
2. **ApiKeyAuthGuard**: API Key 认证
3. **JwtAuthGuard**: JWT 认证
4. **UnifiedPermissionsGuard**: 统一权限验证
5. **RateLimitGuard**: API Key 特定限流

这种顺序确保了先完成身份认证，再进行权限验证，最后应用特定限制。

### 使用示例

```typescript
// JWT 认证 - 管理员访问
@Auth([UserRole.ADMIN], [Permission.APIKEY_MANAGE])
@Get('api-keys')
getApiKeys() {
  // 需要ADMIN角色和apikey:manage权限
}

// API Key 认证 - 数据访问
@ApiKeyAuth([Permission.DATA_READ])
@Get('stocks')
getStockData() {
  // 需要data:read权限
}

// 混合认证 - 两种方式都支持
@MixedAuth([UserRole.DEVELOPER], [Permission.SYSTEM_HEALTH])
@Get('health')
checkHealth() {
  // JWT用户需要DEVELOPER角色
  // API Key用户需要system:health权限
}
```

---

## 守卫组件详解

### 1. ApiKeyAuthGuard - API Key身份认证守卫

负责验证API Key身份凭据的核心守卫，使用Passport策略模式。

**位置**: `src/auth/guards/apikey-auth.guard.ts`

**主要功能**:
- 验证`X-App-Key`和`X-Access-Token`请求头
- 通过`ApiKeyStrategy`查询数据库验证凭据
- 检查API Key的激活状态和过期时间
- 将验证通过的API Key对象设置到`request.user`

**执行顺序**: 第2位 (在ThrottlerGuard之后，JwtAuthGuard之前)

**跳过条件**:
- 接口标记为`@Public()`公开访问
- 接口未明确要求API Key认证

### 2. JwtAuthGuard - JWT令牌认证守卫

负责验证JWT令牌的身份认证守卫，支持与API Key认证的智能切换。

**位置**: `src/auth/guards/jwt-auth.guard.ts`

**主要功能**:
- 验证`Authorization: Bearer <token>`请求头中的JWT令牌
- 使用Passport JWT策略解码和验证令牌
- 检查令牌签名、过期时间和载荷完整性
- 将验证通过的用户对象设置到`request.user`
- 智能检测API Key头部并跳过JWT验证（避免冲突）

**智能认证切换逻辑**:
```typescript
// 优先级判断
if (isPublic) return true;                    // 1. 公开接口直接放行
if (requireApiKey || hasApiKeyHeaders) {     // 2. API Key认证优先
  return true; // 跳过JWT验证
}
return super.canActivate(context);           // 3. 执行JWT验证
```

**执行顺序**: 第3位 (在ApiKeyAuthGuard之后，UnifiedPermissionsGuard之前)

**错误处理**: 
- JWT解析失败: `UnauthorizedException("JWT认证失败")`
- 令牌格式错误: 返回401状态码
- 令牌过期: 自动由JWT策略处理

### 3. UnifiedPermissionsGuard - 统一权限验证守卫

系统权限架构的核心组件，提供JWT用户和API Key的统一权限验证逻辑。

**位置**: `src/auth/guards/unified-permissions.guard.ts`

**设计理念**:
- **统一验证逻辑**: 避免为不同认证方式维护多套权限验证代码
- **确保一致性**: 保证所有接入点的权限验证行为一致
- **提升维护性**: 权限变更只需修改一处代码
- **详细审计**: 提供完整的权限验证日志记录

**验证策略差异**:
| 认证主体 | 角色验证 | 权限验证 | 错误类型 |
|---------|---------|---------|---------|
| JWT用户 | ✅ 检查 | ✅ 检查 | JWT_USER_PERMISSION_DENIED |
| API Key | ❌ 跳过 | ✅ 检查 | API_KEY_PERMISSION_DENIED |

**执行顺序**: 第4位 (在身份认证守卫之后，RateLimitGuard之前)

**核心流程**:
```typescript
1. 获取端点所需的角色和权限要求
2. 无权限要求时直接放行
3. 通过AuthSubjectFactory创建统一认证主体
4. 调用PermissionService执行权限验证
5. 验证失败时抛出详细的ForbiddenException
6. 记录完整的权限验证日志
```

### 4. RateLimitGuard - API Key频率限制守卫

专门针对API Key用户的频率限制守卫，与全局IP限流分离。

**位置**: `src/auth/guards/rate-limit.guard.ts`

**主要功能**:
- 基于API Key的个性化频率限制
- 支持滑动窗口和固定窗口策略
- Redis存储限流计数器
- 设置专用的API Key限流响应头

**限流策略**:
- **时间窗口**: 支持1s, 5m, 1h, 1d等配置
- **计数方式**: 每个API Key独立计数
- **响应头**: 使用`X-API-RateLimit-*`前缀避免冲突

**执行顺序**: 第5位 (最后执行，在所有认证和权限验证之后)

**容错机制**: 当Redis服务不可用时，允许请求通过以保证服务可用性

**响应头说明**:
```http
X-API-RateLimit-Limit: 10000        # 限制总数
X-API-RateLimit-Remaining: 9955     # 剩余次数
X-API-RateLimit-Reset: 1640995200   # 重置时间戳
X-API-Retry-After: 3600             # 建议重试间隔(秒)
X-API-RateLimit-Type: API_KEY       # 限制类型标识
```

### 守卫链执行顺序

系统按以下顺序执行守卫链，确保安全性和性能:

```
1. ThrottlerGuard (全局)     → IP级别的全局请求限制
2. ApiKeyAuthGuard          → API Key身份认证
3. JwtAuthGuard             → JWT身份认证 (智能跳过)
4. UnifiedPermissionsGuard  → 统一权限验证
5. RateLimitGuard          → API Key个性化频率限制
```

**设计原则**:
- **先认证，后授权**: 身份验证完成后再进行权限检查
- **认证互斥**: API Key和JWT认证互相排斥，避免冲突
- **权限统一**: 使用统一守卫处理不同认证主体的权限验证
- **限流分层**: 全局IP限流 + API Key个性化限流

---

## 数据模型

### API Key Schema
```typescript
interface ApiKeyDocument {
  _id: ObjectId;                    // MongoDB文档ID
  appKey: string;                   // 应用密钥（UUID格式）
  accessToken: string;              // 访问令牌（32字符十六进制）- 注意：当前实现为明文存储
  name: string;                     // API Key名称
  description?: string;             // 描述信息
  createdBy: ObjectId;              // 创建者用户ID
  permissions: Permission[];        // 权限列表
  rateLimit: RateLimitConfig;       // 频率限制配置
  isActive: boolean;                // 是否激活
  usageCount: number;               // 使用次数统计
  lastUsedAt?: Date;                // 最后使用时间
  expiresAt?: Date;                 // 过期时间（可选）
  metadata?: Record<string, any>;   // 元数据（可选）
  createdAt: Date;                  // 创建时间
  updatedAt: Date;                  // 更新时间
}

interface RateLimitConfig {
  requests: number;                 // 请求数限制
  window: string;                   // 时间窗口（1s, 5m, 1h, 1d）
}

enum Permission {
  // 基础数据权限 (3个)
  DATA_READ = "data:read",
  QUERY_EXECUTE = "query:execute", 
  PROVIDERS_READ = "providers:read",

  // 开发者权限 (6个)
  TRANSFORMER_PREVIEW = "transformer:preview",
  SYSTEM_MONITOR = "system:monitor",
  SYSTEM_METRICS = "system:metrics",
  SYSTEM_HEALTH = "system:health",
  DEBUG_ACCESS = "debug:access",
  CONFIG_READ = "config:read",

  // 管理员权限 (5个)
  USER_MANAGE = "user:manage",
  APIKEY_MANAGE = "apikey:manage",
  CONFIG_WRITE = "config:write",
  MAPPING_WRITE = "mapping:write",
  SYSTEM_ADMIN = "system:admin",

  // 扩展功能权限 (4个)
  DATA_WRITE = "data:write",
  QUERY_STATS = "query:stats",
  QUERY_HEALTH = "query:health",
  PROVIDERS_MANAGE = "providers:manage",
}
```

### 数据库索引
```javascript
// MongoDB索引设计
db.apikeys.createIndex({ appKey: 1 }, { unique: true });
db.apikeys.createIndex({ accessToken: 1 }, { unique: true });
db.apikeys.createIndex({ createdBy: 1 });
db.apikeys.createIndex({ isActive: 1 });
db.apikeys.createIndex({ lastUsedAt: -1 });
db.apikeys.createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 });
```

---

## API 接口详解

### 1. 创建 API Key

```http
POST /api/v1/auth/api-keys
Authorization: Bearer {jwt_token}
Content-Type: application/json

{
  "name": "生产环境API Key",
  "description": "用于生产环境的股票数据获取",
  "permissions": [
    "data:read",
    "query:execute",
    "providers:read"
  ],
  "rateLimit": {
    "requests": 10000,
    "window": "1h"
  },
  "expiresAt": "2025-12-31T23:59:59.999Z"
}
```

**响应示例：**
```json
{
  "statusCode": 201,
  "message": "API Key创建成功",
  "data": {
    "_id": "668b1234567890abcdef1234",
    "appKey": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "accessToken": "a1b2c3d4e5f678901234567890abcdef",
    "name": "生产环境API Key",
    "description": "用于生产环境的股票数据获取",
    "permissions": [
      "data:read",
      "query:execute", 
      "providers:read"
    ],
    "rateLimit": {
      "requests": 10000,
      "window": "1h"
    },
    "isActive": true,
    "usageCount": 0,
    "expiresAt": "2025-12-31T23:59:59.999Z",
    "createdAt": "2025-07-01T10:00:00.000Z",
    "updatedAt": "2025-07-01T10:00:00.000Z"
  },
  "timestamp": "2025-07-01T10:00:00.000Z"
}
```

### 2. 列出API Keys

```http
GET /api/v1/auth/api-keys?page=1&limit=10&isActive=true&sortBy=createdAt&sortOrder=desc
Authorization: Bearer {jwt_token}
```

**查询参数：**
- `page` - 页码（默认1）
- `limit` - 每页数量（默认10，最大100）
- `isActive` - 筛选激活状态
- `search` - 按名称或描述搜索
- `sortBy` - 排序字段（createdAt, lastUsedAt, usageCount, name）
- `sortOrder` - 排序方向（asc, desc）

**响应示例：**
```json
{
  "statusCode": 200,
  "message": "获取API Key列表成功",
  "data": {
    "items": [
      {
        "_id": "668b1234567890abcdef1234",
        "appKey": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
        "name": "生产环境API Key", 
        "description": "用于生产环境的股票数据获取",
        "permissions": ["data:read", "query:execute"],
        "rateLimit": {
          "requests": 10000,
          "window": "1h"
        },
        "isActive": true,
        "usageCount": 156789,
        "lastUsedAt": "2025-07-01T09:45:30.000Z",
        "expiresAt": "2025-12-31T23:59:59.999Z",
        "createdAt": "2025-01-01T00:00:00.000Z",
        "updatedAt": "2025-07-01T09:45:30.000Z"
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 25,
      "totalPages": 3,
      "hasNext": true,
      "hasPrev": false
    }
  },
  "timestamp": "2025-07-01T10:00:00.000Z"
}
```

### 3. 获取API Key详情

```http
GET /api/v1/auth/api-keys/{apiKeyId}
Authorization: Bearer {jwt_token}
```

**响应示例：**
```json
{
  "statusCode": 200,
  "message": "获取API Key详情成功",
  "data": {
    "_id": "668b1234567890abcdef1234",
    "appKey": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "accessToken": "a1b2c3d4e5f6********", // 部分隐藏
    "name": "生产环境API Key",
    "description": "用于生产环境的股票数据获取",
    "permissions": [
      "data:read",
      "query:execute",
      "providers:read"
    ],
    "rateLimit": {
      "requests": 10000,
      "window": "1h"
    },
    "isActive": true,
    "usageCount": 156789,
    "lastUsedAt": "2025-07-01T09:45:30.000Z",
    "expiresAt": "2025-12-31T23:59:59.999Z",
    "metadata": {
      "environment": "production",
      "client_version": "1.2.3"
    },
    "createdAt": "2025-01-01T00:00:00.000Z",
    "updatedAt": "2025-07-01T09:45:30.000Z",
    "createdBy": {
      "_id": "668a1234567890abcdef1234",
      "username": "developer1",
      "email": "dev@example.com"
    }
  },
  "timestamp": "2025-07-01T10:00:00.000Z"
}
```

### 4. 更新API Key

```http
PUT /api/v1/auth/api-keys/{apiKeyId}
Authorization: Bearer {jwt_token}
Content-Type: application/json

{
  "name": "更新后的API Key名称",
  "description": "更新后的描述",
  "permissions": [
    "data:read",
    "query:execute",
    "query:stats"
  ],
  "rateLimit": {
    "requests": 5000,
    "window": "1h"
  },
  "isActive": true,
  "expiresAt": "2026-12-31T23:59:59.999Z",
  "metadata": {
    "environment": "production",
    "client_version": "1.3.0"
  }
}
```

### 5. 重新生成访问令牌

```http
POST /api/v1/auth/api-keys/{apiKeyId}/regenerate-token
Authorization: Bearer {jwt_token}
```

**响应示例：**
```json
{
  "statusCode": 200,
  "message": "访问令牌重新生成成功",
  "data": {
    "appKey": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "accessToken": "b2c3d4e5f67890123456789a0bcdef01",
    "message": "请保存新的访问令牌，旧令牌已失效"
  },
  "timestamp": "2025-07-01T10:00:00.000Z"
}
```

### 6. 获取使用统计

```http
GET /api/v1/auth/api-keys/{apiKeyId}/usage?period=7d&granularity=1h
Authorization: Bearer {jwt_token}
```

**查询参数：**
- `period` - 统计周期（1d, 7d, 30d, 90d）
- `granularity` - 数据粒度（1h, 1d, 1w）
- `timezone` - 时区（默认UTC）

**响应示例：**
```json
{
  "statusCode": 200,
  "message": "获取使用统计成功",
  "data": {
    "summary": {
      "totalRequests": 156789,
      "successfulRequests": 154321,
      "failedRequests": 2468,
      "averageRequestsPerHour": 929.1,
      "peakHour": "2025-07-01T14:00:00.000Z",
      "peakHourRequests": 1456
    },
    "currentUsage": {
      "currentPeriodRequests": 45,
      "limit": 10000,
      "remaining": 9955,
      "resetTime": 1751397600000,
      "utilizationRate": 0.45
    },
    "timeline": [
      {
        "timestamp": "2025-07-01T00:00:00.000Z",
        "requests": 678,
        "success": 675,
        "errors": 3
      },
      {
        "timestamp": "2025-07-01T01:00:00.000Z", 
        "requests": 724,
        "success": 720,
        "errors": 4
      }
    ],
    "topEndpoints": [
      {
        "endpoint": "/api/v1/receiver/data",
        "requests": 89543,
        "percentage": 57.1
      },
      {
        "endpoint": "/api/v1/query/execute",
        "requests": 45678,
        "percentage": 29.1
      }
    ],
    "errorBreakdown": [
      {
        "statusCode": 429,
        "count": 1234,
        "percentage": 50.0
      },
      {
        "statusCode": 400,
        "count": 987,
        "percentage": 40.0
      }
    ]
  },
  "timestamp": "2025-07-01T10:00:00.000Z"
}
```

### 7. 删除API Key

```http
DELETE /api/v1/auth/api-keys/{apiKeyId}
Authorization: Bearer {jwt_token}
```

**响应示例：**
```json
{
  "statusCode": 200,
  "message": "API Key删除成功",
  "data": {
    "deletedId": "668b1234567890abcdef1234",
    "deletedAt": "2025-07-01T10:00:00.000Z"
  },
  "timestamp": "2025-07-01T10:00:00.000Z"
}
```

---

## 三层认证体系权限映射

### JWT角色权限映射

```typescript
// 角色权限映射定义
const ROLE_PERMISSIONS = {
  DEVELOPER: [
    // 基础数据权限 (3个)
    'data:read',
    'query:execute', 
    'providers:read',
    
    // 开发者专属权限 (6个)
    'transformer:preview',
    'system:monitor',
    'system:metrics',
    'system:health',
    'debug:access',
    'config:read'
  ], // 总计: 9个权限

  ADMIN: [
    // 继承所有开发者权限 (9个)
    ...ROLE_PERMISSIONS.DEVELOPER,
    
    // 管理员专属权限 (5个)
    'user:manage',
    'apikey:manage',
    'config:write',
    'mapping:write',
    'system:admin',
    
    // 部分扩展功能权限
    'data:write',
    'providers:manage'
  ] // 总计: 16个权限
};
```

### 认证方式对比

| 认证方式 | 权限来源 | 权限数量 | 使用场景 |
|---------|---------|---------|---------|
| **JWT + DEVELOPER** | 角色预定义权限 | 9个固定权限 | 系统开发、数据预览、功能测试 |
| **JWT + ADMIN** | 角色预定义权限 | 16个固定权限 | 系统配置、用户管理、运维操作 |
| **API Key** | 自定义权限组合 | 最多18个权限 | 外部集成、自动化脚本、第三方应用 |
| **Public** | 无需权限 | 0个权限 | 公开访问接口 |

---

## 权限系统详解

### 权限级别设计

#### 1. 数据访问权限
```typescript
// 读取数据权限
DATA_READ = 'data:read'
// 包含的端点：
// - GET /api/v1/receiver/data
// - GET /api/v1/storage/*
// - GET /api/v1/query/execute (只读查询)

// 写入数据权限（管理员功能）
DATA_WRITE = 'data:write'
// 包含的端点：
// - POST /api/v1/storage/*
// - PUT /api/v1/storage/*
// - DELETE /api/v1/storage/*
```

#### 2. 查询权限
```typescript
// 执行查询权限
QUERY_EXECUTE = 'query:execute'
// 包含的端点：
// - POST /api/v1/query/execute
// - GET /api/v1/query/results/*

// 查询统计权限
QUERY_STATS = 'query:stats'
// 包含的端点：
// - GET /api/v1/query/stats
// - GET /api/v1/query/performance

// 查询健康检查权限
QUERY_HEALTH = 'query:health'
// 包含的端点：
// - POST /api/v1/query/health-check
```

#### 3. 提供商权限
```typescript
// 查看提供商信息权限
PROVIDERS_READ = 'providers:read'
// 包含的端点：
// - GET /api/v1/providers/capabilities
// - GET /api/v1/providers/*/capabilities
// - GET /api/v1/providers/best-provider/*

// 管理提供商权限（管理员功能）
PROVIDERS_MANAGE = 'providers:manage'
// 包含的端点：
// - POST /api/v1/providers/*/configure
// - PUT /api/v1/providers/*/settings
```

#### 4. 开发者权限
```typescript
// 数据转换预览权限
TRANSFORMER_PREVIEW = 'transformer:preview'
// 包含的端点：
// - POST /api/v1/transformer/preview

// 系统监控权限
SYSTEM_MONITOR = 'system:monitor'
// 包含的端点：
// - GET /api/v1/monitoring/health
// - GET /api/v1/monitoring/status

// 系统指标权限
SYSTEM_METRICS = 'system:metrics'
// 包含的端点：
// - GET /api/v1/monitoring/metrics
// - GET /api/v1/monitoring/performance

// 健康检查权限
SYSTEM_HEALTH = 'system:health'
// 包含的端点：
// - GET /api/v1/monitoring/health-check

// 调试访问权限
DEBUG_ACCESS = 'debug:access'
// 包含的端点：
// - GET /api/v1/debug/*
// - POST /api/v1/debug/trace

// 配置读取权限
CONFIG_READ = 'config:read'
// 包含的端点：
// - GET /api/v1/config/*
```

#### 5. 管理员权限
```typescript
// 用户管理权限
USER_MANAGE = 'user:manage'
// 包含的端点：
// - POST /api/v1/auth/users
// - PUT /api/v1/auth/users/*
// - DELETE /api/v1/auth/users/*

// API密钥管理权限
APIKEY_MANAGE = 'apikey:manage'
// 包含的端点：
// - POST /api/v1/auth/api-keys
// - PUT /api/v1/auth/api-keys/*
// - DELETE /api/v1/auth/api-keys/*

// 配置写入权限
CONFIG_WRITE = 'config:write'
// 包含的端点：
// - POST /api/v1/config/*
// - PUT /api/v1/config/*

// 映射规则写入权限
MAPPING_WRITE = 'mapping:write'
// 包含的端点：
// - POST /api/v1/data-mapper/rules
// - PUT /api/v1/data-mapper/rules/*
// - POST /api/v1/symbol-mapper/rules

// 系统管理权限
SYSTEM_ADMIN = 'system:admin'
// 包含的端点：
// - POST /api/v1/admin/*
// - PUT /api/v1/admin/*
// - DELETE /api/v1/admin/*
```

### 权限检查机制

> ⚠️ **注意**: 以下装饰器用法为示例，实际代码中请使用 `@RequirePermissions(Permission.PERMISSION_NAME)` 的形式。

#### 1. 装饰器权限检查
```typescript
@ApiKeyAuth()
@RequirePermissions(Permission.DATA_READ, Permission.QUERY_EXECUTE)
@Get('data')
async getData(@Request() req) {
  // 自动检查权限，无权限返回403
}
```

#### 2. 程序化权限检查
```typescript
// 在服务中检查权限
if (!this.hasPermission(apiKey, 'data:read')) {
  throw new ForbiddenException('权限不足：需要数据读取权限');
}
```

#### 3. 动态权限验证

> ⚠️ **注意**: 以下为设想中的高级功能，当前版本尚未实现。

```typescript
// 检查多个权限（AND逻辑）
@RequirePermissions(Permission.DATA_READ, Permission.QUERY_EXECUTE)

// 检查任一权限（OR逻辑）
@RequireAnyPermission(Permission.DATA_READ, Permission.DATA_WRITE)

// 自定义权限逻辑
@CustomPermissionCheck((apiKey, context) => {
  return apiKey.permissions.includes('data:read');
})
```

---

## 安全机制

### 1. 令牌安全

#### App Key 生成
```typescript
// 使用UUID v4确保唯一性和随机性
function generateAppKey(): string {
  return uuidv4(); // f47ac10b-58cc-4372-a567-0e02b2c3d479
}
```

#### Access Token 生成
```typescript
// 使用安全随机数生成32字符十六进制令牌
function generateAccessToken(): string {
  return crypto.randomBytes(16).toString('hex'); // 32字符
}
```

#### 令牌存储

> ⚠️ **安全警告**: 当前实现将 `accessToken` 明文存储在数据库中。这是一个严重的安全风险。**强烈建议**迁移到哈希存储方案。

**当前实现 (明文存储):**
```typescript
// 直接存储明文令牌
const apiKey = new ApiKeyModel({
  appKey,
  accessToken, // 警告：明文存储
  // ... 其他字段
});
```

**推荐的哈希存储方案:**
```typescript
// Access Token哈希存储
const hashedToken = await bcrypt.hash(accessToken, 10);

// 保存到数据库时只存储哈希值
const apiKey = new ApiKeyModel({
  appKey,
  accessTokenHash: hashedToken, // 存储哈希值
  // ... 其他字段
});
```

#### 令牌验证

**当前实现 (明文对比):**
```typescript
// 直接在数据库中查询明文令牌
async validateAccessToken(appKey: string, accessToken: string): Promise<boolean> {
  const apiKey = await this.apiKeyModel.findOne({ appKey, accessToken, isActive: true });
  return !!apiKey;
}
```

**推荐的哈希验证方案:**
```typescript
// 验证时对比哈希值
async validateAccessToken(appKey: string, accessToken: string): Promise<boolean> {
  const apiKey = await this.findByAppKey(appKey);
  if (!apiKey) return false;
  
  return bcrypt.compare(accessToken, apiKey.accessTokenHash);
}
```

### 2. 请求安全

#### 防止重放攻击
```typescript
// 可选：添加时间戳和签名验证
interface SecureApiRequest {
  appKey: string;
  accessToken: string;
  timestamp: number;
  signature: string; // HMAC-SHA256签名
}

// 验证时间戳（5分钟有效期）
const isValidTimestamp = Math.abs(Date.now() - timestamp) < 5 * 60 * 1000;

// 验证签名
const expectedSignature = crypto
  .createHmac('sha256', apiKey.secretKey)
  .update(`${appKey}:${timestamp}:${requestBody}`)
  .digest('hex');
```

#### IP 白名单（可选）
```typescript
interface ApiKeyDocument {
  // ... 其他字段
  ipWhitelist?: string[]; // IP白名单
  ipBlacklist?: string[]; // IP黑名单
}

// IP验证
function validateIP(clientIP: string, apiKey: ApiKeyDocument): boolean {
  if (apiKey.ipBlacklist?.includes(clientIP)) return false;
  if (apiKey.ipWhitelist?.length && !apiKey.ipWhitelist.includes(clientIP)) return false;
  return true;
}
```

### 3. 数据保护

#### 敏感信息脱敏
```typescript
// 返回API Key信息时隐藏敏感数据
function sanitizeApiKey(apiKey: ApiKeyDocument): ApiKeyResponse {
  return {
    ...apiKey,
    accessToken: apiKey.accessToken.substring(0, 8) + '********', // 部分隐藏
    accessTokenHash: undefined, // 完全隐藏
  };
}
```

#### 审计日志
```typescript
// 记录所有API Key操作
interface ApiKeyAuditLog {
  apiKeyId: string;
  action: 'create' | 'update' | 'delete' | 'regenerate' | 'access';
  userId: string;
  clientIP: string;
  userAgent: string;
  timestamp: Date;
  details?: Record<string, any>;
}
```

---

## 生命周期管理

### 1. 创建流程

```mermaid
sequenceDiagram
    participant User as 用户
    participant Auth as AuthController
    participant Service as AuthService
    participant DB as MongoDB
    participant Redis as Redis

    User->>Auth: POST /api/v1/auth/api-keys
    Auth->>Auth: 验证JWT Token
    Auth->>Auth: 检查用户权限
    Auth->>Service: 创建API Key
    Service->>Service: 生成App Key (UUID)
    Service->>Service: 生成Access Token
    Service->>Service: 哈希Access Token
    Service->>DB: 保存API Key
    Service->>Redis: 缓存权限信息
    Service-->>Auth: 返回API Key信息
    Auth-->>User: 返回完整凭据（仅此一次）
```

### 2. 使用流程

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Guard as ApiKeyAuthGuard
    participant Strategy as ApiKeyStrategy
    participant DB as MongoDB
    participant RateLimit as RateLimitGuard
    participant Redis as Redis

    Client->>Guard: API请求 + App Key + Access Token
    Guard->>Strategy: 验证凭据
    Strategy->>DB: 查询API Key
    Strategy->>Strategy: 验证Access Token哈希
    Strategy->>Strategy: 检查权限
    Strategy-->>Guard: 返回API Key对象
    Guard->>RateLimit: 检查频率限制
    RateLimit->>Redis: 检查/更新计数器
    RateLimit-->>Guard: 返回限制结果
    Guard-->>Client: 允许请求 + 频率限制头
```

### 3. 清理流程

#### 过期清理
```typescript
// 定时清理过期的API Key
@Cron('0 0 * * *') // 每天午夜执行
async cleanupExpiredApiKeys(): Promise<void> {
  const expiredKeys = await this.apiKeyModel.find({
    expiresAt: { $lt: new Date() },
    isActive: true
  });

  for (const apiKey of expiredKeys) {
    // 标记为非激活
    await this.apiKeyModel.findByIdAndUpdate(apiKey._id, {
      isActive: false,
      deactivatedAt: new Date(),
      deactivationReason: 'expired'
    });

    // 清理Redis缓存
    await this.clearApiKeyCache(apiKey.appKey);
    
    // 记录审计日志
    await this.auditLogger.log({
      apiKeyId: apiKey._id,
      action: 'auto_deactivate',
      reason: 'expired',
      timestamp: new Date()
    });
  }
}
```

#### 非活跃清理
```typescript
// 清理长期未使用的API Key
@Cron('0 2 */7 * *') // 每周执行
async cleanupInactiveApiKeys(): Promise<void> {
  const inactiveThreshold = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000); // 90天

  const inactiveKeys = await this.apiKeyModel.find({
    $or: [
      { lastUsedAt: { $lt: inactiveThreshold } },
      { lastUsedAt: null, createdAt: { $lt: inactiveThreshold } }
    ],
    isActive: true
  });

  // 发送通知给用户确认是否保留
  for (const apiKey of inactiveKeys) {
    await this.notificationService.sendInactiveApiKeyNotice(apiKey);
  }
}
```

---

## 监控和告警

### 1. 关键指标

```typescript
// 使用量指标
interface UsageMetrics {
  totalRequests: number;           // 总请求数
  requestsPerHour: number;         // 每小时请求数  
  successRate: number;             // 成功率
  averageResponseTime: number;     // 平均响应时间
  rateLimitHitRate: number;        // 频率限制命中率
}

// 安全指标
interface SecurityMetrics {
  failedAuthAttempts: number;      // 认证失败次数
  suspiciousRequests: number;      // 可疑请求数
  ipBasedAlerts: number;           // IP相关告警
  permissionDenials: number;       // 权限拒绝次数
}

// 系统指标
interface SystemMetrics {
  activeApiKeys: number;           // 活跃API Key数量
  totalApiKeys: number;            // 总API Key数量
  averagePermissionsPerKey: number; // 平均权限数
  expiringKeys: number;            // 即将过期的密钥数
}
```

### 2. 告警规则

```typescript
// 告警配置
const alertRules = {
  // 高频率认证失败
  highAuthFailureRate: {
    threshold: 100,
    window: '5m',
    action: 'block_ip'
  },
  
  // API Key即将过期
  apiKeyExpiring: {
    threshold: '7d',
    action: 'notify_user'
  },
  
  // 异常使用模式
  abnormalUsage: {
    threshold: '5x_average',
    window: '1h',
    action: 'investigate'
  },
  
  // 权限滥用尝试
  permissionAbuse: {
    threshold: 10,
    window: '1h',
    action: 'temporary_suspend'
  }
};
```

### 3. 监控面板

```typescript
// Grafana仪表板配置
const dashboardConfig = {
  panels: [
    {
      title: 'API Key使用趋势',
      type: 'graph',
      targets: ['api_key_requests_total'],
      timeRange: '24h'
    },
    {
      title: '频率限制命中率',
      type: 'stat',
      targets: ['rate_limit_hit_rate'],
      thresholds: [50, 80]
    },
    {
      title: '权限拒绝统计',
      type: 'pie',
      targets: ['permission_denials_by_permission'],
      timeRange: '7d'
    },
    {
      title: '活跃API Key数量',
      type: 'stat',
      targets: ['active_api_keys_count'],
      sparkline: true
    }
  ]
};
```

---

## 最佳实践

### 1. API Key设计
- 为不同环境（开发、测试、生产）创建独立的API Key
- 设置合理的过期时间，避免永久有效的密钥
- 根据最小权限原则分配权限
- 定期轮换访问令牌

### 2. 安全配置
- 启用IP白名单限制（生产环境推荐）
- 配置合适的频率限制避免滥用
- 监控异常使用模式
- 建立应急响应流程

### 3. 性能优化
- 使用Redis缓存减少数据库查询
- 批量操作提高效率
- 合理设置缓存过期时间
- 定期清理过期数据

### 4. 用户体验
- 提供清晰的权限说明文档
- 在控制台显示使用统计
- 及时通知即将过期的密钥
- 提供自助故障排查工具

---

*文档版本：v1.0.0*  
*最后更新：2025-07-01*