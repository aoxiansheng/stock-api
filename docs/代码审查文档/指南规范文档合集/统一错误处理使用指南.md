# 统一错误处理使用指南

## 概述

本指南面向开发人员，介绍如何在各组件中使用已建立的统一错误处理基础设施。

### 📋 使用前提
- ✅ 统一异常基础设施已完成（BusinessException、UniversalExceptionFactory、UniversalRetryHandler）
- ✅ GlobalExceptionFilter已扩展支持BusinessException
- ✅ @common模块导出已配置完成

---

## 快速开始

### 1. 导入错误处理模块

```typescript
import {
  BusinessException,
  UniversalExceptionFactory,
  UniversalRetryHandler,
  BusinessErrorCode,
  ComponentIdentifier
} from '@common/core/exceptions';
```

### 2. 定义组件错误码常量

每个组件只需要定义一个错误码常量文件：

```typescript
// src/{component}/constants/{component}-error-codes.constants.ts
export const QUERY_ERROR_CODES = {
  // 验证类错误 (001-299)
  MISSING_REQUIRED_PARAMS: 'QUERY_VALIDATION_001',
  INVALID_SYMBOLS: 'QUERY_VALIDATION_002',
  SYMBOLS_LIMIT_EXCEEDED: 'QUERY_VALIDATION_003',

  // 业务逻辑错误 (300-599)
  UNSUPPORTED_QUERY_TYPE: 'QUERY_BUSINESS_300',
  QUERY_RESULT_EMPTY: 'QUERY_BUSINESS_301',

  // 系统资源错误 (600-899)
  MEMORY_PRESSURE: 'QUERY_SYSTEM_600',
  TIMEOUT_ERROR: 'QUERY_SYSTEM_700',

  // 外部依赖错误 (900-999)
  PROVIDER_UNAVAILABLE: 'QUERY_EXTERNAL_950',
  CACHE_SERVICE_ERROR: 'QUERY_EXTERNAL_900',
} as const;
```

### 3. 替换现有错误处理

#### 改造前 ❌
```typescript
if (!symbols || symbols.length === 0) {
  throw new Error('symbols参数不能为空');
}

if (symbolCount > 10000) {
  throw new Error('symbols数量不能超过10000');
}
```

#### 改造后 ✅
```typescript
import { UniversalExceptionFactory } from '@common/core/exceptions';
import { QUERY_ERROR_CODES } from '../constants/query-error-codes.constants';

if (!symbols || symbols.length === 0) {
  throw UniversalExceptionFactory.createBusinessException(
    'query',
    QUERY_ERROR_CODES.MISSING_REQUIRED_PARAMS,
    'validateSymbols',
    'Symbols parameter cannot be empty',
    { symbols }
  );
}

if (symbolCount > QUERY_LIMITS.MAX_SYMBOLS) {
  throw UniversalExceptionFactory.createBusinessException(
    'query',
    QUERY_ERROR_CODES.SYMBOLS_LIMIT_EXCEEDED,
    'validateSymbols',
    `Symbols count cannot exceed ${QUERY_LIMITS.MAX_SYMBOLS}`,
    { symbolCount, limit: QUERY_LIMITS.MAX_SYMBOLS }
  );
}
```

---

## 核心使用方式

### 🔧 创建业务异常

#### 方式一：手动创建（推荐用于已知错误类型）
```typescript
throw UniversalExceptionFactory.createBusinessException(
  'component',        // 组件名
  'ERROR_CODE',       // 错误码
  'operationName',    // 操作名
  'Error message',    // 错误消息
  { key: 'value' },   // 上下文（可选）
  true                // 是否可重试（可选，默认false）
);
```

#### 方式二：智能转换（推荐用于catch块）
```typescript
try {
  // 一些操作
} catch (error) {
  throw UniversalExceptionFactory.createFromError(
    error as Error,
    'operationName',
    'component',
    { additionalContext: 'value' }
  );
}
```

#### 方式三：便捷方法（常用错误类型）
```typescript
// 404错误
throw UniversalExceptionFactory.createNotFoundError(
  '用户',
  'findUser',
  'auth',
  { userId: '123' }
);

// 验证错误
throw UniversalExceptionFactory.createValidationError(
  'Invalid input parameters',
  'validateInput',
  'query',
  { invalidFields: ['symbols'] }
);

// 服务不可用
throw UniversalExceptionFactory.createServiceUnavailableError(
  'External provider is unavailable',
  'fetchData',
  'provider',
  { providerName: 'longport' }
);
```

### 🔄 使用重试机制

#### 自动重试（推荐）
```typescript
// 标准重试配置（3次，指数退避）
const result = await UniversalRetryHandler.standardRetry(
  async () => await externalService.getData(),
  'fetchExternalData',
  'provider'
);

// 网络相关重试（5次，适合网络不稳定）
const result = await UniversalRetryHandler.networkRetry(
  async () => await apiCall(),
  'apiCall',
  'external'
);

// 快速重试（2次，适合轻量操作）
const result = await UniversalRetryHandler.quickRetry(
  async () => await cacheOperation(),
  'cacheGet',
  'cache'
);
```

#### 自定义重试配置
```typescript
const result = await UniversalRetryHandler.executeWithRetry(
  async () => await complexOperation(),
  {
    maxAttempts: 5,
    baseDelayMs: 1000,
    maxDelayMs: 30000,
    backoffMultiplier: 2,
    jitterMs: 100,
    timeoutMs: 60000
  },
  'complexOperation',
  'processing'
);
```

---

## 组件错误码规范

### 错误码格式
`{COMPONENT}_{CATEGORY}_{SEQUENCE}`

### 组件代码对照表
| 组件名 | 代码 | 组件名 | 代码 |
|--------|------|--------|------|
| Alert服务 | ALERT | Query组件 | QUERY |
| Auth服务 | AUTH | Receiver组件 | RECEIVER |
| Cache服务 | CACHE | Stream-Receiver | STREAM_RECEIVER |
| 监控服务 | MONITORING | Data-Fetcher | DATA_FETCHER |
| 通知服务 | NOTIFICATION | Stream-Data-Fetcher | STREAM_DATA_FETCHER |
| 符号映射 | SYMBOL_MAPPER | Transformer | TRANSFORMER |
| 数据映射 | DATA_MAPPER | Symbol-Transformer | SYMBOL_TRANSFORMER |
| 智能缓存 | SMART_CACHE | Storage服务 | STORAGE |
| 通用缓存 | COMMON_CACHE | Shared组件 | SHARED |

### 组件功能对照说明
  - ALERT: 警告服务
  - AUTH: 认证服务
  - CACHE：缓存器服务
  - MONITORING：监控服务
  - NOTIFICATION：通知服务
  
  - SYMBOL-MAPPER : 符号映射规则组件
  - DATA-MAPPER : 数据映射器规则组件

  - QUERY: 慢时效查询组件
  - RECEIVER: 快时效查询组件
  - STREAM_RECEIVER: 流数据查询组件

  - DATA-FETCHER: SDK-REST 数据获取组件
  - STREAM-DATA-FETCHE: SDK-STREAM 数据获取组件

  - TRANSFORMER: 数据映射器规则执行器
  - SYMBOL-TRANSFORMER: 符号映射规则执行器

  - SMART-CACHE: 智能缓存导组件
  - COMMON-CACHE: 通用缓存组件
  - SYMBOL-MAPPER-CACHE: 符号映射规则专用缓存器
  - DATA-MAPPER-CACHE: 数据映射器规则专用缓存器
  - STREAM-CACHE: 流数据专用缓存器

  - STORAGE: 存储服务
  - SHARED: 共享组件

### 错误类别和序号范围
| 类别 | 代码 | 序号范围 | 说明 |
|------|------|----------|------|
| 验证类错误 | VALIDATION | 001-299 | 参数验证、格式验证、业务规则验证 |
| 业务逻辑错误 | BUSINESS | 300-599 | 业务流程、状态冲突、资源不存在 |
| 系统资源错误 | SYSTEM | 600-899 | 内存/CPU、超时、配置错误 |
| 外部依赖错误 | EXTERNAL | 900-999 | 数据库、第三方API、网络错误 |

### 错误码示例
```typescript
// Query组件错误码示例
export const QUERY_ERROR_CODES = {
  // 验证类 (001-299)
  MISSING_REQUIRED_PARAMS: 'QUERY_VALIDATION_001',
  INVALID_SYMBOLS_FORMAT: 'QUERY_VALIDATION_002',
  SYMBOLS_LIMIT_EXCEEDED: 'QUERY_VALIDATION_003',
  INVALID_DATE_RANGE: 'QUERY_VALIDATION_004',

  // 业务逻辑类 (300-599)
  UNSUPPORTED_QUERY_TYPE: 'QUERY_BUSINESS_300',
  QUERY_RESULT_EMPTY: 'QUERY_BUSINESS_301',
  DUPLICATE_QUERY_REQUEST: 'QUERY_BUSINESS_302',

  // 系统资源类 (600-899)
  MEMORY_PRESSURE: 'QUERY_SYSTEM_600',
  CPU_OVERLOAD: 'QUERY_SYSTEM_601',
  OPERATION_TIMEOUT: 'QUERY_SYSTEM_700',
  DATABASE_TIMEOUT: 'QUERY_SYSTEM_701',

  // 外部依赖类 (900-999)
  DATABASE_UNAVAILABLE: 'QUERY_EXTERNAL_900',
  CACHE_SERVICE_ERROR: 'QUERY_EXTERNAL_901',
  PROVIDER_UNAVAILABLE: 'QUERY_EXTERNAL_950',
  PROVIDER_RATE_LIMITED: 'QUERY_EXTERNAL_951',
} as const;
```

---

## 最佳实践

### ✅ 推荐做法

1. **统一错误消息语言**
   ```typescript
   // ✅ 使用英文错误消息
   'Symbols parameter cannot be empty'

   // ❌ 避免中文错误消息
   'symbols参数不能为空'
   ```

2. **提供丰富的上下文信息**
   ```typescript
   throw UniversalExceptionFactory.createBusinessException(
     'query',
     QUERY_ERROR_CODES.SYMBOLS_LIMIT_EXCEEDED,
     'validateSymbols',
     `Symbols count cannot exceed ${QUERY_LIMITS.MAX_SYMBOLS}`,
     {
       symbolCount,
       limit: QUERY_LIMITS.MAX_SYMBOLS,
       providedSymbols: symbols.slice(0, 5) // 提供部分示例
     }
   );
   ```

3. **合理设置重试性**
   ```typescript
   // ✅ 网络/连接错误：可重试
   throw UniversalExceptionFactory.createBusinessException(
     'provider',
     PROVIDER_ERROR_CODES.CONNECTION_FAILED,
     'fetchData',
     'Connection failed',
     { endpoint },
     true  // 可重试
   );

   // ✅ 验证错误：不可重试
   throw UniversalExceptionFactory.createBusinessException(
     'query',
     QUERY_ERROR_CODES.INVALID_SYMBOLS,
     'validateSymbols',
     'Invalid symbols format',
     { symbols },
     false  // 不可重试
   );
   ```

4. **在catch块中智能转换**
   ```typescript
   try {
     await externalService.getData();
   } catch (error) {
     // ✅ 使用智能转换，自动分类和判断重试性
     throw UniversalExceptionFactory.createFromError(
       error as Error,
       'fetchExternalData',
       'provider',
       { serviceEndpoint: 'https://api.example.com' }
     );
   }
   ```

### ❌ 避免的做法

1. **不要直接抛出Error**
   ```typescript
   // ❌ 避免
   throw new Error('Something went wrong');

   // ✅ 使用工厂方法
   throw UniversalExceptionFactory.createBusinessException(...);
   ```

2. **不要混用异常体系**
   ```typescript
   // ❌ 避免混用旧的异常类
   throw new BadRequestException('Invalid input');

   // ✅ 使用统一工厂
   throw UniversalExceptionFactory.createValidationError(...);
   ```

3. **不要忽略原始错误信息**
   ```typescript
   // ❌ 丢失原始错误信息
   try {
     await operation();
   } catch (error) {
     throw UniversalExceptionFactory.createBusinessException(
       'component', 'ERROR_CODE', 'op', 'Generic error'
     );
   }

   // ✅ 保留原始错误
   try {
     await operation();
   } catch (error) {
     throw UniversalExceptionFactory.createFromError(
       error as Error, 'operation', 'component'
     );
   }
   ```

---

## 组件迁移清单

### 每个组件需要完成的任务

1. **定义错误码常量** ⭐ 必需
   - 创建 `src/{component}/constants/{component}-error-codes.constants.ts`
   - 按照四层分类定义错误码

2. **替换throw语句** ⭐ 必需
   - 将所有 `throw new Error()` 替换为工厂方法
   - 将所有通用异常替换为BusinessException

3. **统一错误消息语言** ⭐ 必需
   - 所有错误消息使用英文
   - 消除中英文混用

4. **添加上下文信息** 🔧 推荐
   - 为异常添加丰富的上下文信息
   - 有助于问题排查和监控

5. **集成重试机制** 🔧 推荐
   - 对外部依赖调用使用重试机制
   - 提升系统稳定性

### 迁移验证清单

- [ ] 错误码常量已定义并符合命名规范
- [ ] 所有 `throw new Error` 已替换
- [ ] 所有 `BadRequestException`/`NotFoundException` 等已替换
- [ ] 错误消息统一使用英文
- [ ] 重要操作已集成重试机制
- [ ] TypeScript编译无错误
- [ ] 现有测试用例仍能通过

---

## 自动获得的能力

使用统一错误处理体系后，组件将自动获得以下能力：

### 🎯 错误处理能力
- ✅ 智能错误分类和HTTP状态码映射
- ✅ 统一的错误响应格式
- ✅ 错误恢复建议（retry/fallback/abort）
- ✅ 原始错误信息保留

### 🔄 重试机制
- ✅ 指数退避算法
- ✅ 抖动防雷群效应
- ✅ 基于错误类型的智能重试判断
- ✅ 详细的重试统计和日志

### 📊 监控集成
- ✅ 自动发送监控事件到现有监控系统
- ✅ 错误统计和趋势分析
- ✅ 详细的错误上下文记录
- ✅ 敏感信息自动过滤

### 🛡️ 安全防护
- ✅ 错误信息脱敏
- ✅ 生产环境堆栈信息过滤
- ✅ 敏感路径信息过滤
- ✅ 防止信息泄露

---

## 技术支持

### 常见问题

**Q: 如何判断错误是否应该设置为可重试？**
A:
- 网络错误、连接超时、服务暂时不可用 → 可重试
- 验证错误、权限错误、数据格式错误 → 不可重试
- 不确定时使用 `createFromError` 让工厂自动判断

**Q: 组件名应该如何命名？**
A: 使用组件代码对照表中的标准名称，如 'query'、'cache'、'auth' 等

**Q: 如何处理异步操作的错误？**
A: 在 catch 块中使用 `createFromError` 进行智能转换，或使用 `UniversalRetryHandler` 包装整个异步操作

### 联系方式
- 技术问题：通过Issues提交
- 紧急问题：联系项目维护团队
- 文档更新：提交PR到docs目录

---

**文档版本**: v1.0
**最后更新**: 2025-09-21
**适用版本**: 统一错误处理基础设施 v1.0+