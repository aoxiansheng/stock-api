# 日志系统规范化指南

## 📖 概述

本指南基于系统现有的全局分级日志控制系统，旨在规范各组件的日志使用，解决当前存在的高频日志性能问题、格式不统一等问题，确保日志系统在提供调试能力的同时不影响系统性能。

## 🎯 核心原则

### 1. 性能优先原则
- 生产环境日志不得影响核心业务性能
- 高频路径必须使用级别检查机制
- 避免在日志中进行复杂对象序列化

### 2. 信息有效原则
- 每条日志必须有明确的调试或监控价值
- 避免冗余和重复信息
- 关键业务流程必须有完整的日志链路

### 3. 格式统一原则
- 统一使用英文描述
- 标准化结构化数据格式
- 一致的组件和操作标识

## 📋 强制性规范

### 1. 日志器初始化 (MUST)

```typescript
// ✅ 标准初始化方式
import { createLogger } from '@common/logging/index';

@Injectable()
export class MyService {
  private readonly logger = createLogger(MyService.name);
  // 或使用模块化命名
  private readonly logger = createLogger('cache.symbol-mapper');
}
```

**禁止事项:**
```typescript
// ❌ 禁止直接使用console
console.log('Debug info');

// ❌ 禁止使用@nestjs/common Logger
import { Logger } from '@nestjs/common';
```

> 说明：上述限制适用于业务代码。日志模块内部为避免循环依赖，可按需使用 `console` 输出初始化或降级信息。

### 2. 统一日志格式 (MUST)

#### 标准消息格式
```
[Component]: [Operation] | [Status/Result]
```

#### 结构化数据格式
```typescript
{
  component: string,      // 组件名称 (必需)
  operation: string,      // 操作名称 (必需)
  status?: string,        // 操作状态
  duration?: number,      // 执行时长(ms)
  timestamp?: string,     // 时间戳
  metadata?: object       // 其他上下文数据
}
```

#### 实践示例
```typescript
// ✅ 标准格式示例
this.logger.info('SymbolMapper: batch processing completed', {
  component: 'SymbolMapper',
  operation: 'batchProcess',
  status: 'success',
  symbolCount: 150,
  duration: 45,
  timestamp: new Date().toISOString()
});

// ✅ 错误日志格式
this.logger.error('CacheService: redis connection failed', {
  component: 'CacheService',
  operation: 'connect',
  status: 'failed',
  error: error.message,
  stack: error.stack,
  retryCount: 3
});
```

### 3. 性能敏感路径处理 (MUST)

**高频操作必须使用级别检查:**

```typescript
import { shouldLog } from '@common/logging/index';

// ✅ 正确的高频日志处理
if (shouldLog(CacheService.name, 'debug')) {
  const performanceData = this.calculateMetrics(); // 昂贵操作
  this.logger.debug('Performance: cache metrics calculated', {
    component: 'CacheService',
    operation: 'calculateMetrics',
    ...performanceData
  });
}

// 提示：shouldLog 会复用当前日志级别控制器；当增强控制未启用时会回退为始终返回 true。

// ❌ 错误的高频日志处理
this.logger.debug('Cache metrics', this.calculateMetrics()); // 总是执行昂贵操作
```

> 建议：调用 `shouldLog` 时传入与 `createLogger` 相同的上下文名称，便于级别配置精确匹配。

**高频路径识别标准:**
- 每秒调用超过10次的方法
- 缓存操作、数据库查询
- WebSocket事件处理
- 定时任务和监控检查

### 4. 日志级别使用规范 (MUST)

#### 级别定义与使用场景

| 级别 | 使用场景 | 频率限制 | 示例 |
|------|----------|----------|------|
| `error` | 系统错误、异常处理 | 无限制 | 数据库连接失败、API调用异常 |
| `warn` | 潜在问题、降级处理 | 每分钟<100次 | 缓存未命中、请求超时 |
| `info` | 关键业务流程、状态变更 | 每分钟<50次 | 用户认证成功、数据同步完成 |
| `debug` | 调试信息、详细流程 | 必须使用级别检查 | 中间处理步骤、参数验证 |

#### 具体使用规范

```typescript
// ✅ error级别 - 必须记录的错误
try {
  await this.databaseService.save(data);
} catch (error) {
  this.logger.error('Database: save operation failed', {
    component: 'DatabaseService',
    operation: 'save',
    error: error.message,
    stack: error.stack,
    data: sanitizeData(data)
  });
  throw error;
}

// ✅ warn级别 - 业务警告
if (cacheHitRate < 0.7) {
  this.logger.warn('Cache: hit rate below threshold', {
    component: 'CacheService',
    operation: 'checkPerformance',
    hitRate: cacheHitRate,
    threshold: 0.7
  });
}

// ✅ info级别 - 关键业务节点
this.logger.info('Auth: user authentication successful', {
  component: 'AuthService',
  operation: 'authenticate',
  userId: user.id,
  method: 'jwt'
});

// ✅ debug级别 - 开发调试信息
if (shouldLog(DataTransformer.name, 'debug')) {
  this.logger.debug('Transformer: data mapping initiated', {
    component: 'DataTransformer',
    operation: 'mapFields',
    inputFields: Object.keys(rawData),
    mappingRules: rules.length
  });
}
```

## ⚙️ 配置管理规范

### 1. 环境特定配置

#### 开发环境 (.env.development)
```bash
NODE_ENV=development
LOG_LEVEL=debug
LOG_PERFORMANCE_MODE=false
LOG_CONFIG_DEBUG=true
```

#### 测试环境 (.env.test)
```bash
NODE_ENV=test
LOG_LEVEL=error
DYNAMIC_LOG_LEVEL=false
```

#### 生产环境 (.env.production)
```bash
NODE_ENV=production
LOG_LEVEL=warn
LOG_PERFORMANCE_MODE=true
LOG_TO_FILE=true
```

### 2. 组件级别配置 (config/log-levels.json)

```json
{
  "global": "info",
  "modules": {
    "// 高频组件 - 保守配置": "=================",
    "SymbolMapperService": "warn",
    "CacheService": "warn",
    "StreamDataFetcher": "warn",
    "MonitoringEventBridge": "error",

    "// 业务组件 - 标准配置": "=================",
    "AuthService": "info",
    "TransformerService": "info",
    "StorageService": "info",

    "// 低频组件 - 详细配置": "=================",
    "ConfigService": "debug",
    "InitializationService": "debug"
  },
  "namespaces": {
    "*Controller": "info",
    "*Repository": "warn",
    "*Guard": "warn",
    "Monitor*": "warn",
    "*Cache*": "warn"
  }
}
```

### 3. 动态调整机制

#### 问题排查时临时启用
```bash
# 临时启用特定组件详细日志
export LOG_LEVEL_OVERRIDE_MODULE=ProblematicService:debug

# 使用API动态调整
curl -X PUT http://localhost:3000/api/admin/log-levels/module/AuthService/debug
```

## 🚫 禁止事项

### 1. 绝对禁止的做法

```typescript
// ❌ 在循环中无条件记录debug日志
for (const item of items) {
  this.logger.debug('Processing item', item); // 可能产生大量日志
}

// ❌ 记录敏感信息
this.logger.info('User login', {
  password: user.password,  // 敏感信息
  apiKey: user.apiKey
});

// ❌ 在高频方法中记录info级别日志
public async getCachedData(key: string) {
  this.logger.info('Cache access', { key }); // 每次调用都记录
  return this.cache.get(key);
}

// ❌ 记录过大的对象
this.logger.debug('Full response', {
  response: massiveResponseObject // 可能包含MB级数据
});
```

### 2. 应当避免的模式

```typescript
// ⚠️ 避免字符串拼接
this.logger.info(`Processing ${count} items for user ${userId}`);
// 改为结构化格式
this.logger.info('Processing: items batch initiated', {
  component: 'ProcessingService',
  operation: 'batchProcess',
  itemCount: count,
  userId
});

// ⚠️ 避免中文描述
this.logger.debug('用户认证成功', { userId });
// 使用英文
this.logger.debug('Auth: user authentication successful', {
  component: 'AuthService',
  userId
});
```

## 📊 性能监控与质量保证

### 1. 日志性能监控指标

#### 关键指标阈值
- **日志频率**: 生产环境每秒不超过100条
- **单条日志大小**: 不超过1KB
- **日志处理延迟**: 不超过1ms
- **序列化开销**: debug级别不影响主流程性能

#### 监控实现
```typescript
// 集成到现有监控系统
export class LogPerformanceMonitor {
  static trackLogPerformance(component: string, level: string, size: number) {
    if (level === 'debug' && size > 1024) {
      console.warn(`Large debug log detected: ${component}, size: ${size}B`);
    }
  }
}
```

### 2. 代码审查检查清单

#### 必检项目
- [ ] 是否使用 `createLogger` 初始化
- [ ] 高频路径是否使用 `shouldLog(context, 'debug')` 检查
- [ ] 日志格式是否符合 `[Component]: [Operation] | [Status]` 规范
- [ ] 结构化数据是否包含必需的 `component` 和 `operation` 字段
- [ ] 敏感信息是否已脱敏处理
- [ ] debug级别日志是否有业务价值

#### 性能检查
- [ ] 是否在循环中无条件记录日志
- [ ] 是否记录过大的对象（>1KB）
- [ ] 高频方法是否使用了合适的日志级别

## 🛠️ 工具与自动化

### 1. ESLint规则配置

```json
{
  "rules": {
    "no-console": "error",
    "@typescript-eslint/no-unused-vars": ["error", {
      "varsIgnorePattern": "logger"
    }],
    "custom/logger-format": "error",
    "custom/sensitive-data-logging": "error"
  }
}
```

### 2. 日志格式验证工具

```typescript
// 开发工具：日志格式验证器
export function validateLogFormat(message: string, data: any): boolean {
  const formatRegex = /^[A-Za-z]+: [A-Za-z]+ \| [A-Za-z]+$/;
  const hasRequiredFields = data?.component && data?.operation;

  return formatRegex.test(message) && hasRequiredFields;
}
```

### 3. 性能分析脚本

```bash
#!/bin/bash
# 分析日志性能影响
echo "分析日志频率..."
grep -c "DEBUG\|INFO" logs/app.log | head -10

echo "检查大日志..."
grep -E ".{1000,}" logs/app.log | wc -l

echo "统计组件日志分布..."
grep -oE "component.*:[^,}]*" logs/app.log | sort | uniq -c | sort -nr
```

## 📋 迁移指导

### 1. 现有代码迁移步骤

#### 第一阶段：基础迁移
1. 替换日志器初始化方式
2. 统一日志消息格式
3. 添加结构化数据字段

#### 第二阶段：性能优化
1. 识别高频日志路径
2. 添加级别检查机制
3. 调整日志级别配置

#### 第三阶段：监控完善
1. 集成性能监控
2. 建立质量检查机制
3. 完善文档和培训

### 2. 具体迁移示例

#### 迁移前
```typescript
// 原始代码
console.log('Processing symbols:', symbols);
this.logger.debug('缓存命中', { key, value });
this.logger.info(`用户${userId}登录成功`);
```

#### 迁移后
```typescript
import { createLogger, shouldLog } from '@common/logging/index';

// 标准化后
private readonly logger = createLogger(SymbolMapperService.name);

if (shouldLog(SymbolMapperService.name, 'debug')) {
  this.logger.debug('SymbolMapper: processing initiated', {
    component: 'SymbolMapper',
    operation: 'processSymbols',
    symbolCount: symbols.length
  });
}

this.logger.debug('Cache: hit successful', {
  component: 'CacheService',
  operation: 'get',
  key,
  hitType: 'memory'
});

this.logger.info('Auth: user login successful', {
  component: 'AuthService',
  operation: 'login',
  userId,
  method: 'jwt'
});
```

## 🔍 问题排查指南

### 1. 常见问题及解决方案

#### 问题：日志未输出
```bash
# 检查配置
cat config/log-levels.json | grep "MyService"
echo $LOG_LEVEL_OVERRIDE_MODULE

# 验证logger名称
# 在代码中临时添加
console.log('Logger context:', this.constructor.name);
```

#### 问题：性能下降
```bash
# 启用性能模式
export LOG_PERFORMANCE_MODE=true

# 调整级别
export LOG_LEVEL_OVERRIDE_MODULE=HighFrequencyService:warn
```

#### 问题：日志过多
```bash
# 批量调整命名空间
curl -X PUT http://localhost:3000/api/admin/log-levels/namespace/*Service/warn
```

### 2. 应急处理方案

#### 生产环境日志暴增
```bash
# 紧急降级所有debug日志
export LOG_LEVEL=warn

# 重启应用使配置生效
systemctl restart app-service

# 临时禁用特定高频组件
export LOG_LEVEL_OVERRIDE_MODULE=ProblematicService:error
```

## 📚 参考资源

### 1. 相关文档
- [全局分级日志使用说明文档](./src/common/modules/logging/全局分级日志使用说明文档.md)
- [日志规范开发使用文档](./src/common/modules/logging/日志规范开发使用文档.md)
- [日志问题案例](./docs/代码审查文档/日志问题案例.md)

### 2. 配置模板
- [基础配置模板](./config/log-levels.json)
- [开发环境配置](./config/log-levels.development.json)
- [生产环境配置](./config/log-levels.production.json)

### 3. 工具链
- ESLint日志规则配置
- 日志格式验证工具
- 性能监控脚本

---

**版本**: 1.0.0
**生效日期**: 2024-01-11
**适用范围**: 所有backend组件
**维护责任**: 架构组

---

## 📧 反馈与支持

- **规范问题**: 提交GitHub Issue
- **工具改进**: 创建Pull Request
- **紧急支持**: 联系架构组

**注意**: 本规范为强制性标准，所有新代码和重构代码必须严格遵循。
