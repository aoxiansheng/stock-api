# 跨组件重复问题 - 详细修复实施方案

## 1. StorageClassification 枚举冲突修复方案

### 1.1 问题现状

目前存在两个不同版本的 `StorageClassification` 枚举：

| 文件位置 | 枚举值数量 | 独有值 |
|---------|-----------|--------|
| `/Users/honor/Documents/code/newstockapi/backend/src/core/shared/types/field-naming.types.ts` | 19个 | TRADING_DAYS, GLOBAL_STATE, CRYPTO_QUOTE, CRYPTO_BASIC_INFO, STOCK_LOGO, CRYPTO_LOGO, STOCK_NEWS, CRYPTO_NEWS |
| `/Users/honor/Documents/code/newstockapi/backend/src/core/04-storage/storage/enums/storage-type.enum.ts` | 11个 | 无独有值 |

### 1.2 详细修复步骤

#### 步骤1: 创建统一枚举文件

**文件位置**: `/Users/honor/Documents/code/newstockapi/backend/src/core/shared/types/storage-classification.enum.ts`

> **架构决策说明**: 
> StorageClassification 放置在 `core/shared/types` 而非 `common/enums` 的原因：
> - 🔒 **封装性**: 100%使用场景都在Core内部7个组件
> - 📍 **问题本地化**: 重复定义发生在core内部，应在同层级解决  
> - 🏗️ **架构一致性**: 与现有 `core/shared/types/field-naming.types.ts` 保持一致
> - ❌ **外部无依赖**: alert、auth、cache、monitoring、providers等模块完全不使用

```typescript
/**
 * 统一的存储分类枚举定义
 * 
 * @description 定义系统中所有数据存储分类类型
 * @since 2024-01
 */
export enum StorageClassification {
  // ========== 股票相关数据 ==========
  /** 股票实时报价 */
  STOCK_QUOTE = "stock_quote",
  
  /** 股票K线数据 */
  STOCK_CANDLE = "stock_candle",
  
  /** 股票逐笔数据 */
  STOCK_TICK = "stock_tick",
  
  /** 财务报表 */
  FINANCIAL_STATEMENT = "financial_statement",
  
  /** 股票基本信息 */
  STOCK_BASIC_INFO = "stock_basic_info",
  
  /** 股票新闻 */
  STOCK_NEWS = "stock_news",
  
  /** 股票Logo */
  STOCK_LOGO = "stock_logo",

  // ========== 市场相关数据 ==========
  /** 市场新闻 */
  MARKET_NEWS = "market_news",
  
  /** 市场状态 */
  MARKET_STATUS = "market_status",
  
  /** 指数报价 */
  INDEX_QUOTE = "index_quote",
  
  /** 交易日历 */
  TRADING_DAYS = "trading_days",
  
  /** 全局状态 */
  GLOBAL_STATE = "global_state",

  // ========== 加密货币相关数据 ==========
  /** 加密货币报价 */
  CRYPTO_QUOTE = "crypto_quote",
  
  /** 加密货币基本信息 */
  CRYPTO_BASIC_INFO = "crypto_basic_info",
  
  /** 加密货币Logo */
  CRYPTO_LOGO = "crypto_logo",
  
  /** 加密货币新闻 */
  CRYPTO_NEWS = "crypto_news",

  // ========== 交易相关数据 ==========
  /** 交易订单 */
  TRADING_ORDER = "trading_order",
  
  /** 用户投资组合 */
  USER_PORTFOLIO = "user_portfolio",

  // ========== 通用分类 ==========
  /** 通用/未分类数据 */
  GENERAL = "general",
}

/**
 * 存储分类辅助函数
 */
export const StorageClassificationHelper = {
  /**
   * 检查是否为股票相关分类
   */
  isStockRelated(classification: StorageClassification): boolean {
    return [
      StorageClassification.STOCK_QUOTE,
      StorageClassification.STOCK_CANDLE,
      StorageClassification.STOCK_TICK,
      StorageClassification.STOCK_BASIC_INFO,
      StorageClassification.STOCK_NEWS,
      StorageClassification.STOCK_LOGO,
      StorageClassification.FINANCIAL_STATEMENT,
    ].includes(classification);
  },

  /**
   * 检查是否为加密货币相关分类
   */
  isCryptoRelated(classification: StorageClassification): boolean {
    return [
      StorageClassification.CRYPTO_QUOTE,
      StorageClassification.CRYPTO_BASIC_INFO,
      StorageClassification.CRYPTO_LOGO,
      StorageClassification.CRYPTO_NEWS,
    ].includes(classification);
  },

  /**
   * 检查是否为市场相关分类
   */
  isMarketRelated(classification: StorageClassification): boolean {
    return [
      StorageClassification.MARKET_NEWS,
      StorageClassification.MARKET_STATUS,
      StorageClassification.INDEX_QUOTE,
      StorageClassification.TRADING_DAYS,
      StorageClassification.GLOBAL_STATE,
    ].includes(classification);
  },

  /**
   * 获取分类的显示名称
   */
  getDisplayName(classification: StorageClassification): string {
    const names: Record<StorageClassification, string> = {
      [StorageClassification.STOCK_QUOTE]: "股票报价",
      [StorageClassification.STOCK_CANDLE]: "K线数据",
      [StorageClassification.STOCK_TICK]: "逐笔数据",
      [StorageClassification.FINANCIAL_STATEMENT]: "财务报表",
      [StorageClassification.STOCK_BASIC_INFO]: "股票基本信息",
      [StorageClassification.STOCK_NEWS]: "股票新闻",
      [StorageClassification.STOCK_LOGO]: "股票Logo",
      [StorageClassification.MARKET_NEWS]: "市场新闻",
      [StorageClassification.MARKET_STATUS]: "市场状态",
      [StorageClassification.INDEX_QUOTE]: "指数报价",
      [StorageClassification.TRADING_DAYS]: "交易日历",
      [StorageClassification.GLOBAL_STATE]: "全局状态",
      [StorageClassification.CRYPTO_QUOTE]: "加密货币报价",
      [StorageClassification.CRYPTO_BASIC_INFO]: "加密货币信息",
      [StorageClassification.CRYPTO_LOGO]: "加密货币Logo",
      [StorageClassification.CRYPTO_NEWS]: "加密货币新闻",
      [StorageClassification.TRADING_ORDER]: "交易订单",
      [StorageClassification.USER_PORTFOLIO]: "投资组合",
      [StorageClassification.GENERAL]: "通用",
    };
    return names[classification] || classification;
  },
};
```

#### 步骤2: 创建导出索引文件

**文件位置**: `/Users/honor/Documents/code/newstockapi/backend/src/core/shared/index.ts`

```typescript
/**
 * 统一枚举导出
 */
export { StorageClassification, StorageClassificationHelper } from './storage-classification.enum';

// 未来可以添加其他共享枚举
// export { ... } from './other-enum';
```

#### 步骤3: 更新 shared 组件引用

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/core/shared/types/field-naming.types.ts`

```typescript
/**
 * 字段命名重构相关的类型定义
 * 用于统一管理和映射不同组件间的字段关系
 */

// 从统一位置导入
import { StorageClassification } from './storage-classification.enum';

// 删除原有的 StorageClassification 枚举定义
// export enum StorageClassification { ... }  // 删除这部分

// Receiver 组件的能力类型
export type ReceiverType = 
  | "get-stock-quote"
  | "get-stock-basic-info"
  // ... 保持其他内容不变

// 重新导出以保持向后兼容
export { StorageClassification };
```

#### 步骤4: 更新 storage 组件引用

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/core/04-storage/storage/enums/storage-type.enum.ts`

```typescript
/**
 * 存储类型枚举
 */
export enum StorageType {
  STORAGETYPECACHE = "storagetype_cache",
  PERSISTENT = "persistent",
  BOTH = "both",
}

// 从统一位置导入并重新导出
import { StorageClassification } from '../../../shared/types/storage-classification.enum';
export { StorageClassification };

// 删除原有的 StorageClassification 枚举定义
// export enum StorageClassification { ... }  // 删除这部分
```

#### 步骤5: 更新 tsconfig paths

**文件**: `/Users/honor/Documents/code/newstockapi/backend/tsconfig.json`

```json
{
  "compilerOptions": {
    // ... 其他配置
    "paths": {
      "@core/shared": ["src/core/shared/index"],
      "@core/shared/*": ["src/core/shared/*"],
      // ... 其他路径映射
    }
  }
}
```

#### 步骤6: 批量更新导入语句

执行以下脚本批量更新所有文件的导入语句：

```bash
#!/bin/bash
# 文件位置: /Users/honor/Documents/code/newstockapi/backend/scripts/fix-storage-classification-imports.sh

# 查找并替换 shared 组件的导入
find ./src -type f -name "*.ts" -exec grep -l "from.*shared/types/field-naming.*StorageClassification" {} \; | while read file; do
  echo "Updating import in: $file"
  # 如果文件只导入 StorageClassification
  sed -i '' "s|import { StorageClassification } from '.*shared/types/field-naming.*'|import { StorageClassification } from './storage-classification.enum'|g" "$file"
  # 如果文件导入多个内容
  sed -i '' "s|import { \(.*\), StorageClassification, \(.*\) } from '.*shared/types/field-naming.*'|import { \1, \2 } from '.*shared/types/field-naming.*';\nimport { StorageClassification } from './storage-classification.enum'|g" "$file"
done

# 查找并替换 storage 组件的导入
find ./src -type f -name "*.ts" -exec grep -l "from.*storage/enums/storage-type.*StorageClassification" {} \; | while read file; do
  echo "Updating import in: $file"
  sed -i '' "s|import { StorageClassification } from '.*storage/enums/storage-type.*'|import { StorageClassification } from '../../shared/types/storage-classification.enum'|g" "$file"
done
```

---

## 2. LayerType DTO 内部重复修复方案

### 2.1 问题现状

`LayerType` 枚举在两个位置重复定义：
1. `/Users/honor/Documents/code/newstockapi/backend/src/monitoring/contracts/enums/layer-type.enum.ts`
2. `/Users/honor/Documents/code/newstockapi/backend/src/monitoring/contracts/dto/layer-metrics.dto.ts`

### 2.2 详细修复步骤

#### 步骤1: 修改 layer-metrics.dto.ts

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/monitoring/contracts/dto/layer-metrics.dto.ts`

```typescript
import { IsDate, IsNumber, IsString, IsOptional, ValidateNested, IsEnum } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
// 导入统一的 LayerType 枚举
import { LayerType } from '../enums/layer-type.enum';

/**
 * 层间性能指标DTO定义
 * 用于监控各层之间的性能表现
 */

// 删除重复的枚举定义
// export enum LayerType {
//   COLLECTOR = 'collector',
//   ANALYZER = 'analyzer',
//   PRESENTER = 'presenter'
// }

export enum OperationType {
  DATA_COLLECTION = 'data_collection',
  DATA_ANALYSIS = 'data_analysis',
  CACHE_OPERATION = 'cache_operation',
  DATABASE_OPERATION = 'database_operation',
  // ... 其他操作类型
}

export class LayerMetricsDto {
  @ApiProperty({ 
    enum: LayerType,
    description: '层类型',
    example: LayerType.COLLECTOR
  })
  @IsEnum(LayerType)
  sourceLayer: LayerType;

  @ApiProperty({ 
    enum: LayerType,
    description: '目标层类型',
    example: LayerType.ANALYZER
  })
  @IsEnum(LayerType)
  targetLayer: LayerType;

  // ... 其他字段
}
```

#### 步骤2: 验证所有引用位置

```bash
#!/bin/bash
# 文件位置: /Users/honor/Documents/code/newstockapi/backend/scripts/verify-layer-type-imports.sh

echo "Checking LayerType imports..."

# 查找所有引用 LayerType 的文件
grep -r "LayerType" ./src/monitoring --include="*.ts" | while read -r line; do
  file=$(echo "$line" | cut -d: -f1)
  echo "Found reference in: $file"
  
  # 检查是否从正确位置导入
  if grep -q "from.*layer-metrics.dto.*LayerType" "$file"; then
    echo "  ⚠️  WARNING: Importing LayerType from layer-metrics.dto"
    echo "  Should import from: '../enums/layer-type.enum'"
  fi
done
```

---

## 3. CacheStatsDto 命名冲突修复方案

### 3.1 问题现状

存在两个不同语义的 `CacheStatsDto`：
1. `/Users/honor/Documents/code/newstockapi/backend/src/cache/dto/cache-internal.dto.ts`
2. `/Users/honor/Documents/code/newstockapi/backend/src/core/05-caching/common-cache/dto/cache-result.dto.ts`

### 3.2 详细修复步骤

#### 步骤1: 重命名 cache 组件的 DTO

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/cache/dto/cache-internal.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsNumber, IsOptional, IsString } from 'class-validator';

/**
 * Redis 缓存运行时统计 DTO
 * @renamed 从 CacheStatsDto 重命名以避免命名冲突
 */
export class RedisCacheRuntimeStatsDto {
  @ApiProperty({ description: '缓存命中次数' })
  @IsNumber()
  hits: number;

  @ApiProperty({ description: '缓存未命中次数' })
  @IsNumber()
  misses: number;

  @ApiProperty({ description: '缓存命中率' })
  @IsNumber()
  hitRate: number;

  @ApiProperty({ description: '内存使用量（字节）' })
  @IsNumber()
  memoryUsage: number;

  @ApiProperty({ description: '缓存键数量' })
  @IsNumber()
  keyCount: number;

  @ApiProperty({ description: '平均TTL（秒）' })
  @IsNumber()
  avgTtl: number;
}

// 保留原名称的类型别名以保持向后兼容（标记为废弃）
/**
 * @deprecated 使用 RedisCacheRuntimeStatsDto 替代
 */
export type CacheStatsDto = RedisCacheRuntimeStatsDto;
```

#### 步骤2: 更新 cache.service.ts

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/cache/services/cache.service.ts`

```typescript
import { 
  RedisCacheRuntimeStatsDto,
  // CacheStatsDto // 删除旧导入
} from '../dto/cache-internal.dto';

export class CacheService {
  // ... 其他代码

  /**
   * 获取缓存统计信息
   */
  async getStats(): Promise<RedisCacheRuntimeStatsDto> {
    // 更新返回类型
    const stats = new RedisCacheRuntimeStatsDto();
    
    // ... 统计逻辑
    
    return stats;
  }

  // ... 其他方法
}
```

#### 步骤3: 创建迁移指南

**文件**: `/Users/honor/Documents/code/newstockapi/backend/docs/migration/cache-stats-dto-rename.md`

```markdown
# CacheStatsDto 重命名迁移指南

## 背景
为解决命名冲突问题，`cache` 模块的 `CacheStatsDto` 已重命名为 `RedisCacheRuntimeStatsDto`。

## 影响范围
- `/src/cache/dto/cache-internal.dto.ts`
- `/src/cache/services/cache.service.ts`
- 所有引用 `CacheStatsDto` 的外部模块

## 迁移步骤

### 1. 更新导入语句
```typescript
// 旧代码
import { CacheStatsDto } from '@cache/dto/cache-internal.dto';

// 新代码
import { RedisCacheRuntimeStatsDto } from '@cache/dto/cache-internal.dto';
```

### 2. 更新类型声明
```typescript
// 旧代码
let stats: CacheStatsDto;

// 新代码
let stats: RedisCacheRuntimeStatsDto;
```

### 3. 更新函数签名
```typescript
// 旧代码
async getStats(): Promise<CacheStatsDto> {

// 新代码
async getStats(): Promise<RedisCacheRuntimeStatsDto> {
```

## 兼容性说明
为保持向后兼容，暂时保留了类型别名：
```typescript
export type CacheStatsDto = RedisCacheRuntimeStatsDto;
```

此别名将在下个主版本中移除。
```

---

## 4. 时间字段命名统一方案

### 4.1 问题现状

处理时间字段命名不一致：
- `processingTime: number`
- `processingTimeMs: number`
- `timestamp: string`（显示用途）

### 4.2 详细修复步骤

#### 步骤1: 创建统一的时间字段接口

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/common/interfaces/time-fields.interface.ts`

```typescript
/**
 * 标准时间字段接口定义
 */

/**
 * 标准时间戳字段
 */
export interface StandardTimestamps {
  /** 创建时间 */
  createdAt: Date;
  
  /** 更新时间 */
  updatedAt: Date;
}

/**
 * 处理时间字段
 */
export interface ProcessingTimeFields {
  /** 处理耗时（毫秒） */
  processingTimeMs: number;
  
  /** 开始时间（可选） */
  startTime?: Date;
  
  /** 结束时间（可选） */
  endTime?: Date;
}

/**
 * 显示时间字段
 */
export interface DisplayTimeFields {
  /** ISO格式的时间戳字符串，用于显示 */
  timestamp: string;
}

/**
 * 时间字段辅助函数
 */
export class TimeFieldsHelper {
  /**
   * 计算处理耗时
   */
  static calculateProcessingTime(startTime: Date, endTime: Date = new Date()): number {
    return endTime.getTime() - startTime.getTime();
  }

  /**
   * 格式化为显示时间戳
   */
  static formatTimestamp(date: Date = new Date()): string {
    return date.toISOString();
  }

  /**
   * 将毫秒转换为可读格式
   */
  static formatDuration(ms: number): string {
    if (ms < 1000) return `${ms}ms`;
    if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;
    return `${(ms / 60000).toFixed(2)}m`;
  }
}
```

#### 步骤2: 更新 data-fetcher DTO

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/core/03-fetching/data-fetcher/dto/data-fetch-metadata.dto.ts`

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { ProcessingTimeFields } from '../../../../common/interfaces/time-fields.interface';

export class DataFetchMetadataDto implements Partial<ProcessingTimeFields> {
  @ApiProperty({ description: '数据提供商' })
  provider: string;

  @ApiProperty({ description: '能力类型' })
  capability: string;

  @ApiProperty({ description: '成功处理的符号数量' })
  symbolsProcessed: number;

  @ApiProperty({ description: '失败的符号列表' })
  failedSymbols: string[];

  @ApiProperty({ description: '错误信息列表' })
  errors: string[];

  // 重命名字段以符合标准
  @ApiProperty({ 
    description: '处理耗时（毫秒）',
    example: 1500
  })
  processingTimeMs: number;  // 从 processingTime 重命名

  // 向后兼容的 getter（标记为废弃）
  /**
   * @deprecated 使用 processingTimeMs 替代
   */
  get processingTime(): number {
    return this.processingTimeMs;
  }

  set processingTime(value: number) {
    this.processingTimeMs = value;
  }
}
```

#### 步骤3: 更新 transformer DTO

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/core/02-processing/transformer/dto/data-transform-response.dto.ts`

```typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { ProcessingTimeFields, DisplayTimeFields } from '../../../../common/interfaces/time-fields.interface';

export class DataTransformationMetadataDto 
  implements Partial<ProcessingTimeFields>, DisplayTimeFields {
  
  @ApiProperty({ description: "Applied mapping rule ID" })
  ruleId: string;

  @ApiProperty({ description: "Applied mapping rule name" })
  ruleName: string;

  @ApiProperty({ description: "Data provider used" })
  provider: string;

  @ApiProperty({ description: "Data rule list type" })
  transDataRuleListType: string;

  @ApiProperty({ description: "Number of records processed" })
  recordsProcessed: number;

  @ApiProperty({ description: "Number of fields transformed" })
  fieldsTransformed: number;

  // 重命名字段
  @ApiProperty({
    description: "处理耗时（毫秒）",
    example: 250
  })
  processingTimeMs: number;  // 从 processingTime 重命名

  @ApiProperty({ 
    description: "转换时间戳（ISO格式）",
    example: "2024-01-15T10:30:00.000Z"
  })
  timestamp: string;  // 保留用于显示

  @ApiPropertyOptional({ description: "Applied transformations details" })
  transformationsApplied?: Array<{
    sourceField: string;
    targetField: string;
    transformType?: string;
    transformValue?: any;
  }>;

  constructor(
    ruleId: string,
    ruleName: string,
    provider: string,
    transDataRuleListType: string,
    recordsProcessed: number,
    fieldsTransformed: number,
    processingTimeMs: number,  // 更新参数名
    transformationsApplied?: Array<{
      sourceField: string;
      targetField: string;
      transformType?: string;
      transformValue?: any;
    }>,
  ) {
    this.ruleId = ruleId;
    this.ruleName = ruleName;
    this.provider = provider;
    this.transDataRuleListType = transDataRuleListType;
    this.recordsProcessed = recordsProcessed;
    this.fieldsTransformed = fieldsTransformed;
    this.processingTimeMs = processingTimeMs;
    this.timestamp = new Date().toISOString();
    this.transformationsApplied = transformationsApplied;
  }

  // 向后兼容
  /**
   * @deprecated 使用 processingTimeMs 替代
   */
  get processingTime(): number {
    return this.processingTimeMs;
  }
}
```

---

## 5. 统计字段标准化方案

### 5.1 创建统一的统计接口

**文件**: `/Users/honor/Documents/code/newstockapi/backend/src/common/interfaces/statistics-fields.interface.ts`

```typescript
/**
 * 标准统计字段接口定义
 */

/**
 * 缓存统计字段
 */
export interface CacheStatistics {
  /** 缓存命中次数 */
  hits: number;
  
  /** 缓存未命中次数 */
  misses: number;
  
  /** 缓存命中率（0-1之间的小数） */
  hitRate: number;
}

/**
 * 处理统计字段
 */
export interface ProcessingStatistics {
  /** 总处理数量 */
  totalCount: number;
  
  /** 成功数量 */
  successCount: number;
  
  /** 失败数量 */
  failureCount: number;
  
  /** 成功率（0-1之间的小数） */
  successRate: number;
}

/**
 * 扩展缓存统计（包含Redis特有信息）
 */
export interface ExtendedCacheStatistics extends CacheStatistics {
  /** 内存使用量（字节） */
  memoryUsage: number;
  
  /** 缓存键数量 */
  keyCount: number;
  
  /** 平均TTL（秒） */
  avgTtl: number;
  
  /** 总操作次数 */
  totalOperations: number;
  
  /** 平均响应时间（毫秒） */
  averageResponseTime?: number;
}

/**
 * 统计辅助函数
 */
export class StatisticsHelper {
  /**
   * 计算命中率
   */
  static calculateHitRate(hits: number, misses: number): number {
    const total = hits + misses;
    return total === 0 ? 0 : hits / total;
  }

  /**
   * 计算成功率
   */
  static calculateSuccessRate(successCount: number, failureCount: number): number {
    const total = successCount + failureCount;
    return total === 0 ? 0 : successCount / total;
  }

  /**
   * 格式化百分比
   */
  static formatPercentage(rate: number, decimals: number = 2): string {
    return `${(rate * 100).toFixed(decimals)}%`;
  }

  /**
   * 创建默认缓存统计对象
   */
  static createDefaultCacheStats(): CacheStatistics {
    return {
      hits: 0,
      misses: 0,
      hitRate: 0,
    };
  }

  /**
   * 创建默认处理统计对象
   */
  static createDefaultProcessingStats(): ProcessingStatistics {
    return {
      totalCount: 0,
      successCount: 0,
      failureCount: 0,
      successRate: 0,
    };
  }
}
```

---

## 6. 验证和测试脚本

### 6.1 自动化验证脚本

**文件**: `/Users/honor/Documents/code/newstockapi/backend/scripts/verify-refactoring.sh`

```bash
#!/bin/bash

echo "========================================="
echo "跨组件重复问题修复验证脚本"
echo "========================================="

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 计数器
ERRORS=0
WARNINGS=0

# 1. 检查 StorageClassification 枚举
echo -e "\n${YELLOW}1. 检查 StorageClassification 枚举统一性${NC}"

if [ -f "src/core/shared/types/storage-classification.enum.ts" ]; then
  echo -e "${GREEN}✓ 统一枚举文件存在${NC}"
else
  echo -e "${RED}✗ 统一枚举文件不存在${NC}"
  ((ERRORS++))
fi

# 检查是否还有重复定义
DUPLICATE_ENUM=$(grep -r "export enum StorageClassification" ./src --include="*.ts" | wc -l)
if [ "$DUPLICATE_ENUM" -eq 1 ]; then
  echo -e "${GREEN}✓ 无重复的 StorageClassification 定义${NC}"
else
  echo -e "${RED}✗ 发现 $DUPLICATE_ENUM 个 StorageClassification 定义${NC}"
  grep -r "export enum StorageClassification" ./src --include="*.ts"
  ((ERRORS++))
fi

# 2. 检查 LayerType 重复
echo -e "\n${YELLOW}2. 检查 LayerType 枚举重复${NC}"

LAYERTYPE_COUNT=$(grep -r "export enum LayerType" ./src/monitoring --include="*.ts" | wc -l)
if [ "$LAYERTYPE_COUNT" -eq 1 ]; then
  echo -e "${GREEN}✓ LayerType 只有一个定义${NC}"
else
  echo -e "${RED}✗ 发现 $LAYERTYPE_COUNT 个 LayerType 定义${NC}"
  grep -r "export enum LayerType" ./src/monitoring --include="*.ts"
  ((ERRORS++))
fi

# 3. 检查 CacheStatsDto 重命名
echo -e "\n${YELLOW}3. 检查 CacheStatsDto 重命名${NC}"

if grep -q "export class RedisCacheRuntimeStatsDto" src/cache/dto/cache-internal.dto.ts 2>/dev/null; then
  echo -e "${GREEN}✓ RedisCacheRuntimeStatsDto 已创建${NC}"
else
  echo -e "${YELLOW}⚠ RedisCacheRuntimeStatsDto 未找到${NC}"
  ((WARNINGS++))
fi

# 4. 检查时间字段接口
echo -e "\n${YELLOW}4. 检查时间字段标准化${NC}"

if [ -f "src/common/interfaces/time-fields.interface.ts" ]; then
  echo -e "${GREEN}✓ 时间字段接口文件存在${NC}"
else
  echo -e "${YELLOW}⚠ 时间字段接口文件不存在${NC}"
  ((WARNINGS++))
fi

# 5. 检查统计字段接口
echo -e "\n${YELLOW}5. 检查统计字段标准化${NC}"

if [ -f "src/common/interfaces/statistics-fields.interface.ts" ]; then
  echo -e "${GREEN}✓ 统计字段接口文件存在${NC}"
else
  echo -e "${YELLOW}⚠ 统计字段接口文件不存在${NC}"
  ((WARNINGS++))
fi

# 6. TypeScript 编译检查
echo -e "\n${YELLOW}6. TypeScript 编译检查${NC}"

npx tsc --noEmit 2>/dev/null
if [ $? -eq 0 ]; then
  echo -e "${GREEN}✓ TypeScript 编译通过${NC}"
else
  echo -e "${RED}✗ TypeScript 编译失败${NC}"
  ((ERRORS++))
fi

# 结果汇总
echo -e "\n========================================="
echo -e "验证结果汇总"
echo -e "========================================="
echo -e "错误数: ${RED}$ERRORS${NC}"
echo -e "警告数: ${YELLOW}$WARNINGS${NC}"

if [ "$ERRORS" -eq 0 ]; then
  echo -e "\n${GREEN}✓ 所有关键检查通过！${NC}"
  exit 0
else
  echo -e "\n${RED}✗ 发现 $ERRORS 个错误需要修复${NC}"
  exit 1
fi
```

### 6.2 单元测试示例

**文件**: `/Users/honor/Documents/code/newstockapi/backend/test/common/enums/storage-classification.enum.spec.ts`

```typescript
import { 
  StorageClassification, 
  StorageClassificationHelper 
} from '@core/shared';

describe('StorageClassification', () => {
  describe('枚举值完整性测试', () => {
    it('应该包含19个枚举值', () => {
      const values = Object.values(StorageClassification);
      expect(values).toHaveLength(19);
    });

    it('应该包含所有股票相关分类', () => {
      const stockValues = [
        StorageClassification.STOCK_QUOTE,
        StorageClassification.STOCK_CANDLE,
        StorageClassification.STOCK_TICK,
        StorageClassification.STOCK_BASIC_INFO,
        StorageClassification.STOCK_NEWS,
        StorageClassification.STOCK_LOGO,
        StorageClassification.FINANCIAL_STATEMENT,
      ];
      
      stockValues.forEach(value => {
        expect(Object.values(StorageClassification)).toContain(value);
      });
    });
  });

  describe('StorageClassificationHelper', () => {
    describe('isStockRelated', () => {
      it('应该正确识别股票相关分类', () => {
        expect(StorageClassificationHelper.isStockRelated(
          StorageClassification.STOCK_QUOTE
        )).toBe(true);
        
        expect(StorageClassificationHelper.isStockRelated(
          StorageClassification.CRYPTO_QUOTE
        )).toBe(false);
      });
    });

    describe('getDisplayName', () => {
      it('应该返回正确的显示名称', () => {
        expect(StorageClassificationHelper.getDisplayName(
          StorageClassification.STOCK_QUOTE
        )).toBe('股票报价');
        
        expect(StorageClassificationHelper.getDisplayName(
          StorageClassification.CRYPTO_QUOTE
        )).toBe('加密货币报价');
      });
    });
  });
});
```

---

## 7. 回滚方案

如果修改后出现问题，可以执行以下回滚步骤：

### 7.1 Git 回滚

```bash
# 查看修改前的提交
git log --oneline -n 10

# 回滚到修改前的提交
git revert <commit-hash>

# 或者使用 reset（谨慎使用）
git reset --hard <commit-hash>
```

### 7.2 手动回滚步骤

1. 恢复原有的枚举定义
2. 删除新创建的文件
3. 恢复原有的导入语句
4. 重新编译和测试

---

## 8. 实施时间表

| 阶段 | 任务 | 预计时间 | 负责人 |
|------|------|---------|--------|
| 第1天 | StorageClassification 枚举统一 | 4小时 | 后端团队 |
| 第1天 | LayerType 重复清理 | 2小时 | 后端团队 |
| 第2天 | CacheStatsDto 重命名 | 3小时 | 后端团队 |
| 第2天 | 时间字段标准化 | 3小时 | 后端团队 |
| 第3天 | 统计字段标准化 | 3小时 | 后端团队 |
| 第3天 | 单元测试编写 | 3小时 | 测试团队 |
| 第4天 | 集成测试 | 4小时 | 测试团队 |
| 第4天 | 文档更新 | 2小时 | 文档团队 |
| 第5天 | 代码审查和部署 | 4小时 | 全体 |

---

## 9. 风险和注意事项

### 9.1 风险评估

| 风险项 | 影响级别 | 缓解措施 |
|-------|---------|---------|
| 破坏现有API兼容性 | 高 | 保留类型别名和废弃标记 |
| 编译错误 | 中 | 逐步迁移，每步验证编译 |
| 运行时错误 | 高 | 充分的单元测试和集成测试 |
| 第三方依赖冲突 | 低 | 检查所有外部模块引用 |

### 9.2 注意事项

1. **向后兼容性**：保留原有名称的类型别名，标记为 `@deprecated`
2. **逐步迁移**：分阶段实施，每个阶段独立验证
3. **测试覆盖**：确保所有修改都有对应的测试用例
4. **文档同步**：及时更新API文档和内部文档
5. **监控告警**：部署后密切监控系统指标

---

## 10. 检查清单

- [ ] 创建统一的 StorageClassification 枚举文件
- [ ] 更新所有 StorageClassification 导入语句
- [ ] 删除 LayerType 的重复定义
- [ ] 重命名 CacheStatsDto 为 RedisCacheRuntimeStatsDto
- [ ] 创建时间字段标准接口
- [ ] 创建统计字段标准接口
- [ ] 更新所有受影响的 DTO
- [ ] 编写单元测试
- [ ] 执行集成测试
- [ ] 更新API文档
- [ ] 创建迁移指南
- [ ] 代码审查
- [ ] 部署到测试环境
- [ ] 性能测试
- [ ] 部署到生产环境