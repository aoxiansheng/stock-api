# 错误处理一致性规范指南

## 目录
1. [规范概述](#规范概述)
2. [现状分析](#现状分析)
3. [核心原则](#核心原则)
4. [错误分类体系](#错误分类体系)
5. [错误码规范](#错误码规范)
6. [实施标准](#实施标准)
7. [组件迁移指南](#组件迁移指南)
8. [代码示例](#代码示例)
9. [检查清单](#检查清单)

---

## 规范概述

### 目标
建立统一的错误处理标准，消除组件间错误处理不一致的问题，提升系统的可维护性、可观察性和用户体验。

### 适用范围
- 所有核心组件（7层架构）
- 业务模块（Auth、Notification、Monitoring等）
- 工具服务（Cache、Database等）

### 规范版本
- **版本**: v1.0
- **生效日期**: 2025-09-21
- **审核依据**: 10个组件代码审核报告

---

## 现状分析

### 现有技术基础

#### ✅ GlobalExceptionFilter（系统核心基础设施）
- 强大的异常识别和分类机制
- 完整的错误码生成逻辑
- 多语言消息翻译支持
- 监控事件自动发送
- 敏感信息过滤和安全防护

#### ✅ 错误处理架构基础
- 基于NestJS标准异常体系
- 统一的响应格式和状态码映射
- 完善的日志记录和追踪机制
- 与监控系统的深度集成

#### ⚠️ Cache模块现状
Cache模块虽然有相对完整的异常体系，但**同样存在独立实现的问题**：
- 自定义异常类（CacheException、CacheConnectionException等）
- 独立的异常工厂（CacheExceptionFactory）
- 与其他组件不一致的错误处理模式

**需要迁移**：Cache模块也应当迁移到统一的 `@common` 错误处理体系中。

### 主要问题汇总

| 组件 | 主要问题 | 影响程度 |
|------|----------|----------|
| **Query** | 22处`throw new Error`，缺乏结构化错误分类 | 🔴 严重 |
| **Cache** | 独立异常体系，与统一标准不一致 | 🔴 严重 |
| **Common-cache** | 策略混合：抛异常vs返回null vs返回错误对象 | 🔴 严重 |
| **Stream-receiver** | 中英文混用：`"订阅处理失败"` vs `"AuthenticationError"` | 🟡 中等 |
| **Receiver** | 过度使用`BadRequestException`/`NotFoundException` | 🟡 中等 |
| **Symbol-mapper** | 缺乏统一错误码体系和国际化支持 | 🟡 中等 |
| **Shared** | 对临时性错误直接降级，未实现重试 | 🟡 中等 |
| **Storage** | 重试机制缺失 | 🟡 中等 |

---

## 核心原则

### 1. 统一错误策略
- **关键路径**：必须抛出异常，不允许静默失败
- **非关键功能**：可降级处理，返回默认值并记录日志
- **配置验证**：始终抛出异常，快速失败原则

### 2. 错误分类一致性
- 使用标准化的错误分类体系
- 每个组件建立自己的异常类层次
- 继承自NestJS标准异常类

### 3. 错误信息标准化
- 使用英文错误消息（面向开发者）
- 提供结构化的错误上下文
- 保留原始错误信息用于调试

### 4. 可恢复性设计
- 区分可重试和不可重试错误
- 提供错误恢复建议
- 实现指数退避重试机制

---

## 错误分类体系

### 四层分类结构

```
{COMPONENT}_{CATEGORY}_{SEQUENCE}
├── VALIDATION (验证类错误)
│   ├── 001-099: 参数验证
│   ├── 100-199: 数据格式验证
│   └── 200-299: 业务规则验证
├── BUSINESS (业务逻辑错误)
│   ├── 300-399: 业务流程错误
│   ├── 400-499: 状态冲突错误
│   └── 500-599: 资源不存在错误
├── SYSTEM (系统资源错误)
│   ├── 600-699: 内存/CPU资源
│   ├── 700-799: 超时错误
│   └── 800-899: 配置错误
└── EXTERNAL (外部依赖错误)
    ├── 900-949: 数据库错误
    ├── 950-979: 第三方API错误
    └── 980-999: 网络错误
```

### HTTP状态码映射

| 错误类别 | HTTP状态码 | NestJS异常类 |
|----------|------------|--------------|
| VALIDATION | 400 | BadRequestException |
| BUSINESS | 400/404/409 | BadRequestException/NotFoundException/ConflictException |
| SYSTEM | 500/503/408 | InternalServerErrorException/ServiceUnavailableException/RequestTimeoutException |
| EXTERNAL | 502/503/504 | BadGatewayException/ServiceUnavailableException/GatewayTimeoutException |

---

## 错误码规范

### 命名规则
- **格式**: `{COMPONENT}_{CATEGORY}_{SEQUENCE}`
- **组件代码**:
  - ALERT: 警告服务
  - AUTH: 认证服务
  - CACHE：缓存器服务
  - MONITORING：监控服务
  - NOTIFICATION：通知服务
  
  - SYMBOL-MAPPER : 符号映射规则组件
  - DATA-MAPPER : 数据映射器规则组件

  - QUERY: 慢时效查询组件
  - RECEIVER: 快时效查询组件
  - STREAM_RECEIVER: 流数据查询组件

  - DATA-FETCHER: SDK-REST 数据获取组件
  - STREAM-DATA-FETCHE: SDK-STREAM 数据获取组件

  - TRANSFORMER: 数据映射器规则执行器
  - SYMBOL-TRANSFORMER: 符号映射规则执行器

  - SMART-CACHE: 智能缓存导组件
  - COMMON-CACHE: 通用缓存组件
  - SYMBOL-MAPPER-CACHE: 符号映射规则专用缓存器
  - DATA-MAPPER-CACHE: 数据映射器规则专用缓存器
  - STREAM-CACHE: 流数据专用缓存器

  - STORAGE: 存储服务
  - SHARED: 共享组件

### 示例错误码

```typescript
export enum QueryErrorCode {
  // 验证类错误
  VALIDATION_FAILED = 'QUERY_VALIDATION_001',
  INVALID_SYMBOLS = 'QUERY_VALIDATION_002',
  MISSING_REQUIRED_PARAMS = 'QUERY_VALIDATION_003',

  // 业务逻辑错误
  UNSUPPORTED_QUERY_TYPE = 'QUERY_BUSINESS_300',
  QUERY_RESULT_EMPTY = 'QUERY_BUSINESS_301',

  // 系统资源错误
  MEMORY_PRESSURE = 'QUERY_SYSTEM_600',
  TIMEOUT_ERROR = 'QUERY_SYSTEM_700',

  // 外部依赖错误
  PROVIDER_UNAVAILABLE = 'QUERY_EXTERNAL_950',
  CACHE_SERVICE_ERROR = 'QUERY_EXTERNAL_900',
}
```

---

## 实施标准

### 1. 基于现有架构的通用方案

系统已有强大的 `GlobalExceptionFilter` 和错误处理基础设施，我们只需在 `@common` 模块中扩展现有功能：

```typescript
// @common/core/exceptions/business-exception.ts
// 通用业务异常基类，复用现有 HttpException 体系
export class BusinessException extends HttpException {
  public readonly errorCode: string;
  public readonly operation: string;
  public readonly context?: any;
  public readonly retryable: boolean;
  public readonly component: string;

  constructor(
    errorCode: string,
    message: string,
    status: HttpStatus,
    operation: string,
    component: string,
    context?: any,
    retryable: boolean = false,
    public readonly originalError?: Error
  ) {
    super(message, status);
    this.errorCode = errorCode;
    this.operation = operation;
    this.component = component;
    this.context = context;
    this.retryable = retryable;
  }

  // 错误恢复建议
  getRecoveryAction(): 'retry' | 'fallback' | 'abort' {
    if (this.retryable) return 'retry';
    if (this.errorCode.includes('EXTERNAL')) return 'fallback';
    return 'abort';
  }
}
```

### 2. 通用异常工厂

```typescript
// @common/core/exceptions/exception-factory.ts
// 通用异常工厂，避免每个组件重复实现
export class UniversalExceptionFactory {
  static createBusinessException(
    component: string,
    errorCode: string,
    operation: string,
    message: string,
    context?: any,
    retryable: boolean = false
  ): BusinessException {
    const status = this.getStatusFromErrorCode(errorCode);
    return new BusinessException(
      errorCode,
      message,
      status,
      operation,
      component,
      context,
      retryable
    );
  }

  static createFromError(
    component: string,
    operation: string,
    error: Error,
    context?: any
  ): BusinessException {
    // 智能错误分类，基于现有GlobalExceptionFilter逻辑
    const errorCode = this.classifyError(component, error);
    const status = this.getStatusFromErrorCode(errorCode);
    const retryable = this.isRetryableError(error);

    return new BusinessException(
      errorCode,
      error.message,
      status,
      operation,
      component,
      context,
      retryable,
      error
    );
  }

  private static getStatusFromErrorCode(errorCode: string): HttpStatus {
    if (errorCode.includes('VALIDATION')) return HttpStatus.BAD_REQUEST;
    if (errorCode.includes('BUSINESS')) return HttpStatus.BAD_REQUEST;
    if (errorCode.includes('SYSTEM')) return HttpStatus.INTERNAL_SERVER_ERROR;
    if (errorCode.includes('EXTERNAL')) return HttpStatus.SERVICE_UNAVAILABLE;
    return HttpStatus.INTERNAL_SERVER_ERROR;
  }

  private static classifyError(component: string, error: Error): string {
    const upperComponent = component.toUpperCase();

    if (error.message.includes('timeout')) {
      return `${upperComponent}_SYSTEM_700`;
    }
    if (error.message.includes('validation') || error.message.includes('invalid')) {
      return `${upperComponent}_VALIDATION_001`;
    }
    if (error.message.includes('connection') || error.message.includes('unavailable')) {
      return `${upperComponent}_EXTERNAL_900`;
    }

    return `${upperComponent}_SYSTEM_800`;
  }

  private static isRetryableError(error: Error): boolean {
    const retryableKeywords = ['timeout', 'connection', 'unavailable', 'network'];
    return retryableKeywords.some(keyword =>
      error.message.toLowerCase().includes(keyword)
    );
  }
}
```

### 3. 错误处理策略标准

```typescript
// 统一错误处理策略
export enum ErrorHandlingStrategy {
  THROW = 'throw',           // 抛出异常
  SILENT = 'silent',         // 静默失败，返回默认值
  METADATA = 'metadata'      // 返回包含错误信息的结果对象
}

// 错误处理配置
interface ErrorHandlingConfig {
  strategy: ErrorHandlingStrategy;
  defaultValue?: any;
  retryConfig?: RetryConfig;
  fallbackAction?: () => any;
}
```

### 4. 重试机制标准

```typescript
// 重试配置接口
interface RetryConfig {
  maxAttempts: number;
  baseDelayMs: number;
  maxDelayMs: number;
  backoffMultiplier: number;
  retryableErrors: string[]; // 可重试的错误码
}

// 指数退避重试实现
export class RetryHandler {
  static async executeWithRetry<T>(
    operation: () => Promise<T>,
    config: RetryConfig,
    operationName: string
  ): Promise<T> {
    // 重试逻辑实现
  }
}
```

---

## 组件迁移指南

### 优先级评级

| 优先级 | 组件 | 理由 | 预估工期 |
|--------|------|------|----------|
| 🔴 P0 | Query | 22处错误处理需标准化，影响最大 | 2天 |
| 🔴 P0 | Cache | 迁移现有独立异常体系到通用标准 | 1.5天 |
| 🔴 P0 | Common-cache | 策略不统一，系统稳定性风险 | 1天 |
| 🟡 P1 | Stream-receiver | 中英文混用，用户体验影响 | 1天 |
| 🟡 P1 | Receiver | 异常类型过于通用 | 1天 |
| 🟢 P2 | Symbol-mapper | 功能相对独立 | 1天 |
| 🟢 P2 | Storage | 重试机制补充 | 0.5天 |
| 🟢 P2 | Shared | 降级逻辑完善 | 0.5天 |

### 迁移步骤

#### 第一阶段：在 @common 中建立通用基础设施

1. **创建通用异常基类**
   ```bash
   src/common/core/exceptions/
   ├── business-exception.ts          # 通用业务异常基类
   ├── exception-factory.ts          # 通用异常工厂
   ├── retry-handler.ts              # 通用重试机制
   └── index.ts                      # 统一导出
   ```

2. **扩展全局异常过滤器**
   - 在现有 `GlobalExceptionFilter` 中添加 `BusinessException` 识别
   - 复用现有的错误码生成和消息翻译逻辑

#### 第二阶段：组件接入（每个组件只需最少代码）

各组件只需要两个文件：

1. **错误码常量定义**（唯一需要的组件特定代码）
   ```bash
   src/{component}/constants/{component}-error-codes.constants.ts
   ```

2. **组件错误处理工具**（可选，简化调用）
   ```bash
   src/{component}/utils/{component}-error.utils.ts
   ```

#### 第三阶段：替换现有错误处理
1. **导入通用工厂**: `import { UniversalExceptionFactory } from '@common/core/exceptions'`
2. **替换throw语句**: 使用统一的工厂方法
3. **自动获得重试机制**: 通过工厂自动判断可重试性

---

## 代码示例

### 1. 基于 @common 的简化组件改造

#### Query组件：只需要定义错误码

```typescript
// src/core/01-entry/query/constants/query-error-codes.constants.ts
// 🎯 组件唯一需要的特定代码
export const QUERY_ERROR_CODES = {
  // 验证类错误
  MISSING_REQUIRED_PARAMS: 'QUERY_VALIDATION_001',
  INVALID_SYMBOLS: 'QUERY_VALIDATION_002',
  SYMBOLS_LIMIT_EXCEEDED: 'QUERY_VALIDATION_003',

  // 业务逻辑错误
  UNSUPPORTED_QUERY_TYPE: 'QUERY_BUSINESS_300',
  QUERY_RESULT_EMPTY: 'QUERY_BUSINESS_301',

  // 系统资源错误
  MEMORY_PRESSURE: 'QUERY_SYSTEM_600',
  TIMEOUT_ERROR: 'QUERY_SYSTEM_700',

  // 外部依赖错误
  PROVIDER_UNAVAILABLE: 'QUERY_EXTERNAL_950',
  CACHE_SERVICE_ERROR: 'QUERY_EXTERNAL_900',
} as const;
```

#### 改造前
```typescript
// ❌ 现有问题代码
if (!symbols || symbols.length === 0) {
  throw new Error('symbols参数不能为空');
}

if (symbolCount > 10000) {
  throw new Error('symbols数量不能超过10000');
}
```

#### 改造后
```typescript
// ✅ 使用通用工厂的标准化代码
import { UniversalExceptionFactory } from '@common/core/exceptions';
import { QUERY_ERROR_CODES } from '../constants/query-error-codes.constants';

if (!symbols || symbols.length === 0) {
  throw UniversalExceptionFactory.createBusinessException(
    'query',
    QUERY_ERROR_CODES.MISSING_REQUIRED_PARAMS,
    'validateSymbols',
    'Symbols parameter cannot be empty',
    { symbols }
  );
}

if (symbolCount > QUERY_LIMITS.MAX_SYMBOLS) {
  throw UniversalExceptionFactory.createBusinessException(
    'query',
    QUERY_ERROR_CODES.SYMBOLS_LIMIT_EXCEEDED,
    'validateSymbols',
    `Symbols count cannot exceed ${QUERY_LIMITS.MAX_SYMBOLS}`,
    { symbolCount, limit: QUERY_LIMITS.MAX_SYMBOLS }
  );
}
```

### 2. 使用通用重试机制（自动判断可重试性）

```typescript
// ✅ 使用通用重试处理器，自动获得重试能力
import { UniversalRetryHandler } from '@common/core/exceptions';

export class QueryService {
  async executeQuery(request: QueryRequestDto): Promise<QueryResponseDto> {
    try {
      return await UniversalRetryHandler.executeWithRetry(
        () => this.performQuery(request),
        'query',        // 组件名
        'executeQuery', // 操作名
        { request }     // 上下文
      );
    } catch (error) {
      // 通用工厂会自动判断错误类型和可重试性
      if (error instanceof BusinessException) {
        const action = error.getRecoveryAction();

        if (action === 'fallback') {
          return this.getFallbackResult(request);
        }
      }

      // 通用工厂包装未知错误
      throw UniversalExceptionFactory.createFromError(
        'query',
        'executeQuery',
        error as Error,
        { request }
      );
    }
  }
}
```

### 3. 简化的组件错误处理工具（可选）

```typescript
// src/core/01-entry/query/utils/query-error.utils.ts
// 🎯 可选：为组件提供便捷方法，减少重复代码
import { UniversalExceptionFactory } from '@common/core/exceptions';
import { QUERY_ERROR_CODES } from '../constants/query-error-codes.constants';

export class QueryErrorUtils {
  static throwValidationError(
    operation: string,
    errorCode: keyof typeof QUERY_ERROR_CODES,
    message: string,
    context?: any
  ) {
    throw UniversalExceptionFactory.createBusinessException(
      'query',
      QUERY_ERROR_CODES[errorCode],
      operation,
      message,
      context
    );
  }

  static throwSystemError(
    operation: string,
    errorCode: keyof typeof QUERY_ERROR_CODES,
    message: string,
    context?: any,
    retryable = true
  ) {
    throw UniversalExceptionFactory.createBusinessException(
      'query',
      QUERY_ERROR_CODES[errorCode],
      operation,
      message,
      context,
      retryable
    );
  }
}

// 使用示例
// QueryErrorUtils.throwValidationError(
//   'validateSymbols',
//   'MISSING_REQUIRED_PARAMS',
//   'Symbols parameter cannot be empty',
//   { symbols }
// );
```

### 4. Cache模块迁移（从独立异常体系到通用标准）

#### 改造前
```typescript
// ❌ 独立的异常体系
import {
  CacheConnectionException,
  CacheOperationException,
  CacheSerializationException,
  CacheExceptionFactory
} from '../exceptions';

// 分散的异常创建
throw new CacheConnectionException('set', cacheKey, originalError);
throw CacheExceptionFactory.fromError('get', error, cacheKey);
```

#### 改造后
```typescript
// ✅ 使用通用异常体系
import { UniversalExceptionFactory } from '@common/core/exceptions';
import { CACHE_ERROR_CODES } from '../constants/cache-error-codes.constants';

// 统一的异常创建
throw UniversalExceptionFactory.createBusinessException(
  'cache',
  CACHE_ERROR_CODES.CONNECTION_FAILED,
  'set',
  'Cache connection failed',
  { cacheKey },
  true  // 连接错误可重试
);

// 智能错误包装（自动分类和重试判断）
throw UniversalExceptionFactory.createFromError(
  'cache',
  'get',
  error,
  { cacheKey }
);
```

#### Cache错误码定义
```typescript
// src/cache/constants/cache-error-codes.constants.ts
export const CACHE_ERROR_CODES = {
  // 连接类错误
  CONNECTION_FAILED: 'CACHE_EXTERNAL_900',
  CONNECTION_TIMEOUT: 'CACHE_EXTERNAL_901',

  // 操作类错误
  OPERATION_FAILED: 'CACHE_SYSTEM_800',
  OPERATION_TIMEOUT: 'CACHE_SYSTEM_700',

  // 序列化错误
  SERIALIZATION_FAILED: 'CACHE_VALIDATION_100',
  DESERIALIZATION_FAILED: 'CACHE_VALIDATION_101',

  // 验证错误
  INVALID_KEY: 'CACHE_VALIDATION_001',
  INVALID_VALUE: 'CACHE_VALIDATION_002',
} as const;
```

### 5. Stream-receiver语言标准化

#### 改造前
```typescript
// ❌ 中英文混用
client.emit("subscribe-error", {
  message: error.message || "订阅处理失败",  // 中文
});

const authError = new Error("连接认证失败");  // 中文
authError.name = "AuthenticationError";     // 英文
```

#### 改造后
```typescript
// ✅ 使用通用工厂，自动获得标准化格式
import { UniversalExceptionFactory } from '@common/core/exceptions';
import { STREAM_ERROR_CODES } from '../constants/stream-error-codes.constants';

// 统一的错误发送格式（复用GlobalExceptionFilter的逻辑）
const businessError = UniversalExceptionFactory.createBusinessException(
  'stream_receiver',
  STREAM_ERROR_CODES.SUBSCRIPTION_FAILED,
  'handleSubscription',
  'Subscription processing failed',
  { clientId, error: error.message }
);

client.emit("subscribe-error", {
  code: businessError.errorCode,
  message: businessError.message,
  timestamp: Date.now(),
  details: businessError.context
});

// 认证错误
throw UniversalExceptionFactory.createBusinessException(
  'stream_receiver',
  STREAM_ERROR_CODES.AUTH_FAILED,
  'authenticateConnection',
  'Connection authentication failed',
  { clientId }
);
```

---

## 检查清单

### 通用基础设施检查（@common 模块）

#### ✅ 通用异常基础设施
- [ ] `BusinessException` 基类已创建
- [ ] `UniversalExceptionFactory` 工厂已实现
- [ ] `UniversalRetryHandler` 重试机制已实现
- [ ] `GlobalExceptionFilter` 已扩展支持 `BusinessException`

#### ✅ 集成验证
- [ ] 错误码自动生成逻辑正常
- [ ] 重试机制自动判断可重试性
- [ ] 监控事件自动发送（复用现有 `SYSTEM_STATUS_EVENTS`）
- [ ] 消息翻译机制正常工作

### 组件迁移检查（极简化）

#### ✅ 组件特定代码（每个组件只需检查这些）
- [ ] 错误码常量已定义 (`{component}-error-codes.constants.ts`)
- [ ] 所有 `throw new Error` 已替换为 `UniversalExceptionFactory` 调用
- [ ] 错误消息统一使用英文
- [ ] 上下文信息完整传递

#### ✅ 自动获得的能力（无需额外实现）
- [x] 重试机制（工厂自动判断）
- [x] 错误分类（工厂自动识别）
- [x] HTTP状态码映射（工厂自动处理）
- [x] 监控集成（GlobalExceptionFilter自动处理）
- [x] 错误码生成（GlobalExceptionFilter自动处理）

### 单个组件检查模板（简化版）

```typescript
// 检查清单 - {组件名}组件 (简化版)
export const {COMPONENT}_ERROR_HANDLING_CHECKLIST = {
  // 🎯 组件特定代码 (唯一需要实现的)
  errorCodesConstants: '✅ 已定义', // ❌ 待定义
  throwErrorReplacement: '85%',     // 替换进度
  messageLanguage: '✅ 统一英文',   // ❌ 中英混用

  // ✅ 自动获得的能力 (无需实现)
  retryMechanism: '✅ 自动获得',    // 通过 UniversalExceptionFactory
  errorClassification: '✅ 自动获得', // 通过工厂智能分类
  monitoringIntegration: '✅ 自动获得', // 通过 GlobalExceptionFilter
  statusCodeMapping: '✅ 自动获得',  // 通过工厂逻辑

  // 📊 统计数据
  codeReduction: '90%',             // 相比原方案减少的代码量
  migrationEffort: '1-2天',         // 迁移工作量
};
```

### 关键优势对比

| 维度 | 原方案（每组件独立） | 新方案（基于@common） |
|------|---------------------|---------------------|
| **代码重复** | 严重（每组件重复异常体系） | 几乎无重复 |
| **维护成本** | 高（10个组件 × 多个文件） | 低（仅需维护@common基础设施） |
| **实施工作量** | 高（每组件2-5天） | 低（每组件1-2天） |
| **一致性保证** | 难（人工维护一致性） | 强（自动保证一致性） |
| **功能完整性** | 取决于实施质量 | 统一的高质量实现 |

---

## 实施计划（基于@common的简化方案）

### 第一阶段：建立通用基础设施（Week 1）
- **@common模块扩展**（2-3天）:
  - 创建 `BusinessException` 基类
  - 实现 `UniversalExceptionFactory` 工厂
  - 实现 `UniversalRetryHandler` 重试机制
  - 扩展 `GlobalExceptionFilter` 支持新异常类型

### 第二阶段：组件迁移（Week 2-3）
每个组件只需 1-2天，可并行进行：

| 组件 | 工作量 | 主要任务 |
|------|--------|----------|
| **Query** | 2天 | 定义错误码常量 + 替换22处错误处理 |
| **Cache** | 1.5天 | 迁移现有异常体系 + 定义错误码 + 统一到通用工厂 |
| **Common-cache** | 1天 | 定义错误码 + 统一策略 |
| **Stream-receiver** | 1天 | 错误码 + 消除中英文混用 |
| **Receiver** | 1天 | 错误码 + 替换通用异常 |
| **Symbol-mapper** | 1天 | 错误码 + 标准化 |
| **Storage** | 0.5天 | 错误码 + 重试集成 |
| **Shared** | 0.5天 | 错误码 + 降级完善 |

### 第三阶段：验证和优化（Week 4）
- **集成测试**: 验证所有组件错误处理一致性
- **性能测试**: 确认重试机制性能影响
- **监控配置**: 错误指标和告警规则


---

---

## 附录

### A. 参考文档
- [NestJS Exception Filters](https://docs.nestjs.com/exception-filters)
- [HTTP状态码规范](https://tools.ietf.org/html/rfc7231#section-6)
- [错误码设计最佳实践](https://google.github.io/styleguide/jsoncstyleguide.xml#Error_responses)

