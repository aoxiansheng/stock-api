# Symbol Mapper ç»„ä»¶ç¼“å­˜é‡æ„è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ é¡¹ç›®èƒŒæ™¯

### å½“å‰é—®é¢˜åˆ†æ

ç»è¿‡æ·±åº¦ä»£ç åˆ†æå’Œå®é™…æµç¨‹éªŒè¯ï¼Œå‘ç°å½“å‰ Symbol Mapper ç»„ä»¶å­˜åœ¨ä»¥ä¸‹ç¼“å­˜æ¶æ„é—®é¢˜ï¼š

1. **ç¼“å­˜è·¯å¾„ä¸ç»Ÿä¸€**ï¼šå•ç¬¦å·æŸ¥è¯¢æœ‰ç¼“å­˜ï¼Œæ‰¹é‡æŸ¥è¯¢å®Œå…¨ç»•è¿‡ç¼“å­˜
2. **åŒå‘æ˜ å°„ç¼ºå¤±**ï¼šåªç¼“å­˜å•å‘æ˜ å°„ï¼Œåå‘æŸ¥è¯¢é‡å¤è®¡ç®—
3. **æ•°æ®å­¤å²›é—®é¢˜**ï¼šæ‰¹é‡ä¸å•æ¬¡æŸ¥è¯¢æ•°æ®æ— æ³•å…±äº«
4. **TTLç­–ç•¥ä¸åˆç†**ï¼šSymbolæ˜ å°„æ•°æ®ç¨³å®šæ€§é«˜ï¼Œä½†ä½¿ç”¨çŸ­TTL

**é‡è¦è¯´æ˜**ï¼šç»è¿‡è¯¦ç»†ä»£ç å®¡æŸ¥ï¼ŒQueryâ†’Receiveræµå‘ä¸­**ä¸å­˜åœ¨**Symbol Mapperé‡å¤è°ƒç”¨é—®é¢˜ã€‚SmartCacheOrchestratoræœ‰æ•ˆé¿å…äº†é‡å¤è°ƒç”¨ã€‚

### æ€§èƒ½å½±å“

| é—®é¢˜ç±»å‹ | å½“å‰å½±å“ | ä¸šåŠ¡ç—›ç‚¹ |
|---------|----------|----------|
| æ‰¹é‡æŸ¥è¯¢æ— ç¼“å­˜ | æ¯æ¬¡éƒ½æŸ¥æ•°æ®åº“ | é«˜å¹¶å‘ä¸‹æ•°æ®åº“å‹åŠ›å¤§ |
| åŒå‘æŸ¥è¯¢é‡å¤ | 2æ¬¡ç‹¬ç«‹æŸ¥è¯¢ | æµªè´¹è®¡ç®—èµ„æº |
| çŸ­TTLç­–ç•¥ | é¢‘ç¹ç¼“å­˜å¤±æ•ˆ | ç¼“å­˜å‘½ä¸­ç‡ä½äº30% |
| æ•°æ®å­¤å²› | æ‰¹é‡å’Œå•æ¬¡æŸ¥è¯¢ç¼“å­˜ä¸å…±äº« | é‡å¤çš„æ•°æ®åº“æŸ¥è¯¢ |

## ğŸ¯ é‡æ„ç›®æ ‡

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **ğŸ“Š åˆ†å±‚ç¼“å­˜æ¶æ„**ï¼šL1è§„åˆ™ç¼“å­˜ + L2ç¬¦å·ç¼“å­˜ + L3æ‰¹é‡ç¼“å­˜
2. **ğŸ”„ åŒå‘æ˜ å°„ç¼“å­˜**ï¼šä¸€æ¬¡æŸ¥è¯¢ï¼ŒåŒå‘å—ç›Š
3. **âš¡ æ‰¹é‡å•æ¬¡ç»Ÿä¸€**ï¼šæ‰€æœ‰æŸ¥è¯¢èµ°ç»Ÿä¸€å¤„ç†è·¯å¾„
4. **ğŸ•’ é•¿æœŸç¼“å­˜ç­–ç•¥**ï¼šæ ¹æ®æ•°æ®ç¨³å®šæ€§è®¾ç½®åˆç†TTL
5. **ğŸ¯ æ™ºèƒ½é¢„åŠ è½½**ï¼šåŸºäºä½¿ç”¨æ¨¡å¼ä¸»åŠ¨é¢„åŠ è½½

### é¢„æœŸæ€§èƒ½æ”¹å–„

| æŒ‡æ ‡ | å½“å‰æ€§èƒ½ | ç›®æ ‡æ€§èƒ½ | æ”¹å–„å¹…åº¦ |
|------|----------|----------|----------|
| æ‰¹é‡ç¬¦å·æ˜ å°„ç¼“å­˜å‘½ä¸­ç‡ | <5% | 85%+ | **80%æå‡** |
| å•ç¬¦å·æŸ¥è¯¢å»¶è¿Ÿ | 20-50ms | 0.1-1ms | **95%å‡å°‘** |
| æ‰¹é‡æŸ¥è¯¢å»¶è¿Ÿ | 100-300ms | 10-30ms | **80%å‡å°‘** |
| æ•°æ®åº“æŸ¥è¯¢æ¬¡æ•° | æ¯æ¬¡éƒ½æŸ¥ | ç¼“å­˜æœŸå†…0æ¬¡ | **90%å‡å°‘** |
| åŒå‘æŸ¥è¯¢æ•ˆç‡ | 2æ¬¡ç‹¬ç«‹æŸ¥è¯¢ | 1æ¬¡æŸ¥è¯¢åŒå‘ç¼“å­˜ | **50%å‡å°‘** |

## ğŸ—ï¸ æ–°æ¶æ„è®¾è®¡

### æ¶æ„è¯´æ˜
æœ¬é‡æ„æ–¹æ¡ˆä¸“æ³¨äºä¼˜åŒ–Symbol Mapperç»„ä»¶å†…éƒ¨çš„ç¼“å­˜æœºåˆ¶ï¼Œä¸æ¶‰åŠQuery-Receiverçš„è°ƒç”¨æµç¨‹ï¼ˆè¯¥æµç¨‹å·²é€šè¿‡SmartCacheOrchestratorä¼˜åŒ–ï¼‰ã€‚

### ç»Ÿä¸€ç¼“å­˜æœåŠ¡ç±»

```typescript
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { LRUCache } from 'lru-cache';
import * as crypto from 'crypto';
import { FeatureFlags } from '@common/config/feature-flags.config';
import { PresenterRegistryService } from '@monitoring/metrics/services/metrics-registry.service';
import { SymbolMappingRepository } from '../repositories/symbol-mapping.repository';
import { SymbolMappingRule } from '../schemas/symbol-mapping-rule.schema';
import { createLogger } from '@common/config/logger.config';
import { Metrics } from '@common/utils/metrics.utils'; // ç»Ÿä¸€ä½¿ç”¨ Metrics.inc å°è£…
// TODO: éœ€è¦æ–°å¢ä»¥ä¸‹æ¥å£å®šä¹‰æ–‡ä»¶ï¼š
// import { BatchMappingResult, SymbolMappingResult } from '../interfaces/symbol-mapper.interfaces';

// ğŸ“ å®æ–½æé†’: ä»£ç ç¤ºä¾‹ä¸­ä½¿ç”¨çš„å¯¼å…¥å·²åœ¨ä¸Šæ–¹å®šä¹‰ï¼Œå®æ–½æ—¶ç¡®ä¿è·¯å¾„æ­£ç¡®
// ç‰¹åˆ«æ³¨æ„ PresenterRegistryServiceã€FeatureFlagsã€SymbolMappingRepository çš„å¯¼å…¥è·¯å¾„
// ç»Ÿä¸€ä½¿ç”¨ Metrics.inc å°è£…: import { Metrics } from '@common/utils/metrics.utils';

/**
 * ğŸ“ éœ€è¦æ–°å¢çš„ç±»å‹å®šä¹‰ (interfaces/symbol-mapper.interfaces.ts):
 * 
 * export interface SymbolMappingResult {
 *   success: boolean;
 *   mappedSymbol?: string;
 *   originalSymbol: string;
 *   provider: string;
 *   direction: 'to_standard' | 'from_standard';
 *   cacheHit?: boolean;
 *   processingTime?: number;
 * }
 * 
 * export interface BatchMappingResult {
 *   success: boolean;
 *   mappingDetails: Record<string, string>;
 *   failedSymbols: string[];
 *   provider: string;
 *   direction: 'to_standard' | 'from_standard';
 *   totalProcessed: number;
 *   cacheHits: number;
 *   processingTime: number;
 * }
 */
/**
 * Symbol Mapper ç»Ÿä¸€ç¼“å­˜æœåŠ¡
 * ä¼˜åŒ–æ‰¹é‡æŸ¥è¯¢ç¼“å­˜å’Œå®ç°åŒå‘æ˜ å°„çš„æ ¸å¿ƒç»„ä»¶
 */
@Injectable()
export class SymbolMapperCacheService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = createLogger(SymbolMapperCacheService.name);
  
  // ğŸ¯ ä¸‰å±‚ç¼“å­˜æ¶æ„
  private readonly providerRulesCache: LRUCache<string, SymbolMappingRule[]>;  // L1: è§„åˆ™ç¼“å­˜
  private readonly symbolMappingCache: LRUCache<string, string>;               // L2: ç¬¦å·æ˜ å°„ç¼“å­˜  
  private readonly batchResultCache: LRUCache<string, any>;     // L3: æ‰¹é‡ç»“æœç¼“å­˜ (TODO: ä½¿ç”¨ BatchMappingResult ç±»å‹)
  
  // ğŸ”’ å¹¶å‘æ§åˆ¶
  private readonly pendingQueries: Map<string, Promise<any>>;
  
  // ğŸ“¡ å˜æ›´ç›‘å¬
  private changeStream: any; // Change Stream å®ä¾‹
  
  // ğŸ“Š ç¼“å­˜ç»Ÿè®¡ - æŒ‰å±‚çº§åˆ†åˆ«ç»Ÿè®¡
  private cacheStats: {
    l1: { hits: number; misses: number };
    l2: { hits: number; misses: number };
    l3: { hits: number; misses: number };
    totalQueries: number;
  };

  constructor(
    private readonly repository: SymbolMappingRepository,
    private readonly featureFlags: FeatureFlags,
    private readonly metricsRegistry: PresenterRegistryService
  ) {
    this.initializeCaches();
    this.initializeStats();
    this.pendingQueries = new Map();
  }

  /**
   * ğŸš€ æ¨¡å—åˆå§‹åŒ– - å¯åŠ¨å˜æ›´ç›‘å¬
   */
  async onModuleInit(): Promise<void> {
    // ä»…åœ¨æ¨¡å—åˆå§‹åŒ–æ—¶æ³¨å†Œä¸€æ¬¡ï¼Œé¿å…é‡å¤ç›‘å¬
    this.setupChangeStreamMonitoring();
    
    this.logger.log('SymbolMapperCacheService initialized with change stream monitoring');
  }

  /**
   * ğŸ“Š æ¨¡å—é”€æ¯ - æ¸…ç†èµ„æº
   */
  async onModuleDestroy(): Promise<void> {
    // å…³é—­ Change Stream
    if (this.changeStream) {
      try {
        await this.changeStream.close();
        this.logger.log('Change Stream å·²å…³é—­');
      } catch (error) {
        this.logger.error('å…³é—­ Change Stream å¤±è´¥', { error: error.message });
      }
    }
    
    // æ¸…ç†ç¼“å­˜
    this.providerRulesCache.clear();
    this.symbolMappingCache.clear();
    this.batchResultCache.clear();
    
    // æ¸…ç†å¾…å¤„ç†æŸ¥è¯¢
    this.pendingQueries.clear();
    
    this.logger.log('SymbolMapperCacheService destroyed and resources cleaned up');
  }

  /**
   * ğŸ“Š åˆå§‹åŒ–ç»Ÿè®¡è®¡æ•°å™¨
   */
  private initializeStats(): void {
    this.cacheStats = {
      l1: { hits: 0, misses: 0 },
      l2: { hits: 0, misses: 0 },
      l3: { hits: 0, misses: 0 },
      totalQueries: 0
    };
  }

  /**
   * ğŸ¯ ç¼“å­˜åˆå§‹åŒ–ï¼šä»FeaturesFlagsè¯»å–ç°æœ‰å­—æ®µï¼ŒL3ä½¿ç”¨é»˜è®¤å€¼
   */
  private initializeCaches(): void {
    // ä» FeatureFlags è¯»å–ç°æœ‰ç¼“å­˜é…ç½®ï¼ˆä»…L1/L2ï¼‰
    const l1Config = {
      max: this.featureFlags.ruleCacheMaxSize || 100,
      ttl: this.featureFlags.ruleCacheTtl || 24 * 60 * 60 * 1000
    };
    
    const l2Config = {
      max: this.featureFlags.symbolCacheMaxSize || 50000,
      ttl: this.featureFlags.symbolCacheTtl || 12 * 60 * 60 * 1000
    };
    
    // L3é…ç½®ï¼šæ–°å¢ FeatureFlags å­—æ®µ
    const l3Config = {
      max: this.featureFlags.batchResultCacheMaxSize || 1000,
      ttl: this.featureFlags.batchResultCacheTtl || 2 * 60 * 60 * 1000 // 2å°æ—¶
    };
    
    // L1: è§„åˆ™ç¼“å­˜ - è§„åˆ™å¾ˆå°‘å˜åŠ¨ï¼Œé•¿æœŸç¼“å­˜
    this.providerRulesCache = new LRUCache({
      max: l1Config.max,
      ttl: l1Config.ttl,
      updateAgeOnGet: false        // ä¸æ›´æ–°è®¿é—®æ—¶é—´ï¼Œä¿æŒTTL
    });
    
    // L2: ç¬¦å·æ˜ å°„ç¼“å­˜ - ç¬¦å·æ˜ å°„ç›¸å¯¹ç¨³å®š
    this.symbolMappingCache = new LRUCache({
      max: l2Config.max,
      ttl: l2Config.ttl,
      updateAgeOnGet: true         // çƒ­é—¨ç¬¦å·å»¶é•¿ç”Ÿå‘½å‘¨æœŸ
    });
    
    // L3: æ‰¹é‡ç»“æœç¼“å­˜ - æ‰¹é‡æŸ¥è¯¢ç»“æœ
    this.batchResultCache = new LRUCache({
      max: l3Config.max,
      ttl: l3Config.ttl,
      updateAgeOnGet: true
    });
    
    this.logger.log('Caches initialized with FeatureFlags and ENV config', {
      l1Rules: l1Config,
      l2Symbols: l2Config,
      l3Batches: l3Config
    });
  }
}
```

### ç»Ÿä¸€æŸ¥è¯¢å…¥å£

```typescript
/**
 * ğŸ¯ ç»Ÿä¸€å…¥å£ï¼šæ”¯æŒå•ä¸ªå’Œæ‰¹é‡æŸ¥è¯¢
 * æ›¿æ¢ç°æœ‰çš„ mapSymbol å’Œ mapSymbols æ–¹æ³•
 */
async mapSymbols(
  provider: string, 
  symbols: string | string[], 
  direction: 'to_standard' | 'from_standard',
  requestId?: string
): Promise<any> { // TODO: ä½¿ç”¨ SymbolMappingResult ç±»å‹
  
  const symbolArray = Array.isArray(symbols) ? symbols : [symbols];
  const isBatch = symbolArray.length > 1;
  const startTime = Date.now();
  
  this.cacheStats.totalQueries++;
  
  try {
    // ğŸ¯ Level 3: æ‰¹é‡ç»“æœç¼“å­˜æ£€æŸ¥
    if (isBatch) {
      const batchKey = this.getBatchCacheKey(provider, symbolArray, direction);
      const batchCached = this.batchResultCache.get(batchKey);
      if (batchCached) {
        this.cacheStats.l3.hits++;
        this.recordCacheMetrics('l3', true);
        return this.cloneResult(batchCached);
      }
      // L3 æœªå‘½ä¸­è®¡æ•°
      this.cacheStats.l3.misses++;
      this.recordCacheMetrics('l3', false);
    }
    
    // ğŸ¯ Level 2: å•ç¬¦å·ç¼“å­˜æ£€æŸ¥
    const cacheHits = new Map<string, string>();
    const uncachedSymbols = [];
    
    for (const symbol of symbolArray) {
      const symbolKey = this.getSymbolCacheKey(provider, symbol, direction);
      const cached = this.symbolMappingCache.get(symbolKey);
      if (cached) {
        cacheHits.set(symbol, cached);
        this.cacheStats.l2.hits++;
        this.recordCacheMetrics('l2', true);
      } else {
        uncachedSymbols.push(symbol);
        this.cacheStats.l2.misses++;  // L2 æœªå‘½ä¸­è®¡æ•°
        this.recordCacheMetrics('l2', false);
      }
    }
    
    // ğŸ¯ Level 1: è§„åˆ™ç¼“å­˜ + æ•°æ®åº“æŸ¥è¯¢
    let uncachedResults = {};
    if (uncachedSymbols.length > 0) {
      // å¹¶å‘æ§åˆ¶ï¼šä½¿ç”¨ä¸æ‰¹é‡ç¼“å­˜å®Œå…¨ç›¸åŒçš„é”®è§„èŒƒï¼ˆåŒ…æ‹¬MD5ï¼‰
      const queryKey = this.getPendingQueryKey(provider, uncachedSymbols, direction);
      
      if (this.pendingQueries.has(queryKey)) {
        uncachedResults = await this.pendingQueries.get(queryKey);
      } else {
        const queryPromise = this.executeUncachedQuery(provider, uncachedSymbols, direction);
        this.pendingQueries.set(queryKey, queryPromise);
        
        try {
          uncachedResults = await queryPromise;
          // ğŸ”„ æ‰¹é‡ç»“æœå›å¡«å•ç¬¦å·ç¼“å­˜ï¼ˆåŒå‘å†™å…¥ï¼‰
          this.backfillSingleSymbolCache(provider, uncachedResults, direction);
        } catch (error) {
          this.logger.error('Uncached query failed', { queryKey, error: error.message });
          throw error;
        } finally {
          this.pendingQueries.delete(queryKey);
        }
      }
    }
    
    // ğŸ¯ åˆå¹¶æ‰€æœ‰ç»“æœ
    const finalResult = this.mergeResults(cacheHits, uncachedResults, symbolArray);
    
    // ğŸ¯ å­˜å‚¨æ‰¹é‡ç»“æœç¼“å­˜ - ç»“æ„æ ¡éªŒåå­˜å‚¨
    if (isBatch && uncachedSymbols.length > 0) {
      const batchKey = this.getBatchCacheKey(provider, symbolArray, direction);
      
      // é‡è¦ï¼šç»“æ„æ ¡éªŒå¹¶è¡¥é½L3ç²¾å‡†å¤±æ•ˆæ‰€éœ€å­—æ®µ
      const validatedResult = this.validateAndFixBatchResult(finalResult);
      
      this.batchResultCache.set(batchKey, validatedResult);
      
      this.logger.debug('Batch result cached with validated structure', {
        batchKey,
        mappingDetailsCount: Object.keys(validatedResult.mappingDetails).length,
        failedSymbolsCount: validatedResult.failedSymbols.length
      });
    }
    
    // ğŸ“Š è®°å½•æ€§èƒ½æŒ‡æ ‡
    this.recordPerformanceMetrics(provider, symbolArray.length, Date.now() - startTime, cacheHits.size);
    
    return finalResult;
    
  } catch (error) {
    this.logger.error('Symbol mapping failed', {
      provider,
      symbolsCount: symbolArray.length,
      direction,
      error: error.message,
      requestId
    });
    throw error;
  }
}
```

### åŒå‘ç¼“å­˜æœºåˆ¶

```typescript
/**
 * ğŸ”„ æ·±æ‹·è´ç»“æœï¼Œé¿å…è°ƒç”¨æ–¹ä¿®æ”¹å½±å“ç¼“å­˜
 */
private cloneResult(result: any): any {
  // æ·±æ‹·è´ç¡®ä¿ç¼“å­˜æ•°æ®ä¸è¢«å¤–éƒ¨ä¿®æ”¹
  return JSON.parse(JSON.stringify(result));
}

/**
 * âœ… æ‰¹é‡ç»“æœç»“æ„æ ¡éªŒä¸ä¿®å¤
 */
private validateAndFixBatchResult(result: any): any { // TODO: ä½¿ç”¨ BatchMappingResult ç±»å‹
  // ç¡®ä¿å¿…éœ€å­—æ®µå­˜åœ¨ï¼Œä¾›L3ç²¾å‡†å¤±æ•ˆä½¿ç”¨
  const validatedResult = { ...result };
  
  if (!validatedResult.mappingDetails || typeof validatedResult.mappingDetails !== 'object') {
    validatedResult.mappingDetails = {};
    this.logger.warn('Missing mappingDetails in batch result, added empty object');
  }
  
  if (!Array.isArray(validatedResult.failedSymbols)) {
    validatedResult.failedSymbols = [];
    this.logger.warn('Missing failedSymbols in batch result, added empty array');
  }
  
  return validatedResult;
}

/**
 * ğŸ”„ åŒå‘ç¼“å­˜å­˜å‚¨ï¼šåŒæ—¶ç¼“å­˜æ­£å‘å’Œåå‘æ˜ å°„
 */
private storeBidirectionalMapping(
  provider: string, 
  standardSymbol: string, 
  providerSymbol: string
): void {
  // æ­£å‘ï¼šprovider â†’ standard
  const forwardKey = this.getSymbolCacheKey(provider, providerSymbol, 'to_standard');
  this.symbolMappingCache.set(forwardKey, standardSymbol);
  
  // åå‘ï¼šstandard â†’ provider  
  const reverseKey = this.getSymbolCacheKey(provider, standardSymbol, 'from_standard');
  this.symbolMappingCache.set(reverseKey, providerSymbol);
  
  this.logger.debug('Bidirectional mapping cached', {
    provider,
    standardSymbol,
    providerSymbol,
    forwardKey,
    reverseKey
  });
}

/**
 * ğŸ¯ ç»Ÿä¸€è§„åˆ™è·å–ï¼ˆå¸¦ç¼“å­˜ï¼‰- é”®ä¸€è‡´æ€§ä¿®æ­£
 */
private async getProviderRules(provider: string): Promise<SymbolMappingRule[]> {
  const rulesKey = this.getProviderRulesKey(provider);  // ä½¿ç”¨ç»Ÿä¸€é”®ç”Ÿæˆ
  const cached = this.providerRulesCache.get(rulesKey);
  if (cached) {
    this.cacheStats.l1.hits++;  // L1æ˜¯è§„åˆ™ç¼“å­˜
    this.recordCacheMetrics('l1', true);  // è®°å½•L1å‘½ä¸­
    return cached;
  }
  
  this.cacheStats.l1.misses++;
  this.recordCacheMetrics('l1', false);  // è®°å½•L1æœªå‘½ä¸­
  
  // æŸ¥è¯¢æ•°æ®åº“è·å–è§„åˆ™
  const mappingConfig = await this.repository.findByDataSource(provider);
  const rules = mappingConfig?.SymbolMappingRule || [];
  
  // å­˜å…¥L1ç¼“å­˜ï¼Œä½¿ç”¨ç»Ÿä¸€é”®
  this.providerRulesCache.set(rulesKey, rules);
  
  this.logger.debug('Provider rules loaded and cached', {
    provider: provider.toLowerCase(),
    rulesKey,
    rulesCount: rules.length
  });
  
  return rules;
}

/**
 * ğŸ”„ æ‰¹é‡å›æºå›å¡«ç­–ç•¥ - è¯¦ç»†å®ç°è§„åˆ™
 */
private backfillSingleSymbolCache(
  provider: string, 
  uncachedResults: Record<string, string>, 
  direction: 'to_standard' | 'from_standard'
): void {
  // uncachedResults æ ¼å¼ï¼š{ [originalSymbol]: mappedSymbol }
  // éå†æˆåŠŸæ˜ å°„çš„ç»“æœï¼Œå¤±è´¥é¡¹ä¸å›å¡«
  
  for (const [originalSymbol, mappedSymbol] of Object.entries(uncachedResults)) {
    // è·³è¿‡æ˜ å°„å¤±è´¥çš„é¡¹ï¼ˆå€¼ä¸º nullã€undefined æˆ–ç©ºå­—ç¬¦ä¸²ï¼‰
    if (!mappedSymbol) {
      continue;
    }
    
    // ç¼“å­˜å½“å‰æ–¹å‘çš„æ˜ å°„
    const currentKey = this.getSymbolCacheKey(provider, originalSymbol, direction);
    this.symbolMappingCache.set(currentKey, mappedSymbol);
    
    // åŒæ­¥åŒå‘å›å¡«ï¼šç¼“å­˜åå‘æ˜ å°„
    const reverseDirection = direction === 'to_standard' ? 'from_standard' : 'to_standard';
    const reverseKey = this.getSymbolCacheKey(provider, mappedSymbol, reverseDirection);
    this.symbolMappingCache.set(reverseKey, originalSymbol);
    
    this.logger.debug('Bidirectional backfill completed', {
      provider: provider.toLowerCase(),
      originalSymbol,
      mappedSymbol,
      direction,
      currentKey,
      reverseKey
    });
  }
  
  this.logger.info('Batch backfill completed', {
    provider: provider.toLowerCase(),
    direction,
    successCount: Object.keys(uncachedResults).filter(key => uncachedResults[key]).length,
    totalCount: Object.keys(uncachedResults).length
  });
}
```

### æ™ºèƒ½é¢„åŠ è½½æœºåˆ¶

```typescript
/**
 * ğŸ“Š æ™ºèƒ½é¢„åŠ è½½ï¼šåŸºäºä½¿ç”¨æ¨¡å¼é¢„åŠ è½½çƒ­é—¨ç¬¦å·
 */
async preloadHotSymbols(provider: string, hotSymbols: string[]): Promise<void> {
  const startTime = Date.now();
  
  try {
    // è·å–è§„åˆ™ï¼ˆå¯èƒ½å‘½ä¸­L1ç¼“å­˜ï¼‰
    const rules = await this.getProviderRules(provider);
    
    // æ‰¹é‡é¢„åŠ è½½ï¼Œå‡å°‘æ•°æ®åº“æŸ¥è¯¢
    const preloadPromises = hotSymbols.map(async (symbol) => {
      // åŒå‘é¢„åŠ è½½
      await this.preloadSymbolMapping(provider, symbol, rules, 'to_standard');
      await this.preloadSymbolMapping(provider, symbol, rules, 'from_standard');
    });
    
    await Promise.all(preloadPromises);
    
    this.logger.info('Hot symbols preloaded', {
      provider,
      symbolsCount: hotSymbols.length,
      preloadTime: Date.now() - startTime
    });
    
  } catch (error) {
    this.logger.error('Preload failed', {
      provider,
      symbolsCount: hotSymbols.length,
      error: error.message
    });
  }
}

private async preloadSymbolMapping(
  provider: string,
  symbol: string,
  rules: SymbolMappingRule[],
  direction: 'to_standard' | 'from_standard'
): Promise<void> {
  const cacheKey = this.getSymbolCacheKey(provider, symbol, direction);
  
  // å¦‚æœå·²ç»ç¼“å­˜ï¼Œè·³è¿‡
  if (this.symbolMappingCache.has(cacheKey)) {
    return;
  }
  
  // åº”ç”¨è§„åˆ™å¹¶ç¼“å­˜ç»“æœ
  const mappedSymbol = this.applyMappingRules(symbol, rules, direction);
  if (mappedSymbol) {
    this.symbolMappingCache.set(cacheKey, mappedSymbol);
    
    // å¦‚æœæ˜¯åŒå‘æ˜ å°„ï¼ŒåŒæ—¶ç¼“å­˜åå‘
    if (direction === 'to_standard') {
      this.storeBidirectionalMapping(provider, mappedSymbol, symbol);
    } else {
      this.storeBidirectionalMapping(provider, symbol, mappedSymbol);
    }
  }
}
```

### ç¼“å­˜é”®ç”Ÿæˆç­–ç•¥

```typescript
/**
 * ğŸ”‘ ç¼“å­˜é”®ç”Ÿæˆç­–ç•¥ - ç¡®ä¿ç¨³å®šæ€§å’Œä¸€è‡´æ€§
 */
private getSymbolCacheKey(provider: string, symbol: string, direction: 'to_standard' | 'from_standard'): string {
  // æ ‡å‡†åŒ–provideråç§°ï¼ˆå°å†™ï¼‰é¿å…å¤§å°å†™å¯¼è‡´çš„ç¼“å­˜miss
  const normalizedProvider = provider.toLowerCase();
  return `symbol:${normalizedProvider}:${direction}:${symbol}`;
}

/**
 * ğŸ”‘ ç»Ÿä¸€é”®ç”Ÿæˆæ–¹æ³• - ç¡®ä¿æ‰¹é‡ç¼“å­˜ä¸å¹¶å‘æ§åˆ¶ä½¿ç”¨ç›¸åŒè§„æ ¼
 */
private generateConsistentKey(prefix: string, provider: string, symbols: string[], direction: 'to_standard' | 'from_standard'): string {
  const normalizedProvider = provider.toLowerCase();
  const sortedSymbols = [...symbols].sort().join(',');
  const symbolsHash = crypto.createHash('md5').update(sortedSymbols).digest('hex');
  return `${prefix}:${normalizedProvider}:${direction}:${symbolsHash}`;
}

private getBatchCacheKey(provider: string, symbols: string[], direction: 'to_standard' | 'from_standard'): string {
  return this.generateConsistentKey('batch', provider, symbols, direction);
}

private getPendingQueryKey(provider: string, symbols: string[], direction: 'to_standard' | 'from_standard'): string {
  return this.generateConsistentKey('pending', provider, symbols, direction);
}

private getProviderRulesKey(provider: string): string {
  const normalizedProvider = provider.toLowerCase();
  return `rules:${normalizedProvider}`;
}

/**
 * ğŸ“Š ç¬¦å·æ•°é‡èŒƒå›´åˆ†ç±»ï¼ˆç”¨äºç›‘æ§æ ‡ç­¾ï¼‰
 */
private getSymbolsCountRange(count: number): string {
  if (count === 1) return 'single';
  if (count <= 5) return 'small';
  if (count <= 20) return 'medium';
  if (count <= 100) return 'large';
  return 'bulk';
}
```

### ğŸ”§ å®æ–½ç»†èŠ‚æç¤º

**é‡è¦ä¾èµ–å’Œå®ç°è¦ç‚¹**ï¼š

1. **MD5 å“ˆå¸Œä¾èµ–**ï¼š`getBatchCacheKey()` ä½¿ç”¨ `crypto.createHash('md5')`ï¼Œéœ€ç¡®ä¿å¼•å…¥ Node.js å†…ç½® `crypto` æ¨¡å—
2. **è§„åˆ™æŸ¥è¯¢è·¯å¾„**ï¼š`executeUncachedQuery()` æ–¹æ³•å†…éƒ¨å¿…é¡»å…ˆè°ƒç”¨ `getProviderRules(provider)` ç¡®ä¿èµ° L1 è§„åˆ™ç¼“å­˜
3. **ç›‘æ§æ ‡ç­¾è§„èŒƒ**ï¼šæ‰€æœ‰ `cache_type` æ ‡ç­¾ä½¿ç”¨å°å†™æ ¼å¼ `symbol_mapping_l{1|2|3}`ï¼Œä¿æŒ PromQL æŸ¥è¯¢ä¸€è‡´æ€§
4. **å¹¶å‘é”®ä¸€è‡´æ€§**ï¼šæ‰¹é‡ç¼“å­˜é”®ä¸å¹¶å‘æ§åˆ¶é”®å¿…é¡»ä½¿ç”¨å®Œå…¨ç›¸åŒçš„è§„æ ¼ï¼ˆprovider å°å†™åŒ– + ç¬¦å·æ’åº + direction + å“ˆå¸Œï¼‰
5. **è§„åˆ™æŸ¥è¯¢å®ç°**ï¼š`executeUncachedQuery()` å†…éƒ¨å…ˆè°ƒç”¨ `getProviderRules(provider)` å†åº”ç”¨è§„åˆ™ï¼Œç¡®ä¿èµ° L1 è§„åˆ™ç¼“å­˜
6. **æ‰¹é‡ç¼“å­˜æ•°æ®ç»“æ„**ï¼š`finalResult` å†™å…¥ L3 ç¼“å­˜å‰å¿…é¡»ç¡®ä¿åŒ…å« `mappingDetails` å’Œ `failedSymbols` å­—æ®µï¼Œå¦åˆ™ L3 ç²¾å‡†å¤±æ•ˆæ— æ³•æ­£ç¡®å‘½ä¸­
7. **æ·±æ‹·è´ä¿æŠ¤**ï¼š`cloneResult()` å¿…é¡»è¿›è¡Œæ·±æ‹·è´ï¼Œé¿å…è°ƒç”¨æ–¹ä¿®æ”¹åŒä¸€å¼•ç”¨å½±å“ç¼“å­˜
8. **ç»Ÿè®¡å‡†ç¡®æ€§**ï¼šå„å±‚å‘½ä¸­ç‡ä½¿ç”¨å±‚å†…æ€»æ¬¡æ•°ä½œä¸ºåˆ†æ¯ï¼Œé¿å…é‡çº²ä¸åŒå¯¼è‡´æ¯”ä¾‹å¼‚å¸¸
9. **å¹¶å‘é”®ä¸€è‡´æ€§**ï¼šæ‰¹é‡ç¼“å­˜é”®ä¸å¹¶å‘æ§åˆ¶é”®ä½¿ç”¨ç»Ÿä¸€çš„ `generateConsistentKey()` æ–¹æ³•ï¼Œç¡®ä¿å®Œå…¨ä¸€è‡´ï¼ˆåŒ…æ‹¬MD5å“ˆå¸Œï¼‰
10. **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šChange Stream ç›‘å¬ä»…åœ¨ `onModuleInit()` ä¸­å¯åŠ¨ä¸€æ¬¡ï¼Œ`onModuleDestroy()` ä¸­æ¸…ç†èµ„æº
11. **missesè®¡æ•°å®Œæ•´æ€§**ï¼šL2/L3 åœ¨æœªå‘½ä¸­æ—¶æ­£ç¡®è‡ªå¢ `misses` è®¡æ•°ï¼Œç¡®ä¿ç»Ÿè®¡å‡†ç¡®æ€§
12. **æŒ‡æ ‡ç­–ç•¥æ˜ç¡®åŒ–**ï¼šä¸è®¡ç®— `overallHitRatio`ï¼ˆé¿å…>100%é—®é¢˜ï¼‰ï¼Œä»…ä»¥å„å±‚å‘½ä¸­ç‡ä¸ºä¸»è¦æŒ‡æ ‡
13. **é…ç½®ç®¡ç†ç»Ÿä¸€åŒ–**ï¼šç»Ÿä¸€ä½¿ç”¨FeatureFlagså­—æ®µé…ç½® - L1: `ruleCacheMaxSize`/`ruleCacheTtl`, L2: `symbolCacheMaxSize`/`symbolCacheTtl`, L3: `batchResultCacheMaxSize`/`batchResultCacheTtl` (æ–°å¢)

### å˜æ›´å¤±æ•ˆç­–ç•¥

```typescript
/**
 * ğŸ“¡ åŸºäºMongoDB Change Streamçš„ç¼“å­˜å¤±æ•ˆç­–ç•¥
 * æ³¨æ„ï¼šå…·ä½“å®ç°æŒ‰ç°æœ‰repository.watchChanges()äº‹ä»¶æ¨¡å‹å¯¹é½
 * äº‹ä»¶ç»“æ„ï¼š{ operationType, documentKey, fullDocument }
 * é‡è¦ï¼šä»…åœ¨ onModuleInit() ä¸­è°ƒç”¨ä¸€æ¬¡ï¼Œé¿å…é‡å¤ç›‘å¬
 */
private setupChangeStreamMonitoring(): void {
  try {
    // äº‹ä»¶æµæ¨¡å¼ï¼ˆä¸ç°å®ç°å¯¹é½ï¼‰
    this.changeStream = this.repository.watchChanges();
    this.changeStream.on('change', async (change) => {
      const provider = await this.extractProviderFromChangeEvent(change);
      if (provider) {
        this.invalidateCacheForProvider(provider);
      }
    });
    
    // é”™è¯¯äº‹ä»¶å¤„ç†
    this.changeStream.on('error', (error) => {
      this.logger.error('Change Stream å‘ç”Ÿé”™è¯¯', { error: error.message });
      // å¯é€‰ï¼šåœ¨è¿™é‡Œå®ç°é‡è¿é€»è¾‘
    });
    
    // å…³é—­äº‹ä»¶å¤„ç†
    this.changeStream.on('close', () => {
      this.logger.warn('Change Stream å·²å…³é—­');
    });
    
    this.logger.log('Change stream monitoring setup completed');
  } catch (error) {
    this.logger.error('Failed to setup change stream monitoring', {
      error: error.message
    });
    // ä¸é˜»æ–­æœåŠ¡å¯åŠ¨ï¼Œå¯é™çº§ä¸ºå®šæ—¶åˆ·æ–°
  }
}

/**
 * ğŸ” ä»å˜æ›´äº‹ä»¶ä¸­æå–provideråç§°
 * åŸºäºç°ç½‘äº‹ä»¶ç»“æ„ï¼šoperationType/documentKey/fullDocument
 */
private async extractProviderFromChangeEvent(change: any): Promise<string | null> {
  try {
    // 1. ä¼˜å…ˆä½¿ç”¨ fullDocument.dataSourceNameï¼ˆinsert/replace/éƒ¨åˆ†updateæœ‰ï¼‰
    if (change.fullDocument?.dataSourceName) {
      return change.fullDocument.dataSourceName;
    }
    
    // 2. delete/éƒ¨åˆ†updateæ— fullDocumentï¼Œé€šè¿‡documentKey._idå›æŸ¥
    if (change.documentKey?._id) {
      this.logger.debug('No fullDocument, querying by documentKey._id', {
        operationType: change.operationType,
        documentId: change.documentKey._id
      });
      
      const doc = await this.repository.findById(change.documentKey._id);
      if (doc?.dataSourceName) {
        return doc.dataSourceName;
      }
    }
    
    // 3. æ— æ³•è·å–providerï¼Œè®°å½•è­¦å‘Šä½†ä¸é˜»æ–­
    this.logger.warn('Cannot extract provider from change event, skipping invalidation', {
      operationType: change.operationType,
      hasFullDocument: !!change.fullDocument,
      hasDocumentKey: !!change.documentKey,
      documentKeyId: change.documentKey?._id
    });
    
    return null;
    
  } catch (error) {
    this.logger.error('Failed to extract provider from change event', {
      error: error.message,
      changeEvent: {
        operationType: change.operationType,
        hasFullDocument: !!change.fullDocument,
        hasDocumentKey: !!change.documentKey
      }
    });
    
    // å‘ç”Ÿé”™è¯¯æ—¶ï¼Œå¯é€‰æ‹©é™çº§ä¸ºå…¨é‡å¤±æ•ˆæˆ–è·³è¿‡
    // è¿™é‡Œé€‰æ‹©è·³è¿‡ï¼Œé¿å…è¯¯åˆ æ‰€æœ‰ç¼“å­˜
    return null;
  }
}

/**
 * ğŸ”„ æ™ºèƒ½å·®å¼‚åŒ–å¤±æ•ˆç­–ç•¥ - ä»…å¤±æ•ˆå—å½±å“çš„ç¼“å­˜æ¡ç›®
 * ç‰¹åˆ«å¤„ç†deleteäº‹ä»¶çš„è¾¹ç•Œæƒ…å†µ
 */
private async invalidateCacheForProvider(provider: string): Promise<void> {
  const normalizedProvider = provider.toLowerCase();
  const startTime = Date.now();
  
  try {
    // 1. è·å–æ—§è§„åˆ™ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    const rulesKey = this.getProviderRulesKey(provider);
    const oldRules = this.providerRulesCache.get(rulesKey);
    
    // 2. å¼ºåˆ¶åˆ·æ–°è§„åˆ™ç¼“å­˜ï¼Œè·å–æ–°è§„åˆ™
    this.providerRulesCache.delete(rulesKey);
    
    let newRules;
    try {
      newRules = await this.getProviderRules(provider);
    } catch (error) {
      // deleteäº‹ä»¶å¯èƒ½å¯¼è‡´æŸ¥è¯¢å¤±è´¥ï¼Œæ­¤æ—¶åº”å…¨é‡å¤±æ•ˆ
      this.logger.warn('Failed to fetch new rules after change event, likely delete operation', {
        provider: normalizedProvider,
        error: error.message
      });
      await this.invalidateAllCacheForProvider(normalizedProvider);
      return;
    }
    
    // 3. å¦‚æœæ˜¯é¦–æ¬¡åŠ è½½æˆ–æ— æ—§è§„åˆ™ï¼Œæ¸…ç©ºæ‰€æœ‰ç›¸å…³ç¼“å­˜
    if (!oldRules || oldRules.length === 0) {
      await this.invalidateAllCacheForProvider(normalizedProvider);
      return;
    }
    
    // 4. deleteäº‹ä»¶ç‰¹æ®Šå¤„ç†ï¼šæ–°è§„åˆ™ä¸ºç©ºæˆ–æ˜æ˜¾å‡å°‘ï¼Œæ‰§è¡Œå…¨é‡å¤±æ•ˆ
    if (!newRules || newRules.length === 0 || newRules.length < oldRules.length * 0.5) {
      this.logger.info('Detected significant rule reduction or deletion, performing full invalidation', {
        provider: normalizedProvider,
        oldRulesCount: oldRules.length,
        newRulesCount: newRules?.length || 0
      });
      await this.invalidateAllCacheForProvider(normalizedProvider);
      return;
    }
    
    // 5. è®¡ç®—è§„åˆ™å·®å¼‚ï¼Œæ™ºèƒ½å¤±æ•ˆ - åŸºäºç¬¦å·å¯¹å·®åˆ†
    const affectedSymbolPairs = this.calculateRuleDifferences(oldRules, newRules);
    
    if (affectedSymbolPairs.length === 0) {
      this.logger.debug('No rule changes detected, cache preserved', {
        provider: normalizedProvider,
        oldRulesCount: oldRules.length,
        newRulesCount: newRules.length
      });
      return;
    }
    
    // 6. ç²¾å‡†å¤±æ•ˆå—å½±å“çš„ç¬¦å·æ˜ å°„å’Œæ‰¹é‡ç¼“å­˜
    const invalidationStats = await this.invalidateAffectedCache(normalizedProvider, affectedSymbolPairs);
    
    this.logger.info('Smart cache invalidation completed', {
      provider: normalizedProvider,
      affectedSymbolPairs: affectedSymbolPairs.length,
      invalidationStats,
      processingTime: Date.now() - startTime
    });
    
  } catch (error) {
    this.logger.error('Smart invalidation failed, falling back to full invalidation', {
      provider: normalizedProvider,
      error: error.message
    });
    
    // é™çº§ç­–ç•¥ï¼šå®Œå…¨å¤±æ•ˆ
    await this.invalidateAllCacheForProvider(normalizedProvider);
  }
}

/**
 * ğŸ“Š è®¡ç®—è§„åˆ™å·®å¼‚ï¼Œè¯†åˆ«å—å½±å“çš„ç¬¦å·å¯¹
 * æŒ‰ (standardSymbol, sdkSymbol, isActive) å·®åˆ†ï¼Œç¬¦åˆå®é™…æ•°æ®æ¨¡å‹
 */
private calculateRuleDifferences(
  oldRules: SymbolMappingRule[], 
  newRules: SymbolMappingRule[]
): Array<{ standardSymbol: string; sdkSymbol: string }> {
  const affectedSymbolPairs: Set<string> = new Set();
  
  // åˆ›å»ºè§„åˆ™æ˜ å°„ä»¥ä¾¿å¿«é€Ÿæ¯”è¾ƒ - ä½¿ç”¨ç¬¦å·å¯¹ä½œä¸ºé”®
  const oldRuleMap = new Map(oldRules.map(rule => [
    `${rule.standardSymbol}|${rule.sdkSymbol}`, 
    rule
  ]));
  const newRuleMap = new Map(newRules.map(rule => [
    `${rule.standardSymbol}|${rule.sdkSymbol}`, 
    rule
  ]));
  
  // æ£€æŸ¥å·²åˆ é™¤çš„è§„åˆ™
  for (const [symbolPairKey, oldRule] of oldRuleMap) {
    if (!newRuleMap.has(symbolPairKey)) {
      affectedSymbolPairs.add(symbolPairKey);
      this.logger.debug('Rule deleted', {
        standardSymbol: oldRule.standardSymbol,
        sdkSymbol: oldRule.sdkSymbol,
        oldRule
      });
    }
  }
  
  // æ£€æŸ¥æ–°å¢çš„è§„åˆ™
  for (const [symbolPairKey, newRule] of newRuleMap) {
    if (!oldRuleMap.has(symbolPairKey)) {
      affectedSymbolPairs.add(symbolPairKey);
      this.logger.debug('Rule added', {
        standardSymbol: newRule.standardSymbol,
        sdkSymbol: newRule.sdkSymbol,
        newRule
      });
    }
  }
  
  // æ£€æŸ¥ä¿®æ”¹çš„è§„åˆ™
  for (const [symbolPairKey, newRule] of newRuleMap) {
    const oldRule = oldRuleMap.get(symbolPairKey);
    if (oldRule && this.isRuleModified(oldRule, newRule)) {
      affectedSymbolPairs.add(symbolPairKey);
      this.logger.debug('Rule modified', {
        standardSymbol: newRule.standardSymbol,
        sdkSymbol: newRule.sdkSymbol,
        oldRule,
        newRule
      });
    }
  }
  
  // è½¬æ¢ä¸ºç¬¦å·å¯¹æ•°ç»„
  return Array.from(affectedSymbolPairs).map(pairKey => {
    const [standardSymbol, sdkSymbol] = pairKey.split('|');
    return { standardSymbol, sdkSymbol };
  });
}

/**
 * ğŸ” åˆ¤æ–­è§„åˆ™æ˜¯å¦å‘ç”Ÿå®è´¨æ€§ä¿®æ”¹
 * åŸºäºå®é™… SymbolMappingRule æ•°æ®æ¨¡å‹ (standardSymbol, sdkSymbol, market, symbolType, isActive)
 */
private isRuleModified(oldRule: SymbolMappingRule, newRule: SymbolMappingRule): boolean {
  // æ¯”è¾ƒå…³é”®å­—æ®µ - å¯¹é½å®é™…æ•°æ®æ¨¡å‹ï¼Œæ’é™¤ä¸å­˜åœ¨çš„priorityå­—æ®µ
  return (
    oldRule.isActive !== newRule.isActive ||     // æ´»è·ƒçŠ¶æ€å˜åŒ–
    oldRule.market !== newRule.market ||         // å¸‚åœºå­—æ®µå˜åŒ–
    oldRule.symbolType !== newRule.symbolType    // ç¬¦å·ç±»å‹å˜åŒ–
    // æ³¨æ„ï¼šstandardSymbol å’Œ sdkSymbol åœ¨é”®æ¯”è¾ƒä¸­å·²å¤„ç†ï¼Œè¿™é‡Œä¸»è¦æ£€æŸ¥å…¶ä»–å­—æ®µ
    // priorityå­—æ®µåœ¨å½“å‰æ¨¡å‹ä¸­ä¸å­˜åœ¨ï¼Œå·²ç§»é™¤
  );
}

/**
 * ğŸ¯ ç²¾å‡†å¤±æ•ˆå—å½±å“çš„ç¼“å­˜æ¡ç›®
 * åŸºäºç¬¦å·å¯¹è¿›è¡Œç²¾å‡†åŒ¹é…ï¼Œè€Œéæ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼
 */
private async invalidateAffectedCache(
  provider: string, 
  affectedSymbolPairs: Array<{ standardSymbol: string; sdkSymbol: string }>
): Promise<{ symbolsInvalidated: number; batchesInvalidated: number }> {
  let symbolsInvalidated = 0;
  let batchesInvalidated = 0;
  
  // æ„å»ºå—å½±å“ç¬¦å·çš„æŸ¥æ‰¾é›†åˆï¼ˆåŒå‘ï¼‰
  const affectedSymbols = new Set<string>();
  
  for (const { standardSymbol, sdkSymbol } of affectedSymbolPairs) {
    affectedSymbols.add(standardSymbol);
    affectedSymbols.add(sdkSymbol);
  }
  
  // L2: ç²¾å‡†å¤±æ•ˆç¬¦å·æ˜ å°„ç¼“å­˜ - åŸºäºç¬¦å·å¯¹ç²¾ç¡®åŒ¹é…
  try {
    for (const [key] of this.symbolMappingCache) {
      if (key.startsWith(`symbol:${provider}:`)) {
        const symbol = this.extractSymbolFromCacheKey(key);
        if (affectedSymbols.has(symbol)) {
          this.symbolMappingCache.delete(key);
          symbolsInvalidated++;
          
          this.logger.debug('Symbol cache invalidated', {
            provider,
            cacheKey: key,
            symbol
          });
        }
      }
    }
  } catch {
    // é™çº§ï¼šä½¿ç”¨keys()æ–¹æ³•
    for (const key of this.symbolMappingCache.keys()) {
      if (key.startsWith(`symbol:${provider}:`)) {
        const symbol = this.extractSymbolFromCacheKey(key);
        if (affectedSymbols.has(symbol)) {
          this.symbolMappingCache.delete(key);
          symbolsInvalidated++;
        }
      }
    }
  }
  
  // L3: å¤±æ•ˆåŒ…å«å—å½±å“ç¬¦å·çš„æ‰¹é‡ç¼“å­˜
  try {
    for (const [key, batchResult] of this.batchResultCache) {
      if (key.startsWith(`batch:${provider}:`)) {
        if (this.isBatchAffectedBySymbols(batchResult, affectedSymbols)) {
          this.batchResultCache.delete(key);
          batchesInvalidated++;
          
          this.logger.debug('Batch cache invalidated', {
            provider,
            cacheKey: key,
            affectedSymbolsCount: affectedSymbols.size
          });
        }
      }
    }
  } catch {
    // é™çº§ï¼šä½¿ç”¨keys()æ–¹æ³•
    for (const key of this.batchResultCache.keys()) {
      if (key.startsWith(`batch:${provider}:`)) {
        const batchResult = this.batchResultCache.get(key);
        if (batchResult && this.isBatchAffectedBySymbols(batchResult, affectedSymbols)) {
          this.batchResultCache.delete(key);
          batchesInvalidated++;
        }
      }
    }
  }
  
  return { symbolsInvalidated, batchesInvalidated };
}

/**
 * ğŸ” åˆ¤æ–­æ‰¹é‡ç»“æœæ˜¯å¦å—ç¬¦å·å˜æ›´å½±å“
 * åŸºäºç²¾ç¡®ç¬¦å·åŒ¹é…ï¼Œè€Œéæ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼
 */
private isBatchAffectedBySymbols(batchResult: any, affectedSymbols: Set<string>): boolean { // TODO: ä½¿ç”¨ BatchMappingResult ç±»å‹
  // æ£€æŸ¥æ‰¹é‡ç»“æœä¸­æ˜¯å¦åŒ…å«å—å½±å“çš„ç¬¦å·
  const allSymbols = [
    ...Object.keys(batchResult.mappingDetails || {}),
    ...Object.values(batchResult.mappingDetails || {}),
    ...(batchResult.failedSymbols || [])
  ];
  
  return allSymbols.some(symbol => affectedSymbols.has(symbol));
}

/**
 * ğŸ”§ ä»ç¼“å­˜é”®æå–ç¬¦å·
 */
private extractSymbolFromCacheKey(cacheKey: string): string {
  // ç¼“å­˜é”®æ ¼å¼: symbol:provider:direction:symbol
  const parts = cacheKey.split(':');
  return parts.length >= 4 ? parts.slice(3).join(':') : '';
}

/**
 * ğŸ”„ é™çº§ç­–ç•¥ï¼šå®Œå…¨å¤±æ•ˆæ‰€æœ‰ç›¸å…³ç¼“å­˜
 */
private async invalidateAllCacheForProvider(provider: string): Promise<void> {
  const symbolPrefix = `symbol:${provider}:`;
  const batchPrefix = `batch:${provider}:`;
  
  let symbolsInvalidated = 0;
  let batchesInvalidated = 0;
  
  // æ¸…ç©ºæ‰€æœ‰ç¬¦å·æ˜ å°„ç¼“å­˜
  try {
    for (const [key] of this.symbolMappingCache) {
      if (key.startsWith(symbolPrefix)) {
        this.symbolMappingCache.delete(key);
        symbolsInvalidated++;
      }
    }
  } catch {
    for (const key of this.symbolMappingCache.keys()) {
      if (key.startsWith(symbolPrefix)) {
        this.symbolMappingCache.delete(key);
        symbolsInvalidated++;
      }
    }
  }
  
  // æ¸…ç©ºæ‰€æœ‰æ‰¹é‡ç¼“å­˜
  try {
    for (const [key] of this.batchResultCache) {
      if (key.startsWith(batchPrefix)) {
        this.batchResultCache.delete(key);
        batchesInvalidated++;
      }
    }
  } catch {
    for (const key of this.batchResultCache.keys()) {
      if (key.startsWith(batchPrefix)) {
        this.batchResultCache.delete(key);
        batchesInvalidated++;
      }
    }
  }
  
  this.logger.info('Full cache invalidation completed', {
    provider,
    symbolsInvalidated,
    batchesInvalidated
  });
}
```

### æ€§èƒ½ç›‘æ§å’Œç»Ÿè®¡

```typescript
/**
 * ğŸ“Š ç›‘æ§æŒ‡æ ‡ç­–ç•¥ - é¿å…æŒ‡æ ‡ç±»å‹å†²çª
 */
private recordCacheMetrics(level: 'l1'|'l2'|'l3', isHit: boolean): void {
  // å¤ç”¨ç°æœ‰çš„ streamCacheHitRateï¼Œä»…ä½¿ç”¨å®šä¹‰ä¸­çš„ cache_type æ ‡ç­¾
  // é¿å…æ·»åŠ é¢å¤–æ ‡ç­¾å¯¼è‡´ prom-client æ ‡ç­¾ä¸åŒ¹é…æŠ¥é”™
  // ç»Ÿä¸€ä½¿ç”¨ Metrics.inc å°è£…ï¼Œä¸ç°ç½‘ä¿æŒä¸€è‡´
  Metrics.inc(
    this.metricsRegistry,
    'streamCacheHitRate',
    { 
      cache_type: `symbol_mapping_${level}`  // symbol_mapping_l1/l2/l3
    },
    isHit ? 100 : 0
  );
}

private recordPerformanceMetrics(
  provider: string, 
  symbolsCount: number, 
  processingTime: number,
  cacheHits: number
): void {
  const hitRatio = (cacheHits / symbolsCount) * 100;
  
  // é¿å…ä¸Counterç±»å‹çš„streamCacheHitRateå†²çª
  // æ–¹å¼1ï¼šä»…è®°å½•æ—¥å¿—ï¼Œä¸æ–°å¢æŒ‡æ ‡
  this.logger.info('Symbol mapping performance', {
    provider: provider.toLowerCase(),
    symbolsCount,
    processingTime,
    hitRatio,
    cacheEfficiency: hitRatio > 80 ? 'high' : hitRatio > 50 ? 'medium' : 'low'
  });
  
  // æ–¹å¼2ï¼šå¦‚æœéœ€è¦å‘½ä¸­ç‡æŒ‡æ ‡ï¼Œç»Ÿä¸€ä½¿ç”¨ Metrics.inc å°è£…
  /*
  Metrics.inc(
    this.metricsRegistry,
    'symbolMapperCacheHitRatio',  // å¦‚æœæ–°å¢æ­¤æŒ‡æ ‡
    { 
      provider: provider.toLowerCase()
    },
    hitRatio
  );
  */
}

/**
 * ğŸ“Š æ‰©å±•ç›‘æ§æŒ‡æ ‡ï¼ˆå¯é€‰ - å¦‚éœ€è¦æ–°æŒ‡æ ‡ï¼‰
 */
private initializeNewMetrics(): void {
  // å¦‚æœå†³å®šä½¿ç”¨æ–°æŒ‡æ ‡ï¼Œéœ€è¦åœ¨ PresenterRegistryService ä¸­æ³¨å†Œ
  // ç¤ºä¾‹ï¼š
  /*
  this.metricsRegistry.symbolMapperCacheHits = new Counter({
    name: 'symbol_mapper_cache_hits_total',
    help: 'Symbol Mapper cache hits',
    labelNames: ['cache_level', 'provider', 'symbols_count_range']
  });
  
  this.metricsRegistry.symbolMapperProcessingTime = new Histogram({
    name: 'symbol_mapper_processing_duration_seconds',
    help: 'Symbol Mapper processing time',
    labelNames: ['provider', 'cache_efficiency']
  });
  */
}

/**
 * ğŸ” ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯ - ä½¿ç”¨å±‚å†…æ€»æ¬¡æ•°ä½œä¸ºåˆ†æ¯ï¼Œé¿å…æ¯”ä¾‹å¼‚å¸¸
 */
getCacheStats(): CacheStatsDto {
  const l1Total = this.cacheStats.l1.hits + this.cacheStats.l1.misses;
  const l2Total = this.cacheStats.l2.hits + this.cacheStats.l2.misses;
  const l3Total = this.cacheStats.l3.hits + this.cacheStats.l3.misses;
  
  return {
    totalQueries: this.cacheStats.totalQueries,
    
    // å„å±‚å‘½ä¸­ç‡ï¼šä½¿ç”¨å±‚å†…æ€»æ¬¡æ•°ä½œä¸ºåˆ†æ¯
    l1HitRatio: l1Total > 0 ? (this.cacheStats.l1.hits / l1Total) * 100 : 0,
    l2HitRatio: l2Total > 0 ? (this.cacheStats.l2.hits / l2Total) * 100 : 0,
    l3HitRatio: l3Total > 0 ? (this.cacheStats.l3.hits / l3Total) * 100 : 0,
    
    // æ³¨æ„ï¼šä¸è®¡ç®— overallHitRatioï¼Œå› ä¸ºä¸€æ¬¡æŸ¥è¯¢å¯èƒ½äº§ç”Ÿå¤šä¸ªå±‚çº§å‘½ä¸­ï¼Œå¯¼è‡´æ¯”ä¾‹ > 100%
    // å»ºè®®ä½¿ç”¨å„å±‚å‘½ä¸­ç‡ä½œä¸ºä¸»è¦æŒ‡æ ‡
    // overallHitRatio: 'Use individual layer ratios for accurate metrics',
    
    // è¯¦ç»†è®¡æ•°
    layerStats: {
      l1: { hits: this.cacheStats.l1.hits, misses: this.cacheStats.l1.misses, total: l1Total },
      l2: { hits: this.cacheStats.l2.hits, misses: this.cacheStats.l2.misses, total: l2Total },
      l3: { hits: this.cacheStats.l3.hits, misses: this.cacheStats.l3.misses, total: l3Total }
    },
    
    cacheSize: {
      l1: this.providerRulesCache.size,    // L1: è§„åˆ™ç¼“å­˜
      l2: this.symbolMappingCache.size,    // L2: ç¬¦å·æ˜ å°„ç¼“å­˜
      l3: this.batchResultCache.size       // L3: æ‰¹é‡ç»“æœç¼“å­˜
    }
  };
}
```

## ğŸ”§ å®æ–½è®¡åˆ’

### å®æ–½å‰æï¼šé…ç½®ä¸å…¼å®¹æ€§è®¾è®¡

#### é…ç½®ç®¡ç†ç­–ç•¥
```typescript
// ç»Ÿä¸€ä½¿ç”¨ FeatureFlags å­—æ®µé…ç½®ï¼ŒL3 éœ€æ–°å¢å­—æ®µ

// L1 è§„åˆ™ç¼“å­˜é…ç½® (ç°æœ‰å­—æ®µ)
const ruleCacheMaxSize = this.featureFlags.ruleCacheMaxSize || 100;
const ruleCacheTtl = this.featureFlags.ruleCacheTtl || 24 * 60 * 60 * 1000; // 24å°æ—¶

// L2 ç¬¦å·ç¼“å­˜é…ç½® (ç°æœ‰å­—æ®µ)  
const symbolCacheMaxSize = this.featureFlags.symbolCacheMaxSize || 50000;
const symbolCacheTtl = this.featureFlags.symbolCacheTtl || 12 * 60 * 60 * 1000; // 12å°æ—¶

// L3 æ‰¹é‡ç»“æœç¼“å­˜é…ç½® (æ–°å¢ FeatureFlags å­—æ®µ)
const batchCacheMax = this.featureFlags.batchResultCacheMaxSize || 1000;
const batchCacheTtl = this.featureFlags.batchResultCacheTtl || 2 * 60 * 60 * 1000; // 2å°æ—¶

// ğŸ¯ éœ€è¦åœ¨ FeatureFlags ä¸­æ–°å¢çš„å­—æ®µ:
// - batchResultCacheMaxSize: number  // L3 æ‰¹é‡ç»“æœç¼“å­˜æœ€å¤§æ¡ç›®æ•°
// - batchResultCacheTtl: number      // L3 æ‰¹é‡ç»“æœç¼“å­˜ç”Ÿå­˜æ—¶é—´ (ms)
//
// ğŸ“ å®æ–½æé†’: åŒæ­¥åœ¨ FeatureFlags ä¸­å¢åŠ è¿™ä¸¤ä¸ªå­—æ®µçš„ ENV è¦†ç›–æ”¯æŒ
// ä¿æŒä¸ç°æœ‰ ruleCacheMaxSizeã€symbolCacheMaxSize ç­‰å­—æ®µä¸€è‡´çš„å¯é…ç½®æ€§
```

#### APIå…¼å®¹æ€§ç­–ç•¥
```typescript
// ä¿æŒå‘åå…¼å®¹ï¼Œç°æœ‰æ–¹æ³•å†…éƒ¨å§”æ‰˜åˆ°æ–°ç»Ÿä¸€å…¥å£
// ğŸ¯ é‡è¦ï¼šæ‰€æœ‰è¿”å›ç»“æ„ç»Ÿä¸€ä½¿ç”¨ mappingDetails/failedSymbolsï¼Œç¡®ä¿ä¸L3ç²¾å‡†å¤±æ•ˆå®Œå…¨ä¸€è‡´
export class SymbolMapperService {
  // ç°æœ‰æ–¹æ³•ä¿æŒä¸å˜ï¼Œå†…éƒ¨è°ƒç”¨æ–°ç¼“å­˜æœåŠ¡
  async mapSymbol(originalSymbol: string, fromProvider: string, toProvider: string): Promise<string> {
    // æ³¨æ„ï¼šé€šè¿‡ toProvider === 'standard' åˆ¤æ–­æ–¹å‘
    // ä¸æ”¯æŒ providerAâ†’providerB ç›´è½¬ï¼ˆç»´æŒç°çŠ¶ï¼‰
    const direction = toProvider === 'standard' ? 'to_standard' : 'from_standard';
    const result = await this.cacheService.mapSymbols(
      fromProvider, 
      originalSymbol, 
      direction
    );
    // ä» mappingDetails ä¸­è·å–æ˜ å°„ç»“æœ
    const mapped = result.mappingDetails?.[originalSymbol] ?? originalSymbol;
    return mapped;
  }

  async mapSymbols(provider: string, symbols: string[], requestId?: string) {
    // å§”æ‰˜åˆ°æ–°ç¼“å­˜æœåŠ¡
    // æ³¨æ„ï¼šmapSymbols ç”¨äºå°†æ ‡å‡†ç¬¦å·è½¬ä¸º provider ç¬¦å·ï¼Œä½¿ç”¨ from_standard
    const result = await this.cacheService.mapSymbols(provider, symbols, 'from_standard', requestId);
    
    // é€‰é¡¹1: å¦‚æœç°æœ‰è°ƒç”¨æ–¹æœŸæœ›ç®€å•çš„å­—ç¬¦ä¸²æ•°ç»„ï¼ŒæŒ‰é¡ºåºè¿”å›
    // return symbols.map(symbol => result.mappingDetails?.[symbol] ?? symbol);
    
    // é€‰é¡¹2: ä¿æŒå®Œæ•´çš„æ‰¹é‡ç»“æ„ï¼Œä¾›è°ƒç”¨æ–¹è‡ªè¡Œå¤„ç† (æ¨è)
    return result;
  }

  async transformSymbolsForProvider(provider: string, symbols: string[], requestId: string) {
    // å†…éƒ¨ä½¿ç”¨æ–°ç¼“å­˜æœåŠ¡ï¼Œä¿æŒç°æœ‰ä¸šåŠ¡é€»è¾‘
    // æ³¨æ„ï¼štransformSymbolsForProvider ä¹Ÿæ˜¯ standardâ†’providerï¼Œä½¿ç”¨ from_standard
    const result = await this.cacheService.mapSymbols(provider, symbols, 'from_standard', requestId);
    
    // è¿”å›ç»Ÿä¸€çš„æ‰¹é‡ç»“æ„ï¼Œä¸ mappingDetails/failedSymbols å®Œå…¨ä¸€è‡´
    return result;
  }
}
```

### Phase 1: åŸºç¡€æ¶æ„æ­å»ºï¼ˆ1-2å¤©ï¼‰
- [ ] åœ¨ FeatureFlags ä¸­æ–°å¢ L3 é…ç½®å­—æ®µï¼š`batchResultCacheMaxSize`, `batchResultCacheTtl`
- [ ] ä¸ºæ–°å¢å­—æ®µå¢åŠ  ENV è¦†ç›–æ”¯æŒï¼Œä¿æŒä¸ç°æœ‰å­—æ®µä¸€è‡´çš„å¯é…ç½®æ€§
- [ ] åˆ›å»º `SymbolMapperCacheService` ç±»ï¼Œç¡®è®¤æ‰€æœ‰å¯¼å…¥è·¯å¾„æ­£ç¡®
- [ ] ä» FeatureFlags ç»Ÿä¸€è¯»å–ä¸‰å±‚ç¼“å­˜é…ç½®
- [ ] å®ç°ä¸‰å±‚ç¼“å­˜æ¶æ„
- [ ] æ·»åŠ å…¼å®¹å±‚ä¿æŒAPIä¸å˜
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–

### Phase 2: æ ¸å¿ƒåŠŸèƒ½å®ç°ï¼ˆ2-3å¤©ï¼‰
- [ ] å®ç°ç»Ÿä¸€æŸ¥è¯¢å…¥å£ `mapSymbols`
- [ ] å®ç°åŒå‘ç¼“å­˜æœºåˆ¶å’Œå›å¡«ç­–ç•¥
- [ ] å®ç°å¹¶å‘æ§åˆ¶ï¼ˆåŸºäºæ’åºç¬¦å·çš„ç¨³å®škeyï¼‰
- [ ] é›†æˆChange Streamç›‘å¬å’Œç¼“å­˜å¤±æ•ˆ
- [ ] é›†æˆæµ‹è¯•

### Phase 3: ç›‘æ§ä¸å…¼å®¹å±‚ï¼ˆ1-2å¤©ï¼‰
- [ ] å¤ç”¨ç°æœ‰ç›‘æ§æŒ‡æ ‡ä½“ç³»
- [ ] å®ç°APIå…¼å®¹å±‚ï¼ˆå§”æ‰˜æ¨¡å¼ï¼‰
- [ ] æ·»åŠ ç¼“å­˜ç»Ÿè®¡å’Œå¥åº·æ£€æŸ¥æ¥å£
- [ ] å›å½’æµ‹è¯•éªŒè¯å…¼å®¹æ€§

### Phase 4: é«˜çº§åŠŸèƒ½ï¼ˆ1-2å¤©ï¼‰
- [ ] å®ç°æ™ºèƒ½é¢„åŠ è½½ï¼ˆé¿é‡å¤ã€åŒå‘å†™å…¥ï¼‰
- [ ] æ·»åŠ æ‰¹é‡ç»“æœå›å¡«å•ç¬¦å·ç¼“å­˜
- [ ] å®Œå–„é…ç½®ç®¡ç†å’Œç¯å¢ƒå˜é‡æ”¯æŒ
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•

### Phase 5: ç°åº¦éƒ¨ç½²ï¼ˆ1å¤©ï¼‰
- [ ] åŠŸèƒ½å¼€å…³æ§åˆ¶ç°åº¦å‘å¸ƒ
- [ ] æ€§èƒ½ç›‘æ§å¯¹æ¯”ï¼ˆæ–°æ—§å®ç°ï¼‰
- [ ] ç¼“å­˜å‘½ä¸­ç‡è§‚å¯Ÿ
- [ ] å›æ»šé¢„æ¡ˆå’Œé™çº§å¼€å…³

## ğŸ“Š é¢„æœŸæ•ˆæœéªŒè¯

### å…³é”®æŒ‡æ ‡ç›‘æ§

1. **ç¼“å­˜å‘½ä¸­ç‡**
   - L1ï¼ˆè§„åˆ™ç¼“å­˜ï¼‰: ç›®æ ‡ > 95%
   - L2ï¼ˆç¬¦å·ç¼“å­˜ï¼‰: ç›®æ ‡ > 85%
   - L3ï¼ˆæ‰¹é‡ç¼“å­˜ï¼‰: ç›®æ ‡ > 60%
   - æ³¨ï¼šä¸è®¡ç®—æ•´ä½“å‘½ä¸­ç‡ï¼Œé¿å…è·¨å±‚çº§ç»Ÿè®¡å¯¼è‡´çš„æŒ‡æ ‡å¼‚å¸¸

2. **æ€§èƒ½æŒ‡æ ‡**
   - å•ç¬¦å·æŸ¥è¯¢å»¶è¿Ÿ: ç›®æ ‡ < 2ms
   - æ‰¹é‡æŸ¥è¯¢å»¶è¿Ÿ: ç›®æ ‡ < 30ms
   - Symbol Mapperå†…éƒ¨ç¼“å­˜æ•ˆç‡æå‡: ç›®æ ‡ > 80%

3. **èµ„æºæ¶ˆè€—**
   - æ•°æ®åº“æŸ¥è¯¢å‡å°‘: ç›®æ ‡ > 80%
   - å†…å­˜ä½¿ç”¨åˆç†: ç›®æ ‡ < 500MB
   - CPUä½¿ç”¨ä¼˜åŒ–: ç›®æ ‡ > 50%å‡å°‘

### éªŒè¯æ–¹æ¡ˆ

```typescript
/**
 * ğŸ§ª æ€§èƒ½å¯¹æ¯”æµ‹è¯•
 */
export class SymbolMapperPerformanceTest {
  
  async benchmarkOldVsNew(testSymbols: string[], provider: string): Promise<BenchmarkResult> {
    // æ—§ç‰ˆæœ¬æµ‹è¯•
    const oldStartTime = Date.now();
    await this.oldSymbolMapper.mapSymbols(provider, testSymbols);
    const oldTime = Date.now() - oldStartTime;
    
    // æ–°ç‰ˆæœ¬æµ‹è¯•
    const newStartTime = Date.now();
    await this.newSymbolMapper.mapSymbols(provider, testSymbols);
    const newTime = Date.now() - newStartTime;
    
    return {
      oldPerformance: oldTime,
      newPerformance: newTime,
      improvement: ((oldTime - newTime) / oldTime) * 100,
      cacheStats: this.newSymbolMapper.getCacheStats()
    };
  }
}
```

## ğŸš€ é•¿æœŸä¼˜åŒ–æ–¹å‘

### ç¼“å­˜ç­–ç•¥è¿›åŒ–
1. **è‡ªé€‚åº”TTL**: æ ¹æ®ç¬¦å·ä½¿ç”¨é¢‘ç‡åŠ¨æ€è°ƒæ•´ç¼“å­˜æ—¶é—´
2. **åˆ†çº§é¢„åŠ è½½**: æ ¹æ®å¸‚åœºå¼€ç›˜æ—¶é—´é¢„åŠ è½½ç›¸å…³ç¬¦å·
3. **æ™ºèƒ½å¤±æ•ˆ**: åŸºäºæ•°æ®æºå˜æ›´äº‹ä»¶ä¸»åŠ¨å¤±æ•ˆç¼“å­˜

### æ€§èƒ½ä¼˜åŒ–
1. **ç¼“å­˜å‹ç¼©**: å¯¹å¤§æ‰¹é‡ç»“æœè¿›è¡Œå‹ç¼©å­˜å‚¨
2. **å¼‚æ­¥é¢„çƒ­**: åå°å¼‚æ­¥é¢„åŠ è½½çƒ­é—¨ç¬¦å·
3. **åˆ†å¸ƒå¼ç¼“å­˜**: æ”¯æŒRedisé›†ç¾¤åˆ†å¸ƒå¼ç¼“å­˜

### ç›‘æ§å‘Šè­¦
1. **ç¼“å­˜å‘½ä¸­ç‡å‘Šè­¦**: å‘½ä¸­ç‡ä½äºé˜ˆå€¼æ—¶å‘Šè­¦
2. **æ€§èƒ½é€€åŒ–ç›‘æ§**: å“åº”æ—¶é—´å¼‚å¸¸å¢é•¿å‘Šè­¦
3. **ç¼“å­˜å®¹é‡ç›‘æ§**: ç¼“å­˜ä½¿ç”¨ç‡è¿‡é«˜å‘Šè­¦

## ğŸ“ æ€»ç»“

æœ¬é‡æ„æ–¹æ¡ˆé€šè¿‡å¼•å…¥ä¸‰å±‚ç¼“å­˜æ¶æ„ã€åŒå‘æ˜ å°„æœºåˆ¶å’Œé•¿æœŸç¼“å­˜ç­–ç•¥ï¼Œå°†å½»åº•è§£å†³å½“å‰Symbol Mapperç»„ä»¶çš„ç¼“å­˜æ¶æ„é—®é¢˜ã€‚

### é‡è¦æ¾„æ¸…
ç»è¿‡è¯¦ç»†çš„ä»£ç å®¡æŸ¥å’Œæµç¨‹éªŒè¯ï¼Œ**Queryâ†’Receiveræµå‘ä¸­ä¸å­˜åœ¨Symbol Mapperé‡å¤è°ƒç”¨é—®é¢˜**ã€‚SmartCacheOrchestratorçš„ç¼“å­˜ç¼–æ’æœºåˆ¶æœ‰æ•ˆé¿å…äº†é‡å¤è°ƒç”¨ã€‚æœ¬é‡æ„æ–¹æ¡ˆçš„ä¸»è¦ä»·å€¼åœ¨äºï¼š

1. **è§£å†³æ‰¹é‡æŸ¥è¯¢ç»•è¿‡ç¼“å­˜çš„é—®é¢˜** - è®©æ‰¹é‡æŸ¥è¯¢ä¹Ÿèƒ½äº«å—ç¼“å­˜åŠ é€Ÿ
2. **å®ç°åŒå‘æ˜ å°„ç¼“å­˜** - ä¸€æ¬¡æŸ¥è¯¢ï¼ŒåŒå‘å—ç›Š
3. **ç»Ÿä¸€å•æ¬¡å’Œæ‰¹é‡æŸ¥è¯¢è·¯å¾„** - æé«˜ç¼“å­˜å¤ç”¨ç‡
4. **é‡‡ç”¨é•¿æœŸç¼“å­˜ç­–ç•¥** - å……åˆ†åˆ©ç”¨Symbolæ˜ å°„çš„ç¨³å®šæ€§ç‰¹ç‚¹

### å®æ–½å…³é”®ç‚¹æ€»ç»“

æ ¹æ®ä»£ç å®¡æŸ¥å‘ç°çš„å…³é”®å®æ–½è¦ç‚¹å’Œæœ¬æ¬¡ä¿®æ­£ï¼š

1. **é…ç½®ç®¡ç†**: é€šè¿‡FeatureFlagsç»Ÿä¸€ç®¡ç†ï¼Œæ”¯æŒENVè¦†ç›–ï¼Œé¿å…ç¡¬ç¼–ç TTL
2. **å˜æ›´å¤±æ•ˆ**: åŸºäºMongoDB Change Streamçš„ç²¾å‡†å¤±æ•ˆï¼ŒæŒ‰dataSourceNameåŒ¹é…ä¸‰å±‚ç¼“å­˜é”®
3. **ç›‘æ§å¯¹é½**: å¤ç”¨ç°æœ‰`streamCacheHitRate`æŒ‡æ ‡ä½“ç³»ï¼Œé€šè¿‡`cache_type`æ ‡ç­¾åŒºåˆ†
4. **APIå…¼å®¹**: ä¿ç•™ç°æœ‰æ–¹æ³•ç­¾åï¼Œå†…éƒ¨å§”æ‰˜åˆ°æ–°ç¼“å­˜æœåŠ¡ï¼Œç¡®ä¿å¹³æ»‘è¿ç§»
5. **å¹¶å‘å®‰å…¨**: ç¼“å­˜é”®åŸºäºæ’åºç¬¦å·+provider+directionï¼Œç¡®ä¿å¹¶å‘ä¸€è‡´æ€§
6. **å›å¡«ç­–ç•¥**: æ‰¹é‡æŸ¥è¯¢ç»“æœåŒæ­¥å›å¡«å•ç¬¦å·ç¼“å­˜ï¼Œè§£é™¤æ•°æ®å­¤å²›

**æœ¬æ¬¡æ–‡æ¡£ä¿®æ­£è¦ç‚¹**ï¼š
- **ç¼“å­˜å±‚çº§ç»Ÿä¸€**: L1è§„åˆ™ç¼“å­˜ã€L2ç¬¦å·ç¼“å­˜ã€L3æ‰¹é‡ç¼“å­˜ï¼ˆå…¨æ–‡ä¸€è‡´ï¼‰
- **ç›‘æ§æŒ‡æ ‡ä¼˜åŒ–**: `recordCacheMetrics(level, isHit)` ä»…ä½¿ç”¨å®šä¹‰ä¸­çš„æ ‡ç­¾ï¼Œé¿å…æ ‡ç­¾ä¸åŒ¹é…é”™è¯¯
- **æ–¹å‘å‚æ•°å¼ºåˆ¶**: ç§»é™¤`mapSymbols`é»˜è®¤æ–¹å‘ï¼Œå¼ºåˆ¶è°ƒç”¨æ–¹æ˜¾å¼ä¼ å…¥ï¼Œé¿å…è¯¯ç”¨
- **é”®ç”Ÿæˆä¸€è‡´**: æ‰€æœ‰è§„åˆ™ç¼“å­˜æ“ä½œç»Ÿä¸€ä½¿ç”¨`getProviderRulesKey()`ç”Ÿæˆé”®
- **å›å¡«ç»†åˆ™æ˜ç¡®**: è¯¦ç»†è§„å®šå¤±è´¥é¡¹ä¸å›å¡«ï¼ŒæˆåŠŸé¡¹åŒå‘å†™å…¥çš„å…·ä½“å®ç°
- **è¿­ä»£å™¨å…¼å®¹**: æ ‡æ³¨LRU-Cacheç‰ˆæœ¬é€‰æ‹©ç­–ç•¥ï¼Œé¿å…æ··ç”¨ä¸¤ç§éå†æ–¹å¼
- **å¹¶å‘é”®è§„æ ¼**: ç¡®ä¿æ‰¹é‡ç¼“å­˜é”®ä¸å¹¶å‘æ§åˆ¶é”®ä½¿ç”¨ç›¸åŒè§„æ ¼ï¼ˆæ’åº+å°å†™+å“ˆå¸Œï¼‰

é¢„æœŸå°†å¸¦æ¥80%ä»¥ä¸Šçš„æ‰¹é‡æŸ¥è¯¢æ€§èƒ½æå‡ï¼ŒåŒæ—¶æ˜¾è‘—å‡å°‘æ•°æ®åº“æŸ¥è¯¢å‹åŠ›ã€‚é€šè¿‡æ™ºèƒ½é¢„åŠ è½½å’Œè‡ªé€‚åº”ä¼˜åŒ–ï¼Œç³»ç»Ÿå°†éšç€ä½¿ç”¨è€Œå˜å¾—æ›´åŠ é«˜æ•ˆã€‚

## âš ï¸ å®æ–½é£é™©æç¤º

### å…³é”®é£é™©ç‚¹å’Œè§„é¿ç­–ç•¥

1. **å¹¶å‘é”®ä¸ç¼“å­˜é”®ä¸€è‡´æ€§é£é™©**
   - **é£é™©**ï¼šå¹¶å‘å»é‡é”®ä¸æ‰¹é‡ç¼“å­˜é”®è§„æ ¼ä¸ä¸€è‡´ï¼Œå¯¼è‡´é‡å¤æ‰§è¡Œæˆ–é”™å¤±å‘½ä¸­
   - **è§„é¿**ï¼šç¡®ä¿ä¸¤å¤„ä½¿ç”¨å®Œå…¨ç›¸åŒçš„é”®ç”Ÿæˆé€»è¾‘ï¼ˆprovider å°å†™åŒ– + ç¬¦å·æ’åº + direction + MD5 å“ˆå¸Œï¼‰
   - **éªŒè¯**ï¼šé€šè¿‡å•å…ƒæµ‹è¯•éªŒè¯ç›¸åŒè¾“å…¥ç”Ÿæˆç›¸åŒé”®

2. **æ™ºèƒ½å¤±æ•ˆå¤æ‚æ€§é£é™©**
   - **é£é™©**ï¼šè§„åˆ™å·®å¼‚è®¡ç®—é”™è¯¯ï¼Œå¯¼è‡´åº”è¯¥å¤±æ•ˆçš„ç¼“å­˜æœªå¤±æ•ˆæˆ–è¯¯å¤±æ•ˆæ­£ç¡®ç¼“å­˜
   - **è§„é¿**ï¼šå®ç°ä¸¥æ ¼çš„è§„åˆ™æ¯”è¾ƒé€»è¾‘ï¼Œæä¾›é™çº§åˆ°å®Œå…¨å¤±æ•ˆçš„æœºåˆ¶
   - **ç›‘æ§**ï¼šè®°å½•æ™ºèƒ½å¤±æ•ˆç»Ÿè®¡ï¼Œå¼‚å¸¸æ—¶è‡ªåŠ¨é™çº§åˆ°å®Œå…¨å¤±æ•ˆæ¨¡å¼

3. **å†…å­˜å ç”¨é£é™©**
   - **é£é™©**ï¼šL2 ç¬¦å·ç¼“å­˜é»˜è®¤ 5 ä¸‡æ¡ç›®å¯èƒ½æ¶ˆè€—è¿‡å¤šå†…å­˜
   - **è§„é¿**ï¼šç°åº¦æœŸå¯†åˆ‡ç›‘æ§å†…å­˜ä½¿ç”¨ï¼Œé€šè¿‡ FeatureFlags/ENV åŠ¨æ€è°ƒæ•´
   - **é™çº§**ï¼šå‡†å¤‡å†…å­˜å‘Šè­¦å’Œè‡ªåŠ¨é™çº§æœºåˆ¶

4. **ç›‘æ§æŒ‡æ ‡å†²çªé£é™©**
   - **é£é™©**ï¼šæ–°å¢çš„ `symbol_mapping_l{1|2|3}` æ ‡ç­¾ä¸ç°æœ‰æŒ‡æ ‡äº§ç”Ÿå‘½åç©ºé—´å†²çª
   - **è§„é¿**ï¼šå®æ–½å‰éªŒè¯ Prometheus æŒ‡æ ‡æ³¨å†Œï¼Œç¡®ä¿æ ‡ç­¾æ ¼å¼å…¼å®¹
   - **å›æ»š**ï¼šä¿ç•™åŸæœ‰ç›‘æ§é€»è¾‘ä½œä¸ºé™çº§æ–¹æ¡ˆ

5. **Change Stream ä¾èµ–é£é™©**
   - **é£é™©**ï¼šMongoDB Change Stream ä¸å¯ç”¨æ—¶ï¼Œç¼“å­˜æ— æ³•åŠæ—¶å¤±æ•ˆ
   - **è§„é¿**ï¼šå®ç°è½®è¯¢æ¨¡å¼ä½œä¸ºé™çº§ç­–ç•¥ï¼Œå®šæœŸæ£€æŸ¥è§„åˆ™ç‰ˆæœ¬
   - **ç›‘æ§**ï¼šæ·»åŠ  Change Stream è¿æ¥çŠ¶æ€ç›‘æ§

### ç°åº¦å‘å¸ƒæ£€æŸ¥æ¸…å•

- [ ] **æ€§èƒ½åŸºå‡†**ï¼šè®°å½•é‡æ„å‰çš„ç¼“å­˜å‘½ä¸­ç‡å’Œå“åº”æ—¶é—´åŸºå‡†
- [ ] **å†…å­˜ç›‘æ§**ï¼šè®¾ç½®å†…å­˜ä½¿ç”¨é˜ˆå€¼å‘Šè­¦ï¼ˆå»ºè®® < 500MBï¼‰
- [ ] **å¹¶å‘æµ‹è¯•**ï¼šéªŒè¯é«˜å¹¶å‘åœºæ™¯ä¸‹é”®ç”Ÿæˆä¸€è‡´æ€§
- [ ] **å¤±æ•ˆæµ‹è¯•**ï¼šéªŒè¯è§„åˆ™å˜æ›´åä¸‰å±‚ç¼“å­˜æ­£ç¡®å¤±æ•ˆ
- [ ] **é™çº§å¼€å…³**ï¼šç¡®ä¿åŠŸèƒ½å¼€å…³å¯ä»¥å¿«é€Ÿå›æ»šåˆ°æ—§å®ç°
- [ ] **ç›‘æ§ä»ªè¡¨æ¿**ï¼šå‡†å¤‡ç¼“å­˜å‘½ä¸­ç‡ã€å“åº”æ—¶é—´ã€å†…å­˜ä½¿ç”¨çš„ç›‘æ§é¢æ¿