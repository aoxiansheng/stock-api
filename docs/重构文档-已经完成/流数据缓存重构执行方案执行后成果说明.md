# StreamCache - 高性能流数据缓存系统

## 快速开始

StreamCache 是专为实时股票流数据设计的双层缓存系统，提供毫秒级的数据访问性能。

### 安装和配置

1. **环境准备**
```bash
# 确保Redis运行
redis-server --port 6379

# 安装依赖
cd backend/
bun install
```

2. **环境变量配置**
```bash
# .env 文件
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_STREAM_CACHE_DB=1

# StreamCache配置
STREAM_CACHE_HOT_TTL_MS=5000
STREAM_CACHE_WARM_TTL_SECONDS=300
STREAM_CACHE_MAX_HOT_SIZE=1000
```

3. **启动服务**
```bash
bun run dev
```

## 基本使用

### 1. 依赖注入

```typescript
import { StreamCacheService } from '@core/05-caching/stream-cache/services/stream-cache.service';

@Injectable()
export class YourService {
  constructor(
    private readonly streamCache: StreamCacheService,
  ) {}
}
```

### 2. 数据操作

```typescript
// 设置数据 - 自动策略
await this.streamCache.setData('quote:AAPL.US', stockData, 'auto');

// 获取数据
const data = await this.streamCache.getData('quote:AAPL.US');

// 增量查询 - 获取最近5秒的数据
const recentData = await this.streamCache.getDataSince(
  'quote:AAPL.US', 
  Date.now() - 5000
);

// 批量操作
const batchResult = await this.streamCache.getBatchData([
  'quote:AAPL.US',
  'quote:TSLA.US'
]);
```

### 3. 监控统计

```typescript
// 获取缓存统计
const stats = this.streamCache.getCacheStats();
console.log(`Hot Cache命中率: ${stats.hotCacheHits / (stats.hotCacheHits + stats.hotCacheMisses) * 100}%`);
```

## 架构特性

### 🚀 双层缓存设计

| 缓存层 | 存储 | TTL | 延迟 | 用途 |
|--------|------|-----|------|------|
| **Hot Cache** | 内存LRU | 5秒 | ~1ms | 超高频访问 |
| **Warm Cache** | Redis | 300秒 | ~10ms | 中频访问 |

### 🎯 智能存储策略

```typescript
// 系统自动判断存储策略
await streamCache.setData(key, data, 'auto'); // 推荐

// 手动指定策略
await streamCache.setData(key, data, 'hot');  // 强制Hot Cache
await streamCache.setData(key, data, 'warm'); // 仅Warm Cache
```

### 📊 数据压缩

```typescript
// 原始数据格式
const rawData = {
  symbol: 'AAPL.US',
  price: 150.25,
  volume: 1000,
  timestamp: Date.now(),
  change: 2.5,
  changePercent: 1.69
};

// 自动压缩为
const compressed = {
  s: 'AAPL.US',    // symbol
  p: 150.25,       // price
  v: 1000,         // volume
  t: Date.now(),   // timestamp
  c: 2.5,          // change
  cp: 1.69         // changePercent
};
```

## 性能指标

### 基准测试结果

```bash
# 运行性能测试
bun test test/jest/integration/core/05-caching/stream-cache/

# 典型性能指标
✓ Hot Cache访问: ~1ms
✓ Warm Cache访问: ~10ms
✓ 1000次并发访问: <500ms
✓ 缓存命中率: >95%
✓ 数据压缩比: ~0.6
```

### 容量规划

```typescript
// 默认配置
const config = {
  maxHotCacheSize: 1000,      // Hot Cache最大条目数
  hotCacheTTL: 5000,          // 5秒TTL
  warmCacheTTL: 300,          // 5分钟TTL
  cleanupInterval: 30000,     // 30秒清理间隔
};

// 内存使用估算
// Hot Cache: ~1000 条目 × 平均1KB = 1MB
// Warm Cache: 取决于Redis配置
```

## 高级功能

### 1. 增量数据查询

```typescript
// 实时数据追踪场景
const lastTimestamp = getLastProcessedTimestamp();
const incrementalData = await streamCache.getDataSince(
  'realtime:AAPL.US',
  lastTimestamp
);

// 处理新数据
if (incrementalData) {
  await processNewData(incrementalData);
}
```

### 2. 批量操作优化

```typescript
// 获取投资组合的所有股票数据
const portfolio = ['AAPL.US', 'MSFT.US', 'GOOGL.US', 'AMZN.US'];
const portfolioKeys = portfolio.map(symbol => `quote:${symbol}`);

const portfolioData = await streamCache.getBatchData(portfolioKeys);

// 并行处理
const processedData = Object.entries(portfolioData).map(([key, data]) => {
  return data ? processStockData(data) : null;
});
```

### 3. 实时WebSocket集成

```typescript
// WebSocket数据接收处理
websocket.on('data', async (rawData) => {
  const symbol = extractSymbol(rawData);
  const cacheKey = `realtime:${symbol}`;
  
  // 智能缓存策略 - 热门股票用Hot Cache
  const priority = isHotStock(symbol) ? 'hot' : 'auto';
  await streamCache.setData(cacheKey, rawData, priority);
  
  // 广播给订阅客户端
  broadcastToClients(symbol, rawData);
});
```

## 故障排除

### 常见问题

1. **缓存命中率低**
```typescript
// 检查统计信息
const stats = streamCache.getCacheStats();
console.log('命中率统计:', {
  hotHitRate: stats.hotCacheHits / (stats.hotCacheHits + stats.hotCacheMisses),
  warmHitRate: stats.warmCacheHits / (stats.warmCacheHits + stats.warmCacheMisses),
});

// 可能原因：
// - TTL设置过短
// - 缓存容量不足
// - 数据访问模式不规律
```

2. **Redis连接问题**
```typescript
// 检查Redis连接
const redisClient = module.get('REDIS_CLIENT');
const pingResult = await redisClient.ping();
console.log('Redis状态:', pingResult); // 应该返回 'PONG'
```

3. **内存使用过高**
```typescript
// 调整Hot Cache大小
const config = {
  maxHotCacheSize: 500, // 减少容量
  cleanupInterval: 15000, // 增加清理频率
};
```

### 调试模式

```typescript
// 启用详细日志
process.env.LOG_LEVEL = 'debug';

// 监控缓存操作
streamCache.getCacheStats(); // 定期检查统计信息
```

## 测试

### 运行测试

```bash
# 单元测试
bun test test/jest/unit/core/05-caching/stream-cache/

# 集成测试 (需要Redis运行)
bun test test/jest/integration/core/05-caching/stream-cache/

# 特定测试
bun test test/jest/unit/core/05-caching/stream-cache/services/stream-cache.service.spec.ts
```

### 测试覆盖率

```bash
# 生成覆盖率报告
bun test --coverage test/jest/unit/core/05-caching/stream-cache/
```

## 生产部署

### 1. 性能优化配置

```typescript
// 生产环境配置
const productionConfig = {
  hotCacheTTL: 3000,           // 3秒 - 更激进的TTL
  warmCacheTTL: 600,           // 10分钟 - 更长的备份时间
  maxHotCacheSize: 2000,       // 更大的Hot Cache
  cleanupInterval: 60000,      // 1分钟清理间隔
  compressionThreshold: 512,   // 更低的压缩阈值
};
```

### 2. 监控集成

```typescript
// Prometheus指标集成
import { register } from 'prom-client';

const cacheHitRateGauge = new Gauge({
  name: 'stream_cache_hit_rate',
  help: 'Stream cache hit rate percentage',
  labelNames: ['cache_type'],
  registers: [register],
});

// 定期更新指标
setInterval(() => {
  const stats = streamCache.getCacheStats();
  const hotHitRate = stats.hotCacheHits / (stats.hotCacheHits + stats.hotCacheMisses);
  cacheHitRateGauge.set({ cache_type: 'hot' }, hotHitRate);
}, 30000);
```

### 3. 健康检查

```typescript
// 健康检查端点
@Get('/health/stream-cache')
async getStreamCacheHealth() {
  const stats = streamCache.getCacheStats();
  const redisClient = this.module.get('REDIS_CLIENT');
  
  try {
    await redisClient.ping();
    return {
      status: 'healthy',
      stats,
      redis: 'connected',
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    return {
      status: 'degraded',
      stats,
      redis: 'disconnected',
      error: error.message,
      timestamp: new Date().toISOString(),
    };
  }
}
```

## 最佳实践

### 1. 缓存键命名
```typescript
// 推荐的命名规范
const keys = {
  quote: `quote:${symbol}`,                    // 报价数据
  historical: `hist:${symbol}:${date}`,        // 历史数据
  realtime: `rt:${symbol}:${timestamp}`,       // 实时流数据
  batch: `batch:${batchId}`,                   // 批量数据
  portfolio: `portfolio:${userId}:${symbols}`, // 投资组合
};
```

### 2. 错误处理
```typescript
try {
  const data = await streamCache.getData(key);
  return data || await fallbackDataSource(key);
} catch (error) {
  logger.error('缓存访问失败', { key, error });
  return await fallbackDataSource(key); // 优雅降级
}
```

### 3. 批量操作优化
```typescript
// 优化大批量操作
const BATCH_SIZE = 50;
const batches = chunk(keys, BATCH_SIZE);

const results = await Promise.all(
  batches.map(batch => streamCache.getBatchData(batch))
);

return results.reduce((acc, batch) => ({ ...acc, ...batch }), {});
```

---

**StreamCache 为股票流数据处理提供了高性能、可扩展的缓存解决方案。**