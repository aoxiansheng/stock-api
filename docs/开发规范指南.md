## 目录导航

- [概述](#概述)
- [0. 快速开始](#0-快速开始)
  - [0.1 环境准备](#01-环境准备)
  - [0.2 开发工作流程](#02-开发工作流程)
  - [0.3 项目核心概念](#03-项目核心概念)
- [1. 项目架构规范](#1-项目架构规范)
  - [1.1 核心架构原则](#11-核心架构原则)
  - [1.2 目录结构规范](#12-目录结构规范)
- [2. 命名规范](#2-命名规范)
  - [2.1 文件命名](#21-文件命名)
  - [2.2 类命名](#22-类命名)
  - [2.3 方法和变量命名](#23-方法和变量命名)
  - [2.4 数据类型和能力命名规范 ⭐](#24-数据类型和能力命名规范-)
- [3. 控制器开发规范](#3-控制器开发规范)
  - [3.1 基础结构模板](#31-基础结构模板)
  - [3.2 控制器编写标准](#32-控制器编写标准)
  - [3.3 Swagger文档规范](#33-swagger文档规范)
  - [3.4 批量操作响应规范 ⭐](#34-批量操作响应规范-)
- [4. 服务层开发规范](#4-服务层开发规范)
  - [4.1 服务结构模板](#41-服务结构模板)
  - [4.2 服务编写标准](#42-服务编写标准)
- [5. DTO开发规范](#5-dto开发规范)
  - [5.1 DTO结构模板](#51-dto结构模板)
  - [5.2 DTO编写标准](#52-dto编写标准)
  - [5.3 DTO 复用 common 模块最佳实践](#53-dto-复用-common-模块最佳实践)
- [6. 数据库和仓储层规范](#6-数据库和仓储层规范)
  - [6.1 Schema定义规范](#61-schema定义规范)
  - [6.2 仓储层实现规范](#62-仓储层实现规范)
  - [6.3 数据库设计标准](#63-数据库设计标准)
  - [6.4 数据库复用 common 模块最佳实践](#64-数据库复用-common-模块最佳实践)
- [7. 错误处理和响应规范](#7-错误处理和响应规范)
  - [7.1 异常处理标准](#71-异常处理标准)
  - [7.2 自定义业务异常](#72-自定义业务异常)
  - [7.3 全局异常过滤器](#73-全局异常过滤器)
- [8. 认证和授权规范](#8-认证和授权规范)
  - [8.1 权限系统架构](#81-权限系统架构)
  - [8.2 认证装饰器使用](#82-认证装饰器使用)
  - [8.3 响应装饰器完整指南](#83-响应装饰器完整指南)
  - [8.4 响应装饰器详细使用](#84-响应装饰器详细使用)
  - [8.5 装饰器常见问题与调试](#85-装饰器常见问题与调试)
  - [8.6 权限控制](#86-权限控制)
  - [8.7 权限验证最佳实践](#87-权限验证最佳实践)
  - [8.8 请求上下文](#88-请求上下文)
- [9. 性能监控和日志规范](#9-性能监控和日志规范)
  - [9.1 日志记录标准](#91-日志记录标准)
  - [9.2 性能监控](#92-性能监控)
  - [9.3 健康检查](#93-健康检查)
- [10. Shared 模块复用指南 🎯](#10-common-模块复用指南-)
  - [10.1 Shared 模块概览](#101-common-模块概览)
  - [10.2 强制复用规范](#102-强制复用规范)
  - [10.3 组件级复用指南](#103-组件级复用指南)
  - [10.4 复用验证清单](#104-复用验证清单)
  - [10.5 反模式警告](#105-反模式警告)
- [11. 测试规范](#11-测试规范)
  - [11.1 单元测试](#111-单元测试)
  - [11.2 集成测试](#112-集成测试)
  - [11.3 测试中的 Shared 模块复用最佳实践](#113-测试中的-common-模块复用最佳实践)
- [13. API版本控制](#13-api版本控制)
  - [13.1 版本策略](#131-版本策略)
  - [13.2 版本实现](#132-版本实现)
- [14. 安全规范](#14-安全规范)
  - [14.1 输入验证](#141-输入验证)
  - [14.2 敏感信息处理](#142-敏感信息处理)
  - [14.3 安全审计](#143-安全审计)
  - [14.4 HTTP Headers 工具类](#144-http-headers-工具类)
- [15. CI/CD和部署规范](#15-cicd和部署规范)
  - [15.1 代码质量检查](#151-代码质量检查)
  - [15.2 构建和部署](#152-构建和部署)
- [16. 开发工具和配置](#16-开发工具和配置)
  - [16.1 IDE配置](#161-ide配置)
  - [16.2 环境变量管理](#162-环境变量管理)
- [17. 最佳实践总结](#17-最佳实践总结)
  - [17.1 代码质量](#171-代码质量)
  - [17.2 团队协作](#172-团队协作)
  - [17.3 系统监控](#173-系统监控)
- [结语](#结语)
  - [📚 相关文档](#-相关文档)
  - [🎯 规范更新记录](#-规范更新记录)

# NestJS + Bun 项目开发规范指南

> 基于 Context7 NestJS 最佳实践和当前项目架构制定的企业级开发标准

## 概述

本文档基于对 NestJS 官方最佳实践的深入研究和当前项目架构的全面分析，制定了一套统一的开发规范，确保代码质量、团队协作效率和系统的长期可维护性。

**📚 文档关系说明**：
- 本文档是 [CLAUDE.md](../CLAUDE.md) 的补充，专注于具体的编码规范和开发标准
- CLAUDE.md 提供系统概览和快速上手指南，本文档提供详细的开发实践规范
- 建议先阅读 CLAUDE.md 了解系统架构，再参考本文档进行具体开发

**🎯 合规整改状态**：
- ✅ 系统已完成95%+企业级合规整改
- ✅ 统一响应格式和认证装饰器标准化
- ✅ 代码质量和安全规范全面实施
- ✅ 开发服务器验证通过，所有核心功能正常运行

**📝 最新更新 (v2.1.0)**：
- ✅ **装饰器体系优化**: 简化响应装饰器使用，移除冗余的 `@ApiKeyAuthResponses()`
- ✅ **增强JWT响应**: `@JwtAuthResponses()` 现包含完整错误响应覆盖
- ✅ **统一标准响应**: API Key认证和公开端点统一使用 `@ApiStandardResponses()`
- ✅ **完善使用指南**: 新增装饰器快速参考表和常见问题解决方案
- ✅ **调试支持**: 提供装饰器使用的调试技巧和最佳实践

## 0. 快速开始

### 0.1 环境准备

在开始开发前，请确保已完成基础环境搭建（详见 [CLAUDE.md 快速开始部分](../CLAUDE.md#quick-start)）：

```bash
# 1. 安装依赖
bun install

# 2. 环境变量配置
export LONGPORT_APP_KEY=your_app_key
export LONGPORT_APP_SECRET=your_app_secret  
export LONGPORT_ACCESS_TOKEN=your_access_token

# 3. 启动开发服务器
bun run dev

# 4. 验证系统运行
curl http://localhost:3000/docs  # Swagger文档
```

### 0.2 开发工作流程

**标准开发流程**：
1. **创建功能分支** → `git checkout -b feature/功能名称`
2. **编写代码** → 遵循本文档规范
3. **代码质量检查** → `bun run lint && bun run format`
4. **本地测试** → `bun test` (注意：部分测试配置可能需要更新)
5. **提交代码** → 规范的commit消息
6. **创建PR** → 代码审查后合并

**常用开发命令**：
```bash
# 代码质量检查 (注意：ESLint配置可能需要@typescript-eslint/recommended包)
bun run lint          # ESLint检查和自动修复
bun run format        # Prettier格式化
bun run format:check  # 检查代码格式

# 测试 (合规整改后，部分测试配置可能需要更新)
bun test              # 单元测试
bun test --watch      # 监控模式测试
bun test --coverage   # 覆盖率测试

# 开发和调试
bun run dev           # 开发服务器 (支持热重载)
bun run start:debug   # 调试模式
```

### 0.3 项目核心概念

在深入开发前，请理解以下核心概念（详细架构见 [CLAUDE.md](../CLAUDE.md#architecture-overview)）：

- **6组件架构**：Receiver → Symbol Mapper → Data Mapper → Transformer → Storage → Query
- **三层认证**：JWT认证（用户）+ API Key认证（第三方）+ 公开访问
- **统一响应格式**：全局拦截器自动处理，不要手动包装响应
- **能力导向设计**：数据源按能力组织，自动发现和注册

## 1. 项目架构规范

### 1.1 核心架构原则

- **6组件核心架构**：`receiver`、`symbol-mapper`、`data-mapper`、`transformer`、`storage`、`query`
- **模块化设计**：每个模块具有独立的责任边界和清晰的接口定义
- **服务导向架构**：业务逻辑封装在服务层，控制器仅负责请求处理
- **策略模式**：认证、数据转换等采用策略模式支持多种实现
- **仓储模式**：数据访问层统一抽象，支持不同数据源

### 1.2 目录结构规范

```
src/
├── core/                           # 核心业务模块
│   ├── [module-name]/              # 模块目录
│   │   ├── [module].controller.ts  # 控制器
│   │   ├── [module].service.ts     # 业务服务
│   │   ├── [module].module.ts      # 模块定义
│   │   ├── dto/                    # 数据传输对象
│   │   │   ├── index.ts            # 导出索引
│   │   │   ├── create-[entity].dto.ts
│   │   │   ├── update-[entity].dto.ts
│   │   │   ├── [entity]-query.dto.ts
│   │   │   └── [entity]-response.dto.ts
│   │   ├── schemas/                # 数据库模式
│   │   │   └── [entity].schema.ts
│   │   └── repositories/           # 仓储层
│   │       └── [entity].repository.ts
├── auth/                           # 认证授权模块
├── common/                         # 共享组件
│   ├── dto/                        # 通用DTO
│   ├── decorators/                 # 自定义装饰器
│   ├── interceptors/               # 拦截器
│   ├── filters/                    # 
│   ├── interfaces/                 # 接口定义
│   ├── config/                      # 
│   └── constants/                  # 常量定义
│   └── utils   /                   # 
├── providers/                      # 外部服务提供商
├── monitoring/                     # 监控模块
├── security/                       # 安全模块
└── config/                         # 配置文件
```

## 2. 命名规范

### 2.1 文件命名

- **模块文件**：`kebab-case`
  - 控制器：`module-name.controller.ts`
  - 服务：`module-name.service.ts`
  - DTO：`entity-name.dto.ts`
  - 接口：`entity-name.interface.ts`

### 2.2 类命名

- **类名**：`PascalCase`
  - 控制器：`EntityNameController`
  - 服务：`EntityNameService`
  - DTO：`CreateEntityNameDto`、`UpdateEntityNameDto`、`EntityNameResponseDto`
  - 接口：`IEntityName`

### 2.3 方法和变量命名

- **方法/变量**：`camelCase`
- **常量**：`SCREAMING_SNAKE_CASE`
- **枚举**：`PascalCase` 枚举名，`SCREAMING_SNAKE_CASE` 枚举值

### 2.4 数据类型和能力命名规范 ⭐

> **重要**：本节定义了系统核心的数据类型和能力命名规范，是添加新功能时必须遵循的标准。

#### 2.4.1 分层命名架构

系统采用三层命名架构，确保用户接口简洁、内部逻辑清晰：

```typescript
// 🎯 字段语义四层架构示例（消除通用dataType混淆）
{
  // Receiver层 - 能力路由
  receiverType: "get-stock-quote",     // 用于提供商能力路由和匹配

  // Data Mapper/Transformer层 - 映射规则类型
  transDataRuleListType: "quote_fields",     // 用于字段映射规则分类和查找

  // Storage层 - 数据分类
  storageClassification: "stock_quote",    // 用于数据存储分类和检索

  // Query层 - 数据过滤
  queryTypeFilter: "get-stock-quote",    // 用于查询时的数据类型过滤
  
  // 存储键 (组合多个语义层)
  storageKey: "get-stock-quote:longport:AAPL:US"
}
```

#### 2.4.2 命名格式约定

**重要**: 系统使用统一的命名格式约定：

- **能力路由层** (`receiverType`): 使用 `kebab-case` (连字符分隔) - "get-stock-quote"
- **映射规则层** (`transDataRuleListType`): 使用 `snake_case` (下划线分隔) - "quote_fields"  
- **存储分类层** (`storageClassification`): 使用 `snake_case` (下划线分隔) - "stock_quote"
- **查询过滤层** (`queryTypeFilter`): 灵活格式，通常沿用能力名称格式

#### 2.4.3 命名规范对照表

| 数据类型 | Receiver层<br>`receiverType` | Data Mapper层<br>`transDataRuleListType` | Storage层<br>`storageClassification` | Query层<br>`queryTypeFilter` | 文件名 |
|---------|--------------------------------|------------------------------------|------------------------------------|------------------------------|---------|
| 股票报价 | `get-stock-quote` | `quote_fields` | `stock_quote` | `get-stock-quote` | `get-stock-quote.ts` |
| 指数报价 | `get-index-quote` | `index_fields` | `index_quote` | `get-index-quote` | `get-index-quote.ts` |
| 股票信息 | `get-stock-basic-info` | `basic_info_fields` | `company_profile` | `get-stock-basic-info` | `get-stock-basic-info.ts` |
| 市场状态 | `get-market-status` | `market_status_fields` | `market_status` | `get-market-status` | `get-market-status.ts` |

#### 2.4.4 能力文件命名规范

**文件命名模式**：`get-{data-type}.ts`

```typescript
// ✅ 正确的能力文件命名
src/providers/longport/capabilities/
├── get-stock-quote.ts           // 股票报价能力
├── get-stock-basic-info.ts      // 股票基本信息能力
├── get-index-quote.ts           // 指数报价能力
├── get-market-status.ts         // 市场状态能力
└── get-trading-days.ts          // 交易日能力

// ❌ 错误的命名方式
├── stock-quote.ts               // 缺少动作前缀
├── stockQuote.ts                // 使用camelCase
├── get_stock_quote.ts           // 使用snake_case
└── getStockQuote.ts             // 使用camelCase
```

#### 2.4.5 能力定义规范

**能力对象命名**：使用 `camelCase` 导出变量名，`name` 字段使用 `kebab-case`

```typescript
// ✅ 标准的能力定义模板
import { ICapability } from "@common/interfaces";
import { MARKETS } from "@common/constants";

/**
 * {Provider} {DataType} 获取能力
 * 注意：此函数需要与 {Provider}ContextService 配合使用
 */
export const getStockQuote: ICapability = {
  name: "get-stock-quote",                    // ✅ 使用kebab-case
  description: "获取股票实时报价数据",
  supportedMarkets: [MARKETS.HK, MARKETS.US, MARKETS.SZ, MARKETS.SH],
  supportedSymbolFormats: ["700.HK", "AAPL.US", "000001.SZ", "600000.SH"],
  rateLimit: {
    requestsPerSecond: 10,
    requestsPerDay: 10000,
  },

  async execute(params: {
    symbols: string[];
    contextService?: any;
  }): Promise<any> {
    try {
      console.log("调用 {Provider} SDK 获取{数据类型}:", params.symbols);

      // 实现具体的API调用逻辑
      // ...

      return result;
    } catch (error) {
      throw new Error(`{Provider} 获取{数据类型}失败: ${error.message}`);
    }
  },
};

export default getStockQuote;  // ✅ 默认导出
```

#### 2.4.6 字段语义映射规范

**四层字段映射配置**：

```typescript
// ✅ 字段语义四层架构映射
import { FIELD_MAPPING_CONFIG } from '@common/types/field-naming.types';

// Receiver层处理能力路由
private processCapability(receiverType: string): string {
  // receiverType 用于能力路由和匹配
  // 如: "get-stock-quote", "get-stock-basic-info", "get-index-quote"
  return receiverType;
}

// Data Mapper/Transformer层处理映射规则查找
private findMappingRule(provider: string, transDataRuleListType: string) {
  // transDataRuleListType 用于查找字段映射规则
  // 如: "quote_fields", "basic_info_fields", "index_fields"
  return this.dataMapperService.findBestMatchingRule(provider, transDataRuleListType);
}

// Storage层处理数据分类
private storeData(data: any, storageClassification: string) {
  // storageClassification 用于数据存储分类
  // 如: "stock_quote", "company_profile", "index_quote"
  return this.storageService.store(data, { classification: storageClassification });
}

// Query层处理数据过滤
private queryData(symbols: string[], queryTypeFilter?: string) {
  // queryTypeFilter 用于查询时的数据类型过滤（Query层语义）
  // 可以使用任意上述类型的字符串值
  return this.queryService.execute({ symbols, queryTypeFilter });
}

// 支持的能力类型常量
export const SUPPORTED_CAPABILITY_TYPES = [
  "get-stock-quote",
  "get-stock-basic-info", 
  "get-index-quote",
  "get-market-status",
  "get-trading-days",
  // 添加新能力类型时在此处扩展
] as const;

// 映射规则类型常量
export const DATA_RULE_LIST_TYPES = [
  "quote_fields",
  "basic_info_fields",
  "index_fields", 
  "market_status_fields",
  // 添加新映射规则类型时在此处扩展
] as const;
```

#### 2.4.7 存储分类规范

**StorageClassification 枚举定义**：

```typescript
// ✅ 存储分类使用snake_case格式
export enum StorageClassification {
  STOCK_QUOTE = "stock_quote",
  STOCK_CANDLE = "stock_candle",
  STOCK_TICK = "stock_tick",
  FINANCIAL_STATEMENT = "financial_statement",
  COMPANY_PROFILE = "company_profile",
  MARKET_NEWS = "market_news",
  TRADING_ORDER = "trading_order",
  USER_PORTFOLIO = "user_portfolio",
  GENERAL = "general",
}
```

#### 2.4.8 预设字段配置规范

**数据映射规则类型**：

```typescript
// ✅ 预设字段配置命名 (使用snake_case)
{
  provider: "preset",
  transDataRuleListType: "quote_fields",             // 字段映射规则类型
  // 其他示例：
  // transDataRuleListType: "basic_info_fields",     // 基本信息字段
  // transDataRuleListType: "index_fields",          // 指数字段
  // transDataRuleListType: "market_status_fields",  // 市场状态字段
}
```

#### 2.4.9 添加新数据类型的标准流程

当需要添加新的数据类型时，请按以下**四层架构**操作：

1. **定义Receiver层能力类型**
   ```typescript
   // 例如：get-crypto-quote（加密货币报价能力）
   // 文件：src/providers/{provider}/capabilities/get-crypto-quote.ts
   export const getCryptoQuote: ICapability = {
     name: "get-crypto-quote",  // receiverType 值
     // ...
   };
   ```

2. **定义Data Mapper层映射规则类型**
   ```typescript
   // 文件：src/core/data-mapper/constants/data-mapper.constants.ts
   export const SUPPORTED_DATA_RULE_LIST_TYPES = [
     // 现有类型...
     "crypto_quote_fields",  // transDataRuleListType值 (snake_case)
   ] as const;
   ```

3. **定义Storage层数据分类**
   ```typescript
   // 文件：src/common/types/field-naming.types.ts
   export enum StorageClassification {
     // 现有分类...
     CRYPTO_QUOTE = "crypto_quote",  // storageClassification 值 (snake_case)
   }
   ```

4. **更新字段映射配置**
   ```typescript
   // 文件：src/common/types/field-naming.types.ts
   export const FIELD_MAPPING_CONFIG = {
     CAPABILITY_TO_CLASSIFICATION: {
       // 现有映射...
       "get-crypto-quote": StorageClassification.CRYPTO_QUOTE,
     },
     RULE_TYPE_TO_CLASSIFICATION: {
       // 现有映射...
       "crypto_quote_fields": StorageClassification.CRYPTO_QUOTE,
     }
   } as const;
   ```

5. **创建预设字段映射规则**（如需要）
   ```typescript
   // 文件：src/scripts/auto-init-on-startup.service.ts
   // 添加新的字段映射规则初始化逻辑
   private async initCryptoQuotePresetFields() {
     // 自动创建crypto_quote_fields类型的映射规则
   }
   ```

6. **更新能力类型常量**
   ```typescript  
   // 文件：src/core/receiver/constants/receiver.constants.ts
   export const SUPPORTED_CAPABILITY_TYPES = [
     // 现有类型...
     "get-crypto-quote",
   ] as const;
   ```

#### 2.4.10 字段语义四层架构验证清单

在添加新数据类型时，请使用以下清单验证四层架构规范：

**Receiver层 (能力路由)**：
- [ ] **文件名**：使用 `get-{data-type}.ts` 格式
- [ ] **能力名称**：`name` 字段使用 `get-{data-type}` 格式 (kebab-case)
- [ ] **导出变量**：使用 `camelCase`，如 `getCryptoQuote`
- [ ] **DTO字段**：`receiverType` 使用 `get-{data-type}` 格式

**Data Mapper/Transformer层 (映射规则)**：
- [ ] **映射规则类型**：`transDataRuleListType` 使用 `{type}_fields` 格式 (snake_case)
- [ ] **常量定义**：在 `SUPPORTED_DATA_RULE_LIST_TYPES` 中添加
- [ ] **Schema字段**：数据库中使用相同的 `transDataRuleListType` 值

**Storage层 (数据分类)**：
- [ ] **分类枚举**：在 `StorageClassification` 中使用 `{TYPE}` 格式 (UPPER_SNAKE_CASE)
- [ ] **分类值**：枚举值使用 `{type}` 格式 (snake_case)
- [ ] **DTO字段**：`storageClassification` 使用分类枚举值

**Query层 (数据过滤)**：
- [ ] **过滤字段**：`queryTypeFilter` 可灵活使用上述任意格式
- [ ] **通常使用**：沿用Receiver层的能力名称格式

**映射配置**：
- [ ] **映射关系**：在 `FIELD_MAPPING_CONFIG` 中添加四层映射
- [ ] **类型安全**：确保 TypeScript 类型定义正确
- [ ] **文档更新**：更新相关API文档和开发指南

#### 2.4.11 常见错误和避免方法

**❌ 常见错误**：

1. **混淆不同组件的字段语义**
   ```typescript
   // 错误：在Storage组件中使用能力名称
   storageClassification: "get-stock-quote" // 应该是 "stock_quote"
   
   // 错误：在Data Mapper中使用能力名称
   transDataRuleListType: "get-stock-quote" // 应该是 "quote_fields"
   ```

2. **使用过时的通用dataType字段**
   ```typescript
   // 错误：仍然使用通用的dataType字段
   interface RequestDto {
     dataType: string; // 已废弃，应明确使用四层架构中的具体字段
   }
   ```

3. **命名格式不一致**
   ```typescript
   // 错误：在snake_case场景使用kebab-case
   transDataRuleListType: "quote-fields" // 应该是 "quote_fields"
   
   // 错误：在kebab-case场景使用snake_case  
   receiverType: "get_stock_quote" // 应该是 "get-stock-quote"
   ```

**✅ 正确做法**：

1. **明确字段语义**
   ```typescript
   // Receiver层 - 能力路由
   interface DataRequestDto {
     receiverType: string; // "get-stock-quote"
   }
   
   // Data Mapper层 - 映射规则
   interface DataMappingRule {
     transDataRuleListType: string; // "quote_fields"  
   }
   
   // Storage层 - 数据分类
   interface StorageDocument {
     storageClassification: string; // "stock_quote"
   }
   
   // Query层 - 数据过滤
   interface QueryRequestDto {
     queryTypeFilter?: string; // 可灵活使用任意格式
   }
   ```

2. **使用统一的映射配置**
   ```typescript
   // 通过FIELD_MAPPING_CONFIG确保四层语义一致性  
   import { FIELD_MAPPING_CONFIG } from '@common/types/field-naming.types';
   
   const storageClassification = FIELD_MAPPING_CONFIG.CAPABILITY_TO_CLASSIFICATION[receiverType];
   ```

2. **保持四层架构一致性**
   ```typescript
   // 文件名、能力名称、字段语义保持对应关系
   // 文件：get-stock-quote.ts
   // 能力：name: "get-stock-quote"
   // Receiver API：receiverType: "get-stock-quote"
   // Data Mapper：transDataRuleListType: "quote_fields"
   // Storage：storageClassification : "stock_quote"
   // Query：queryTypeFilter: "get-stock-quote" (通常沿用能力名称)
   ```

3. **完整更新**
   ```typescript
   // 添加新类型时同时更新所有相关文件
   ```

#### 2.4.12 自动发现机制

系统的能力自动发现机制基于文件名工作：

```typescript
// CapabilityRegistryService 自动发现逻辑
private async loadCapability(providerName: string, capabilityName: string) {
  // 1. 根据能力名称加载对应文件
  const capabilityModule = await import(`./${providerName}/capabilities/${capabilityName}`);

  // 2. 获取能力对象（文件名必须与能力名称匹配）
  const capability: ICapability = capabilityModule.default || capabilityModule[capabilityName];

  // 3. 注册能力
  this.capabilities.get(providerName)!.set(capability.name, registration);
}
```

**关键要求**：
- 文件名必须与能力名称完全匹配
- 能力对象的 `name` 字段必须与文件名一致
- 支持默认导出或命名导出

这套命名规范确保了：
- **用户友好**：API接口简洁易用
- **语义清晰**：内部逻辑表达明确的动作意图
- **自动发现**：文件名与能力名称匹配，支持零配置
- **可扩展性**：新增数据类型遵循统一模式
- **一致性**：整个系统使用统一的命名标准

## 3. 控制器开发规范

### 3.1 基础结构模板

```typescript
import { Controller, Post, Get, Body, Param, Query, Logger, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { Auth, ApiKeyAuth, Public } from '../auth/decorators/auth.decorator';
import { RequirePermissions } from '../auth/decorators/permissions.decorator';
import { ValidationPipe } from '@nestjs/common';
// 🎯 复用 common 模块的通用装饰器
import {
  ApiSuccessResponse,
  ApiCreatedResponse,
  ApiPaginatedResponse,
  ApiStandardResponses,
  JwtAuthResponses,
  ApiHealthResponse,
  PermissionResponses
} from '@common/decorators/swagger-responses.decorator';
// 🎯 复用 common 模块的通用响应 DTO
import { ApiResponseDto, ErrorResponseDto, PaginatedResponseDto } from '@common/dto/common-response.dto';
// 🎯 复用 common 模块的通用类型
import { RequestId, Timestamp } from '@common/types/common.types';
// 🎯 复用 common 模块的通用常量
import { DataType } from '@common/constants/data-type.constants';
import { MARKETS } from '@common/constants/markets.constants';
import { PROVIDERS } from '@common/constants/providers.constants';

@ApiTags('模块名称')
@Controller('api/v1/endpoint')
export class ExampleController {
  // 🎯 复用 common 模块的日志配置
  private readonly logger = new Logger(ExampleController.name);

  constructor(private readonly exampleService: ExampleService) {}

  @ApiKeyAuth() // 或 @Auth() 用于JWT认证
  @Post()
  @ApiOperation({
    summary: '操作描述',
    description: '详细的操作说明，包括业务逻辑和使用场景'
  })
  @ApiCreatedResponse({
    description: '创建成功',
    type: ApiResponseDto, // 🎯 使用通用响应DTO类型
    schema: {
      example: {
        statusCode: 201,
        message: '操作成功',
        data: { /* 具体响应数据示例 */ },
        timestamp: '2024-01-01T12:00:00.000Z'
      }
    }
  })
  @ApiStandardResponses() // 🎯 使用通用错误响应装饰器
  async createExample(
    @Body(ValidationPipe) createDto: CreateExampleDto
  ): Promise<ExampleResponseDto> { // 🎯 明确返回类型
    this.logger.log(`API 请求: ${createDto.name}`, {
      operation: 'createExample',
      data: createDto
    });

    try {
      // 🎯 合规标准：直接返回业务数据，让 ResponseInterceptor 自动处理格式化
      return await this.exampleService.create(createDto);
    } catch (error) {
      this.logger.error(`操作失败: ${error.message}`, {
        operation: 'createExample',
        error: error.stack,
        input: createDto
      });
      throw error; // 🎯 让全局异常过滤器处理错误格式化
    }
  }
}
```

### 3.2 控制器编写标准

#### 必须遵守的规则

1. **响应格式统一**：所有API返回统一的响应格式（由全局`ResponseInterceptor`自动处理）
```typescript
{
  statusCode: number;    // HTTP状态码
  message: string;       // 中文成功/错误消息
  data: T | null;        // 实际响应数据
  timestamp: string;     // ISO时间戳
  requestId?: string;    // 可选的请求跟踪ID
}
```

2. **🚨 重要：响应格式合规**
   - **禁止手动包装响应** - 让`ResponseInterceptor`拦截器自动处理
   - **直接返回数据** - 控制器方法直接返回业务数据或DTO
   - **使用中文消息** - 错误和成功消息必须使用中文
   
   ```typescript
   // ✅ 正确做法
   async create(@Body() dto: CreateDto) {
     return await this.service.create(dto); // 拦截器自动包装
   }
   
   // ❌ 错误做法
   async create(@Body() dto: CreateDto) {
     const data = await this.service.create(dto);
     return { statusCode: 201, message: '创建成功', data }; // 不要手动包装
   }
   ```

3. **认证装饰器标准化**：使用统一的认证装饰器
4. **Swagger文档完整**：每个端点必须有详细的API文档
5. **结构化日志记录**：记录关键操作的上下文信息

#### 认证装饰器使用规范

```typescript
// JWT认证（用户个人账户管理）
@Auth([UserRole.ADMIN])           // 管理员权限
@Auth()                           // 登录用户权限
@Auth([UserRole.DEVELOPER])       // 开发者权限

// API Key认证（第三方应用和系统管理）
@ApiKeyAuth([Permission.DATA_READ])     // 第三方API访问
@ApiKeyAuth([Permission.SYSTEM_ADMIN])  // 系统管理功能

// 公开访问
@Public()                         // 无需认证
```

### 3.3 Swagger文档规范

```typescript
@ApiOperation({ 
  summary: '简洁的操作描述（中文）',
  description: '详细说明操作的业务逻辑、参数要求、返回内容等'
})

// 使用标准响应装饰器
@ApiSuccessResponse({
  description: '操作成功',
  type: ResponseDto,  // 指定响应DTO类型
  schema: {
    example: {
      statusCode: 200,
      message: '操作成功',
      data: { /* 真实的响应数据示例 */ },
      timestamp: '2024-01-01T12:00:00.000Z'
    }
  }
})

@ApiStandardResponses()  // 包含400、401、403、404、429、500等标准错误响应
```

### 3.4 批量操作响应规范 ⭐

为确保对批量操作的处理结果有清晰、可操作的反馈，所有批量处理接口应遵循以下响应格式。

#### 3.4.1 响应数据体 (Data Body) 格式

批量操作的返回数据体应包含 `succeeded` 和 `failed` 两个字段，均为数组，分别记录操作成功和失败的ID列表。

```typescript
// ✅ 标准的批量操作响应格式
{
  "succeeded": ["id-1", "id-2", "id-5"],
  "failed": ["id-3", "id-4"]
}
```

**字段说明**:
- `succeeded` (`string[]`): 操作成功的ID列表。
- `failed` (`string[]`): 操作失败的ID列表。

#### 3.4.2 优点

- **明确性**: `succeeded` 和 `failed` 语义清晰，直接表达了每个ID的操作结果。
- **可操作性**: 调用方（前端或其他服务）可以精确地知道哪些ID操作失败，从而轻松实现重试或错误定位逻辑。
- **可扩展性**: 如果未来需要提供更详细的错误信息，`failed` 字段可以平滑地扩展为一个对象数组，例如：
  ```typescript
  {
    "succeeded": ["id-1", "id-2"],
    "failed": [
      { "id": "id-3", "reason": "Not found" },
      { "id": "id-4", "reason": "Permission denied" }
    ]
  }
  ```

#### 3.4.3 实现示例

```typescript
// src/alert/alert.controller.ts

@Post("batch/acknowledge")
@Auth([UserRole.ADMIN])
@ApiOperation({ summary: "批量确认告警" })
@ApiSuccessResponse({
  description: "批量确认告警完成",
  schema: {
    example: {
      succeeded: ["alert-id-1", "alert-id-2"],
      failed: ["alert-id-3"]
    }
  }
})
@JwtAuthResponses()
async batchAcknowledgeAlerts(
  @Body() body: { alertIds: string[]; acknowledgedBy: string }
): Promise<{ succeeded: string[]; failed: string[] }> {
  const succeeded: string[] = [];
  const failed: string[] = [];

  // ... 批量处理逻辑 ...
  // 根据结果填充 succeeded 和 failed 数组

  return { succeeded, failed };
}
```

## 4. 服务层开发规范

### 4.1 服务结构模板

```typescript
import { Injectable, Logger, NotFoundException, ConflictException } from '@nestjs/common';
import { ExampleRepository } from './repositories/example.repository';
import { CreateExampleDto, UpdateExampleDto, ExampleResponseDto } from './dto';
import { Example } from './schemas/example.schema';
// 🎯 复用 common 模块的通用接口
import { IDataMapper } from '@common/interfaces/data-mapping.interface';
import { ICapability } from '@common/interfaces/capability.interface';
// 🎯 复用 common 模块的通用类型
import { Market, ProviderName, RequestId } from '@common/types/common.types';
// 🎯 复用 common 模块的通用常量
import { DataType } from '@common/constants/data-type.constants';
import { MARKETS } from '@common/constants/markets.constants';
// 🎯 复用 common 模块的通用工具
import { HttpHeadersUtil } from '@common/utils/http-headers.util';
// 🎯 复用 common 模块的日志配置
import { createLogger, sanitizeLogData } from '@common/config/logger.config';
// 🎯 复用 common 模块的分页服务
import { PaginationService } from '@common/modules/pagination/services/pagination.service';
import { PaginatedDataDto } from '@common/modules/pagination/dto/paginated-data';

@Injectable()
export class ExampleService {
  // 🎯 使用 common 模块的日志配置
  private readonly logger = createLogger(ExampleService.name);

  constructor(
    private readonly exampleRepository: ExampleRepository,
    private readonly relatedService: RelatedService,
    private readonly paginationService: PaginationService, // 🎯 注入分页服务
  ) {}

  async create(createDto: CreateExampleDto): Promise<ExampleResponseDto> {
    // 🎯 使用 common 模块的日志脱敏功能
    this.logger.log(`创建实体: ${createDto.name}`, {
      operation: 'create',
      data: sanitizeLogData(createDto) // 自动脱敏敏感数据
    });

    try {
      // 1. 业务逻辑验证
      await this.validateBusinessRules(createDto);

      // 2. 数据转换和处理
      const entityData = this.transformCreateDto(createDto);

      // 3. 数据库操作
      const createdEntity = await this.exampleRepository.create(entityData);

      // 4. 返回响应DTO
      return ExampleResponseDto.fromEntity(createdEntity);
    } catch (error) {
      this.logger.error(`创建失败: ${error.message}`, {
        operation: 'create',
        error: error.stack,
        input: sanitizeLogData(createDto) // 🎯 错误日志也要脱敏
      });
      throw error;
    }
  }

  async findById(id: string): Promise<ExampleResponseDto> {
    this.logger.debug(`查询实体: ${id}`);

    const entity = await this.exampleRepository.findById(id);
    if (!entity) {
      // 🎯 使用标准的 NestJS 异常，让全局异常过滤器处理
      throw new NotFoundException(`实体不存在: ${id}`);
    }

    return ExampleResponseDto.fromEntity(entity);
  }

  // 🎯 分页查询：使用PaginationService
  async findPaginated(query: ExampleQueryDto): Promise<PaginatedDataDto<ExampleResponseDto>> {
    const { items, total } = await this.exampleRepository.findPaginated(query);
    const responseItems = items.map(item => ExampleResponseDto.fromDocument(item));
    
    // 使用分页服务自动处理分页逻辑
    return this.paginationService.createPaginatedResponseFromQuery(responseItems, query, total);
  }

  // 🎯 示例：使用 common 模块的通用接口实现数据映射
  async processDataWithMapping(
    rawData: any,
    mappingRuleId: string,
    dataMapper: IDataMapper
  ): Promise<any> {
    try {
      return await dataMapper.mapData(rawData, mappingRuleId);
    } catch (error) {
      this.logger.error('数据映射失败', {
        operation: 'processDataWithMapping',
        mappingRuleId,
        error: error.message
      });
      throw error;
    }
  }

  // 私有辅助方法
  private async validateBusinessRules(dto: CreateExampleDto): Promise<void> {
    // 🎯 可以使用 common 模块的常量进行验证
    if (dto.market && !Object.values(MARKETS).includes(dto.market as Market)) {
      throw new ConflictException(`不支持的市场: ${dto.market}`);
    }
    // 其他业务规则验证逻辑
  }

  private transformCreateDto(dto: CreateExampleDto): Partial<Example> {
    // DTO到实体的转换逻辑
    return {
      name: dto.name.trim(),
      // 🎯 使用 common 模块的类型确保类型安全
      market: dto.market as Market,
      // 其他字段转换
    };
  }
}
```

### 4.2 服务编写标准

1. **单一职责**：每个服务专注于一个业务领域
2. **依赖注入**：通过构造函数注入依赖
3. **错误处理**：使用NestJS标准异常类型
4. **日志记录**：记录关键操作的结构化日志
5. **返回DTO**：服务方法返回DTO而非实体对象
6. **事务处理**：涉及多个数据库操作时使用事务
7. **分页处理**：使用PaginationService统一处理分页逻辑 ⭐

#### 4.2.1 模块配置

⭐ **重要**：在Module的`providers`中添加`PaginationService`

## 5. DTO开发规范

### 5.1 DTO结构模板

```typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsEnum,
  IsArray,
  ValidateNested,
  MinLength,
  MaxLength,
  IsEmail
} from 'class-validator';
import { Type } from 'class-transformer';
// 🎯 复用 common 模块的通用类型和常量
import { Market, ProviderName } from '@common/types/common.types';
import { StorageClassification } from '@common/types/field-naming.types';
import { MARKETS } from '@common/constants/markets.constants';
import { PROVIDERS } from '@common/constants/providers.constants';

/**
 * 创建实体DTO
 */
export class CreateExampleDto {
  @ApiProperty({
    description: '实体名称',
    example: '示例名称',
    minLength: 3,
    maxLength: 50
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(3)
  @MaxLength(50)
  name: string;

  @ApiProperty({
    description: '实体类型',
    enum: ExampleType,
    example: ExampleType.STANDARD
  })
  @IsEnum(ExampleType)
  type: ExampleType;

  // 🎯 使用 common 模块的市场常量
  @ApiPropertyOptional({
    description: '市场类型',
    enum: MARKETS,
    example: MARKETS.HK
  })
  @IsOptional()
  @IsEnum(MARKETS, { message: '不支持的市场类型' })
  market?: Market;

  // 🎯 根据组件语义使用相应的字段
  // 示例：如果这是Storage层的DTO，使用 storageClassification
  @ApiPropertyOptional({
    description: '数据分类（Storage层语义）',
    enum: StorageClassification,
    example: StorageClassification.STOCK_QUOTE
  })
  @IsOptional()
  @IsEnum(StorageClassification, { message: '不支持的数据分类' })
  storageClassification?: StorageClassification;
  
  // 示例：如果这是Receiver层的DTO，使用 receiverType
  // @ApiPropertyOptional({
  //   description: '能力类型（Receiver层语义）',
  //   example: 'get-stock-quote'
  // })
  // @IsOptional()
  // @IsString()
  // receiverType?: string;

  @ApiPropertyOptional({
    description: '可选描述',
    maxLength: 500
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  description?: string;

  @ApiPropertyOptional({
    description: '标签列表',
    type: [String]
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    description: '嵌套对象',
    type: NestedDto
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => NestedDto)
  nestedObject?: NestedDto;
}

/**
 * 响应实体DTO
 * 🎯 继承或使用 common 模块的通用响应格式
 */
export class ExampleResponseDto {
  @ApiProperty({ description: '实体ID' })
  id: string;

  @ApiProperty({ description: '实体名称' })
  name: string;

  @ApiProperty({ description: '实体类型', enum: ExampleType })
  type: ExampleType;

  // 🎯 使用 common 模块的类型
  @ApiPropertyOptional({
    description: '市场类型',
    enum: MARKETS
  })
  market?: Market;

  @ApiPropertyOptional({
    description: '数据分类（根据实际组件语义选择合适字段）',
    enum: StorageClassification
  })
  storageClassification?: StorageClassification;

  @ApiProperty({ description: '创建时间' })
  createdAt: Date;

  @ApiProperty({ description: '更新时间' })
  updatedAt: Date;

  /**
   * 从实体对象创建响应DTO
   * 🎯 标准化的工厂方法，确保数据转换一致性
   */
  static fromEntity(entity: Example): ExampleResponseDto {
    const dto = new ExampleResponseDto();
    dto.id = entity._id?.toString() || entity.id;
    dto.name = entity.name;
    dto.type = entity.type;
    dto.market = entity.market as Market; // 🎯 类型安全转换
    dto.storageClassification = entity.storageClassification as StorageClassification;
    dto.createdAt = entity.createdAt;
    dto.updatedAt = entity.updatedAt;
    return dto;
  }

  /**
   * 从MongoDB文档创建响应DTO
   * 🎯 处理数据库文档的标准化方法
   */
  static fromDocument(doc: any): ExampleResponseDto {
    const dto = new ExampleResponseDto();
    dto.id = doc._id.toString();
    dto.name = doc.name;
    dto.type = doc.type;
    dto.market = doc.market as Market;
    dto.storageClassification = doc.storageClassification as StorageClassification;
    dto.createdAt = doc.createdAt;
    dto.updatedAt = doc.updatedAt;
    return dto;
  }

  /**
   * 🎯 批量转换方法，提高性能
   */
  static fromEntities(entities: Example[]): ExampleResponseDto[] {
    return entities.map(entity => this.fromEntity(entity));
  }
}

/**
 * 查询参数DTO
 * 🎯 推荐使用 PaginationService 处理分页逻辑，而非手动实现
 */
export class ExampleQueryDto {
  @ApiPropertyOptional({ description: '页码', minimum: 1, default: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ description: '每页数量', minimum: 1, maximum: 100, default: 10 })
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  @Max(100)
  limit?: number = 10;

  @ApiPropertyOptional({ description: '搜索关键词' })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({ description: '类型筛选', enum: ExampleType })
  @IsOptional()
  @IsEnum(ExampleType)
  type?: ExampleType;

  // 🎯 使用 common 模块的常量进行筛选
  @ApiPropertyOptional({
    description: '市场筛选',
    enum: MARKETS
  })
  @IsOptional()
  @IsEnum(MARKETS)
  market?: Market;

  @ApiPropertyOptional({
    description: '数据类型过滤器',
    enum: DataType
  })
  @IsOptional()
  @IsEnum(DataType)
  queryTypeFilter?: DataType;
}
```

### 5.2 DTO编写标准

1. **详细的API文档**：每个字段都要有`@ApiProperty`或`@ApiPropertyOptional`
2. **完整的验证规则**：使用`class-validator`装饰器进行验证
3. **类型转换**：使用`class-transformer`进行类型转换
4. **工厂方法**：响应DTO提供`fromEntity`和`fromDocument`静态方法
5. **嵌套验证**：复杂对象使用`@ValidateNested`和`@Type`
6. **中文描述**：所有描述信息使用中文
7. **🎯 复用 common 模块**：
   - 使用 `@common/types` 中的通用类型定义
   - 使用 `@common/constants` 中的枚举常量
   - 使用 `@common/interfaces` 中的接口定义
   - 继承 `@common/dto` 中的通用响应格式

### 5.3 DTO 复用 common 模块最佳实践

#### 5.3.1 类型安全的常量使用
```typescript
// ✅ 正确：使用 common 模块的类型安全常量
import { MARKETS } from '@common/constants/markets.constants';
import { DataType } from '@common/constants/data-type.constants';

@IsEnum(MARKETS, { message: '不支持的市场类型' })
market: Market;

// ❌ 错误：硬编码枚举值
@IsEnum(['HK', 'US', 'SZ', 'SH'], { message: '不支持的市场类型' })
market: string;
```

#### 5.3.2 通用接口的实现
```typescript
// ✅ 正确：实现 common 模块的接口
import { IDataMappingRule } from '@common/interfaces/data-mapping.interface';

export class DataMappingDto implements IDataMappingRule {
  // 实现接口定义的所有字段
}

// ✅ 正确：使用 common 模块的类型
import { Market, ProviderName } from '@common/types/common.types';

export class QueryDto {
  @IsEnum(Object.values(MARKETS))
  market: Market;

  @IsEnum(Object.values(PROVIDERS))
  provider: ProviderName;
}
```



#### 响应 DTO 类型概览

系统提供了三个标准化的响应 DTO 类，位于 `src/common/dto/common-response.dto.ts`：

##### 1. ApiResponseDto<T> - 标准 API 响应格式
```typescript
export class ApiResponseDto<T = any> {
  statusCode: number;    // HTTP 状态码
  message: string;       // 响应消息
  data?: T;             // 响应数据（泛型）
  timestamp?: string;    // 请求时间戳
}
```

**使用场景**：
- 所有标准的 API 响应
- 单个资源的 CRUD 操作
- 业务逻辑处理结果

**使用示例**：
```typescript
// 在控制器中指定响应类型
@ApiSuccessResponse({
  type: ApiResponseDto,
  description: '获取用户信息成功'
})
async getUserProfile(): Promise<UserDto> {
  // 直接返回数据，ResponseInterceptor 会自动包装为 ApiResponseDto 格式
  return await this.userService.getProfile();
}
```

##### 2. ErrorResponseDto - 错误响应格式
```typescript
export class ErrorResponseDto {
  statusCode: number;           // HTTP 状态码
  message: string | string[];   // 错误消息
  error: string;               // 错误代码
  details?: Array<{            // 错误详情（可选）
    field: string;
    code: string;
    message: string;
  }>;
  timestamp: string;           // 请求时间戳
  path: string;               // 请求路径
}
```

**使用场景**：
- 所有错误响应（由全局异常过滤器自动处理）
- 参数验证错误
- 业务逻辑错误
- 系统异常

**自动处理**：
```typescript
// 错误响应由全局异常过滤器自动格式化，无需手动构造
throw new BadRequestException('用户名不能为空');
// 自动转换为 ErrorResponseDto 格式
```

##### 3. PaginatedDataDto<T> - 分页响应格式 ⭐
```typescript
// 📂 位置：@common/modules/pagination/dto/paginated-data
export class PaginatedDataDto<T = unknown> {
  @ApiProperty({ description: "数据列表" })
  items: T[];

  @ApiProperty({
    description: "分页信息",
    example: {
      page: 1,
      limit: 10,
      total: 100,
      totalPages: 10,
      hasNext: true,
      hasPrev: false,
    },
  })
  pagination: {
    page: number;              // 当前页码
    limit: number;             // 每页数量
    total: number;             // 总记录数
    totalPages: number;        // 总页数
    hasNext: boolean;          // 是否有下一页
    hasPrev: boolean;          // 是否有上一页
  };
}
```

**使用场景**：
- 分页查询结果
- 列表数据展示
- 批量数据处理结果

**使用方式**：

1. **Service层**：注入PaginationService，使用`createPaginatedResponseFromQuery()`方法
2. **Repository层**：使用`normalizePaginationQuery()`和`calculateSkip()`方法
3. **Module层**：在providers中注册PaginationService

**核心使用步骤**：
- Repository获取`{ items, total }`
- Service调用`paginationService.createPaginatedResponseFromQuery(items, query, total)`
- 自动返回标准化的PaginatedDataDto格式

#### DTO 使用最佳实践

##### 1. 响应类型声明
```typescript
// ✅ 正确：明确指定响应 DTO 类型
@ApiSuccessResponse({
  type: ApiResponseDto,
  description: '操作成功',
  schema: {
    example: {
      statusCode: 200,
      message: '操作成功',
      data: { id: 1, name: '示例数据' },
      timestamp: '2024-01-01T12:00:00.000Z'
    }
  }
})

// ❌ 错误：缺少类型声明
@ApiSuccessResponse({ description: '操作成功' })
```

##### 2. 泛型类型使用
```typescript
// ✅ 正确：使用具体的数据类型
@ApiSuccessResponse({
  type: ApiResponseDto<UserDto>,
  description: '获取用户信息成功'
})
async getUser(): Promise<UserDto> {
  return await this.userService.findById(id);
}

// ✅ 正确：数组类型
@ApiSuccessResponse({
  type: ApiResponseDto<UserDto[]>,
  description: '获取用户列表成功'
})
async getUsers(): Promise<UserDto[]> {
  return await this.userService.findAll();
}
```

##### 3. 错误响应处理
```typescript
// ✅ 正确：让全局异常过滤器处理
async createUser(@Body() createUserDto: CreateUserDto) {
  try {
    return await this.userService.create(createUserDto);
  } catch (error) {
    // 直接抛出异常，让全局过滤器格式化为 ErrorResponseDto
    throw new ConflictException('用户名已存在');
  }
}

// ❌ 错误：手动构造错误响应
async createUser(@Body() createUserDto: CreateUserDto) {
  try {
    return await this.userService.create(createUserDto);
  } catch (error) {
    // 不要手动构造 ErrorResponseDto
    return new ErrorResponseDto(409, '用户名已存在', 'Conflict', '/users');
  }
}
```

## 6. 数据库和仓储层规范

### 6.1 Schema定义规范

```typescript
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';
// 🎯 复用 common 模块的类型和常量
import { Market, ProviderName } from '@common/types/common.types';
import { DataType } from '@common/constants/data-type.constants';
import { MARKETS } from '@common/constants/markets.constants';
import { PROVIDERS } from '@common/constants/providers.constants';

@Schema({
  timestamps: true,  // 自动添加createdAt和updatedAt
  collection: 'examples',
})
export class Example {
  @Prop({ required: true, trim: true, minlength: 3, maxlength: 50 })
  name: string;

  @Prop({ required: true, enum: ExampleType })
  type: ExampleType;

  // 🎯 使用 common 模块的市场常量
  @Prop({
    enum: Object.values(MARKETS),
    required: false
  })
  market?: Market;

  // 🎯 使用字段语义四层架构中的相应枚举
  @Prop({
    enum: Object.values(StorageClassification),
    required: false
  })
  storageClassification?: StorageClassification;

  // 🎯 使用 common 模块的提供商常量
  @Prop({
    enum: Object.values(PROVIDERS),
    required: false
  })
  provider?: ProviderName;

  @Prop({ maxlength: 500 })
  description?: string;

  @Prop({ type: [String], default: [] })
  tags: string[];

  @Prop({ default: true })
  isActive: boolean;

  // 时间戳字段由timestamps选项自动添加
  createdAt?: Date;
  updatedAt?: Date;
}

export type ExampleDocument = Example & Document;
export const ExampleSchema = SchemaFactory.createForClass(Example);

// 🎯 使用 common 模块常量创建复合索引
ExampleSchema.index({ name: 1 }, { unique: true });
ExampleSchema.index({ type: 1, isActive: 1 });
ExampleSchema.index({ market: 1, storageClassification: 1 }); // 业务查询优化
ExampleSchema.index({ provider: 1, isActive: 1 }); // 提供商查询优化
ExampleSchema.index({ createdAt: -1 });

// 🎯 标准化的JSON序列化方法
ExampleSchema.methods.toJSON = function() {
  const obj = this.toObject();
  obj.id = obj._id.toString();
  delete obj._id;
  delete obj.__v;
  return obj;
};
```

### 6.2 仓储层实现规范

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Example, ExampleDocument } from '../schemas/example.schema';
import { CreateExampleDto, UpdateExampleDto, ExampleQueryDto } from '../dto';
// 🎯 复用 common 模块的类型和工具
import { Market, ProviderName } from '@common/types/common.types';
import { DataType } from '@common/constants/data-type.constants';
import { MARKETS } from '@common/constants/markets.constants';
// 🎯 复用 common 模块的日志配置
import { createLogger, sanitizeLogData } from '@common/config/logger.config';
// 🎯 复用 common 模块的分页服务
import { PaginationService } from '@common/modules/pagination/services/pagination.service';

@Injectable()
export class ExampleRepository {
  // 🎯 使用 common 模块的日志配置
  private readonly logger = createLogger(ExampleRepository.name);

  constructor(
    @InjectModel(Example.name) private readonly exampleModel: Model<ExampleDocument>,
    private readonly paginationService: PaginationService, // 🎯 注入分页服务
  ) {}

  async create(createDto: Partial<Example>): Promise<ExampleDocument> {
    // 🎯 使用日志脱敏功能
    this.logger.debug(`创建实体: ${createDto.name}`, {
      operation: 'create',
      data: sanitizeLogData(createDto)
    });

    const entity = new this.exampleModel(createDto);
    return entity.save();
  }

  async findById(id: string): Promise<ExampleDocument | null> {
    this.logger.debug(`查询实体: ${id}`);

    return this.exampleModel
      .findById(id)
      .where('isActive')
      .equals(true)
      .lean()
      .exec();
  }

  // 🎯 支持字段语义四层架构的查询方法
  async findByMarketAndClassification(
    market: Market,
    storageClassification: StorageClassification
  ): Promise<ExampleDocument[]> {
    this.logger.debug(`按市场和数据分类查询: ${market}, ${storageClassification}`);

    return this.exampleModel
      .find({
        market,
        storageClassification,
        isActive: true
      })
      .sort({ createdAt: -1 })
      .lean()
      .exec();
  }

  // 🎯 分页查询：使用PaginationService
  async findPaginated(query: ExampleQueryDto): Promise<{ items: ExampleDocument[]; total: number }> {
    // 标准化分页参数并计算skip
    const { page, limit } = this.paginationService.normalizePaginationQuery(query);
    const skip = this.paginationService.calculateSkip(page, limit);

    // 构建查询条件...
    const filter = { /* 查询条件 */ };

    // 并行查询数据和总数
    const [items, total] = await Promise.all([
      this.exampleModel.find(filter).skip(skip).limit(limit).lean().exec(),
      this.exampleModel.countDocuments(filter).exec(),
    ]);

    return { items, total };
  }


  async updateById(id: string, updateDto: Partial<Example>): Promise<ExampleDocument | null> {
    this.logger.debug(`更新实体: ${id}`);
    
    return this.exampleModel
      .findByIdAndUpdate(id, updateDto, { new: true })
      .where('isActive')
      .equals(true)
      .lean()
      .exec();
  }

  async deleteById(id: string): Promise<boolean> {
    this.logger.debug(`删除实体: ${id}`);
    
    const result = await this.exampleModel
      .findByIdAndUpdate(id, { isActive: false }, { new: true })
      .exec();
    
    return !!result;
  }

  async existsByName(name: string, excludeId?: string): Promise<boolean> {
    const filter: any = { name, isActive: true };
    
    if (excludeId) {
      filter._id = { $ne: excludeId };
    }

    const count = await this.exampleModel.countDocuments(filter).exec();
    return count > 0;
  }
}
```

### 6.3 数据库设计标准

1. **Schema设计**：使用TypeScript类定义，启用时间戳
2. **索引优化**：为常用查询字段创建索引
3. **软删除**：使用`isActive`字段实现软删除
4. **查询优化**：使用`.lean()`获得更好的性能
5. **事务支持**：复杂操作使用MongoDB事务
6. **硬编码ID**：核心数据使用预定义的ObjectId
7. **🎯 复用 common 模块标准**：
   - 使用 `@common/types` 中的类型定义确保类型安全
   - 使用 `@common/constants` 中的枚举值作为Schema约束
   - 使用 `@common/config/logger.config` 进行日志记录和脱敏
   - 实现 `@common/interfaces` 中定义的数据接口

### 6.4 数据库复用 common 模块最佳实践

#### 6.4.1 类型安全的Schema定义
```typescript
// ✅ 正确：使用 common 模块的类型约束
import { MARKETS } from '@common/constants/markets.constants';

@Prop({
  enum: Object.values(MARKETS),
  validate: {
    validator: (v: string) => Object.values(MARKETS).includes(v as Market),
    message: '不支持的市场类型'
  }
})
market: Market;

// ❌ 错误：硬编码枚举值
@Prop({ enum: ['HK', 'US', 'SZ', 'SH'] })
market: string;
```

#### 6.4.2 统一的查询方法
```typescript
// ✅ 正确：使用 common 模块类型的查询方法
async findByBusinessCriteria(
  market: Market,
  storageClassification: DataType,
  provider: ProviderName
): Promise<ExampleDocument[]> {
  return this.exampleModel
    .find({ market, storageClassification, provider, isActive: true })
    .lean()
    .exec();
}

// ✅ 正确：实现 common 接口的查询方法
async findByCapabilityName(capabilityName: string): Promise<ExampleDocument[]> {
  // 使用 common 模块的能力接口标准
  return this.exampleModel
    .find({
      capabilityName,
      isActive: true
    })
    .lean()
    .exec();
}
```

## 7. 错误处理和响应规范

### 7.1 异常处理标准

```typescript
import {
  BadRequestException,
  NotFoundException,
  ConflictException,
  UnauthorizedException,
  ForbiddenException,
  InternalServerErrorException
} from '@nestjs/common';
// 🎯 复用 common 模块的类型和常量
import { Market, ProviderName } from '@common/types/common.types';
import { DataType } from '@common/constants/data-type.constants';
import { MARKETS } from '@common/constants/markets.constants';

// 🎯 使用 common 模块常量进行验证的异常处理
if (!entity) {
  throw new NotFoundException(`实体不存在: ${id}`);
}

if (await this.repository.existsByName(dto.name)) {
  throw new ConflictException(`名称已存在: ${dto.name}`);
}

if (!user.hasPermission(action)) {
  throw new ForbiddenException('权限不足，无法执行此操作');
}

// 🎯 使用 common 模块常量进行业务验证
if (dto.market && !Object.values(MARKETS).includes(dto.market as Market)) {
  throw new BadRequestException(`不支持的市场类型: ${dto.market}`);
}

if (dto.storageClassification && !Object.values(StorageClassification).includes(dto.storageClassification)) {
  throw new BadRequestException(`不支持的数据分类: ${dto.storageClassification}`);
}
```

### 7.2 自定义业务异常

```typescript
import { HttpException, HttpStatus } from '@nestjs/common';

export class BusinessException extends HttpException {
  constructor(
    message: string,
    code: string,
    statusCode: HttpStatus = HttpStatus.BAD_REQUEST,
    details?: any
  ) {
    super(
      {
        message,
        code,
        details,
        timestamp: new Date().toISOString()
      },
      statusCode
    );
  }
}

// 使用示例
throw new BusinessException(
  '业务规则验证失败',
  'BUSINESS_RULE_VIOLATION',
  HttpStatus.UNPROCESSABLE_ENTITY,
  { field: 'amount', constraint: 'minimum_value' }
);
```

### 7.3 全局异常过滤器

🎯 系统已实现全局异常过滤器（`@common/filters/global-exception.filter.ts`），确保所有错误响应格式一致：

```typescript
{
  statusCode: number;
  message: string | string[];
  error: string;
  details?: Array<{ field: string; code: string; message: string }>;
  timestamp: string;
  path: string;
}
```

#### 7.3.1 全局异常过滤器特性

🎯 **复用 common 模块的全局异常过滤器提供以下功能**：

1. **统一错误格式**：所有异常自动转换为 `ErrorResponseDto` 格式
2. **智能异常识别**：自动识别MongoDB、JWT、验证等不同类型异常
3. **中文错误消息**：自动翻译常见错误为中文
4. **敏感信息脱敏**：使用 `@common/config/logger.config` 的脱敏功能
5. **结构化日志**：使用 `@common/utils/http-headers.util` 提取请求信息
6. **生产环境优化**：生产环境下隐藏敏感的错误详情

#### 7.3.2 异常处理最佳实践

```typescript
// ✅ 正确：让全局过滤器处理异常格式化
try {
  return await this.service.processData(data);
} catch (error) {
  // 直接抛出，让全局过滤器处理
  throw error;
}

// ✅ 正确：使用标准NestJS异常
if (!isValidMarket(dto.market)) {
  throw new BadRequestException(`不支持的市场: ${dto.market}`);
}

// ❌ 错误：手动构造错误响应
try {
  return await this.service.processData(data);
} catch (error) {
  return {
    statusCode: 500,
    message: '处理失败',
    error: 'InternalServerError'
  };
}
```

## 8. 认证和授权规范

系统使用三层认证体系，具体的权限定义和认证机制请参考：
- **权限系统架构**: 详见 [系统基本架构和说明文档.md](./系统基本架构和说明文档.md#三层认证体系)
- **API Key管理**: 详见 [apikey-management.md](./apikey-management.md)

### 8.1 认证装饰器使用

#### JWT认证示例
```typescript
// 管理员功能
@Auth([UserRole.ADMIN])
@Get('profile')
@ApiOperation({ summary: '获取用户信息' })
@ApiSuccessResponse({ type: UserResponseDto })
@JwtAuthResponses()
async getProfile() {}
```

#### API Key认证示例
```typescript
// 第三方应用访问
@ApiKeyAuth()
@RequirePermissions(Permission.DATA_READ)
@Post('receiver/data')
@ApiOperation({ summary: '获取股票数据' })
@ApiSuccessResponse({ type: DataResponseDto })
@ApiStandardResponses()
async getData() {}
```

#### 公开访问示例
```typescript
@Public()
@Get('health')
@ApiOperation({ summary: '健康检查' })
@ApiHealthResponse()
async getHealth() {}
```

## 9. 性能监控和日志规范

### 9.1 日志记录标准

🎯 **强烈建议使用 common 模块的日志配置**：

```typescript
// 🎯 使用 common 模块的日志配置
import { createLogger, sanitizeLogData, LoggerConfig } from '@common/config/logger.config';

export class ExampleService {
  // 🎯 使用 common 模块创建日志实例
  private readonly logger = createLogger(ExampleService.name);

  async processData(data: any, user: any) {
    const startTime = Date.now();

    // 🎯 信息日志 - 自动脱敏敏感数据
    this.logger.log('操作成功', {
      operation: 'processData',
      userId: user.id,
      duration: Date.now() - startTime,
      data: sanitizeLogData(data) // 自动脱敏
    });

    try {
      // 业务逻辑
    } catch (error) {
      // 🎯 错误日志 - 自动脱敏输入数据
      this.logger.error('操作失败', {
        operation: 'processData',
        error: error.message,
        stack: error.stack,
        input: sanitizeLogData(data) // 自动脱敏
      });
      throw error;
    }
  }

  // 🎯 调试日志
  debugOperation(details: any) {
    this.logger.debug('调试信息', {
      details: sanitizeLogData(details)
    });
  }

  // 🎯 性能警告日志
  checkPerformance(operation: string, duration: number) {
    if (duration > 1000) {
      this.logger.warn('性能警告', {
        operation,
        duration,
        threshold: 1000
      });
    }
  }
}
```

#### 9.1.1 日志脱敏功能

🎯 **common 模块提供自动脱敏功能**，保护敏感信息：

```typescript
import { sanitizeLogData, LoggerConfig } from '@common/config/logger.config';

// 自动脱敏的敏感字段
const sensitiveData = {
  username: 'john_doe',
  password: 'secret123',
  accessToken: 'eyJhbGciOiJIUzI1NiIs...',
  apiKey: 'ak_1234567890abcdef'
};

// 脱敏后的数据
const sanitized = sanitizeLogData(sensitiveData);
// 结果: { username: 'john_doe', password: '****', accessToken: 'ey****ef', apiKey: 'ak****ef' }
```

#### 9.1.2 日志配置常量

```typescript
// 🎯 使用 common 模块的日志配置
import { LoggerConfig } from '@common/config/logger.config';

// 最大日志消息长度
if (message.length > LoggerConfig.MAX_MESSAGE_LENGTH) {
  message = message.substring(0, LoggerConfig.MAX_MESSAGE_LENGTH) + '...';
}

// 敏感字段列表
const isSensitive = LoggerConfig.SENSITIVE_FIELDS.some(field =>
  key.toLowerCase().includes(field)
);
```

### 9.2 性能监控

🎯 **系统使用 common 模块的拦截器进行性能监控**：

#### 9.2.1 ResponseInterceptor（响应拦截器）
位置：`@common/interceptors/response.interceptor.ts`

**功能**：
- 自动包装所有响应为标准格式
- 跳过健康检查和指标端点
- 提供统一的响应时间戳
- 结构化日志记录

**使用方式**：
```typescript
// 全局注册（已在 main.ts 中配置）
app.useGlobalInterceptors(new ResponseInterceptor());

// 控制器中无需特殊处理，直接返回数据
@Get('users')
async getUsers(): Promise<UserDto[]> {
  return await this.userService.findAll(); // 自动包装为标准响应格式
}
```

#### 9.2.2 性能监控最佳实践

```typescript
// ✅ 正确：让拦截器自动处理响应格式
@Get('data')
async getData(): Promise<DataDto[]> {
  const startTime = Date.now();

  try {
    const result = await this.dataService.fetchData();

    // 记录性能指标
    const duration = Date.now() - startTime;
    if (duration > 1000) {
      this.logger.warn('慢查询检测', { duration, operation: 'getData' });
    }

    return result; // 拦截器自动包装
  } catch (error) {
    this.logger.error('查询失败', {
      operation: 'getData',
      duration: Date.now() - startTime,
      error: error.message
    });
    throw error;
  }
}

// ❌ 错误：手动包装响应
@Get('data')
async getData() {
  const result = await this.dataService.fetchData();
  return {
    statusCode: 200,
    message: '获取成功',
    data: result,
    timestamp: new Date().toISOString()
  }; // 不要手动包装
}
```

### 9.3 健康检查

🎯 **使用 common 模块的标准健康检查格式**：

```typescript
import { Public } from '@auth/decorators/auth.decorator';
import { ApiHealthResponse } from '@common/decorators/swagger-responses.decorator';

@Public()
@Get('health')
@ApiOperation({ summary: '系统健康检查' })
@ApiHealthResponse() // 🎯 使用 common 模块的健康检查响应装饰器
async healthCheck() {
  return {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    // 🎯 可以添加更多系统状态信息
    memory: {
      used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
      total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024)
    }
  };
}

// 🎯 高级健康检查（包含依赖服务状态）
@Public()
@Get('health/detailed')
@ApiOperation({ summary: '详细健康检查' })
@ApiHealthResponse()
async detailedHealthCheck() {
  const checks = await Promise.allSettled([
    this.checkDatabase(),
    this.checkRedis(),
    this.checkExternalAPIs()
  ]);

  const status = checks.every(check => check.status === 'fulfilled') ? 'ok' : 'error';

  return {
    status,
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    checks: {
      database: checks[0].status === 'fulfilled' ? 'ok' : 'error',
      redis: checks[1].status === 'fulfilled' ? 'ok' : 'error',
      externalAPIs: checks[2].status === 'fulfilled' ? 'ok' : 'error'
    }
  };
}
```

## 10. Shared 模块复用指南 🎯

### 10.1 Shared 模块概览

经过架构优化和代码清理，`src/common` 目录现在只包含真正跨模块共享的核心基础设施代码。遵循"最小必要原则"，只保留最核心的通用功能：

```
src/common/
├── config/                     # 通用配置
│   └── logger.config.ts        # 日志配置和脱敏功能
├── constants/                  # 通用常量
│   └── market.constants.ts     # 市场常量和枚举
├── decorators/                 # 通用装饰器
│   └── swagger-responses.decorator.ts  # Swagger响应装饰器
├── dto/                        # 通用DTO
│   └── common-response.dto.ts  # 标准响应格式
├── filters/                    # 通用过滤器
│   ├── global-exception.filter.ts  # 全局异常过滤器
│   └── index.ts                # 过滤器导出
├── interceptors/               # 通用拦截器
│   ├── response.interceptor.ts # 响应格式化拦截器
│   └── index.ts                # 拦截器导出
└── utils/                      # 通用工具
    └── http-headers.util.ts    # HTTP头处理工具
```

#### 🎯 架构优化说明

**删除的冗余组件**：
- `interfaces/` - 接口定义已迁移到各自的业务模块中
- `types/` - 类型定义已迁移到各自的业务模块中
- `constants/providers.constants.ts` - 未被使用，已删除
- `constants/data-type.constants.ts` - 已迁移到业务模块中

**保留原则**：
1. **真正的跨模块共享** - 被多个模块使用的基础设施
2. **核心基础功能** - 日志、异常处理、响应格式化等
3. **框架级别的组件** - 拦截器、过滤器、装饰器等

### 10.2 强制复用规范

#### 10.2.1 导入路径标准化

**所有组件必须使用 `@common` 路径别名**：

```typescript
// ✅ 正确：使用路径别名
import { Market, MARKETS, MARKET_NAMES } from '@common/constants/market.constants';
import { PaginatedResponseDto } from '@common/dto/common-response.dto';
import { createLogger, sanitizeLogData } from '@common/config/logger.config';
import { HttpHeadersUtil } from '@common/utils/http-headers.util';

// ❌ 错误：使用相对路径
import { Market } from '../../../common/constants/market.constants';
import { PaginatedResponseDto } from '../../common/dto/common-response.dto';
```

#### 10.2.2 市场常量复用

**必须使用 common 模块的市场常量，禁止硬编码**：

```typescript
// ✅ 正确：使用 common 市场常量
import { Market, MARKETS, MARKET_NAMES } from '@common/constants/market.constants';

if (!Object.values(MARKETS).includes(market as Market)) {
  throw new BadRequestException(`不支持的市场: ${market}`);
}

// ❌ 错误：硬编码常量
const supportedMarkets = ['HK', 'US', 'SZ', 'SH'];  // 不要硬编码
```

#### 10.2.3 日志记录标准化

**必须使用 common 模块的日志配置，确保日志一致性和安全性**：

```typescript
// ✅ 正确：使用 common 日志配置
import { createLogger, sanitizeLogData } from '@common/config/logger.config';

export class ExampleService {
  private readonly logger = createLogger(ExampleService.name);

  async processData(data: any): Promise<any> {
    this.logger.log('处理数据开始', sanitizeLogData({ requestData: data }));
    // ... 处理逻辑
  }
}

// ❌ 错误：直接使用console或Logger
console.log('处理数据', data);  // 不要直接使用console
```

### 10.3 组件级复用指南

#### 10.3.1 控制器复用清单

**每个控制器必须复用以下 common 组件**：

```typescript
// 🎯 控制器复用清单
import { Controller, Get, Post, Body, Query } from '@nestjs/common';
import { ApiTags, ApiOperation } from '@nestjs/swagger';

// ✅ 必须复用：认证装饰器
import { Auth, ApiKeyAuth, Public } from '@auth/decorators/auth.decorator';

// ✅ 必须复用：Swagger响应装饰器
import {
  ApiSuccessResponse,
  ApiCreatedResponse,
  ApiPaginatedResponse,
  ApiStandardResponses,
  JwtAuthResponses,
  ApiHealthResponse
} from '@common/decorators/swagger-responses.decorator';

// ✅ 必须复用：通用响应DTO
import { PaginatedResponseDto } from '@common/dto/common-response.dto';

// ✅ 必须复用：日志配置
import { createLogger } from '@common/config/logger.config';

// ✅ 必须复用：市场常量
import { Market, MARKETS } from '@common/constants/market.constants';

@ApiTags('示例模块')
@Controller('api/v1/examples')
export class ExampleController {
  private readonly logger = createLogger(ExampleController.name);

  @ApiKeyAuth()
  @RequirePermissions(Permission.DATA_READ)
  @Get()
  @ApiOperation({ summary: '获取示例列表' })
  @ApiPaginatedResponse(ExampleDto, { description: '获取示例列表成功' })
  @ApiStandardResponses()
  async getExamples(@Query() query: ExampleQueryDto): Promise<PaginatedResponseDto<ExampleDto>> {
    return await this.exampleService.findAll(query);
  }
}
```

#### 10.3.2 服务层复用清单

**每个服务必须复用以下 common 组件**：

```typescript
// 🎯 服务层复用清单
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';

// ✅ 必须复用：日志配置
import { createLogger, sanitizeLogData } from '@common/config/logger.config';

// ✅ 必须复用：市场常量
import { Market, MARKETS, MARKET_NAMES } from '@common/constants/market.constants';

@Injectable()
export class ExampleService {
  // ✅ 必须复用：shared 日志配置
  private readonly logger = createLogger(ExampleService.name);

  async processData(data: any): Promise<any> {
    // ✅ 必须复用：日志脱敏
    this.logger.log('处理数据开始', sanitizeLogData({
      operation: 'processData',
      dataKeys: Object.keys(data)
    }));

    // ✅ 必须复用：市场常量验证
    if (data.market && !Object.values(MARKETS).includes(data.market)) {
      throw new ConflictException(`不支持的市场: ${data.market}`);
    }

    // 处理逻辑...
    const result = await this.doProcess(data);
    
    this.logger.log('处理数据完成', sanitizeLogData({
      operation: 'processData',
      resultSize: result?.length || 0
    }));

    return result;
  }
}
```

#### 10.3.3 HTTP头处理复用

**必须使用 common 模块的HTTP头处理工具**：

```typescript
// ✅ 正确：使用 common HTTP头工具
import { HttpHeadersUtil } from '@common/utils/http-headers.util';

@Injectable()
export class ApiKeyService {
  extractApiKeyFromHeaders(request: Request): { appKey?: string; accessToken?: string } {
    // 使用统一的头部提取工具
    const appKey = HttpHeadersUtil.extractAppKey(request);
    const accessToken = HttpHeadersUtil.extractAccessToken(request);
    
    return { appKey, accessToken };
  }
}

// ❌ 错误：重复实现头部提取逻辑
@Injectable()
export class ApiKeyService {
  extractApiKeyFromHeaders(request: Request): { appKey?: string; accessToken?: string } {
    // 不要重复实现这些逻辑
    const appKey = request.headers['x-app-key'] as string;
    const accessToken = request.headers['x-access-token'] as string;
    return { appKey, accessToken };
  }
}
```

### 10.4 模块化架构原则

#### 10.4.1 接口和类型定义原则

**接口和类型应该定义在使用它们的模块中**：

```typescript
// ✅ 正确：模块内部接口定义
// src/core/symbol-mapper/interfaces/symbol-mapping.interface.ts
export interface ISymbolMapper {
  mapSymbol(originalSymbol: string, fromProvider: string, toProvider: string): Promise<string>;
  saveMapping(rule: ISymbolMappingRule): Promise<void>;
  getSymbolMappingRule(provider: string): Promise<IMappingRule[]>;
}

// src/core/symbol-mapper/symbol-mapper.service.ts
import { ISymbolMapper } from "./interfaces/symbol-mapping.interface";

@Injectable()
export class symbolMapperService implements ISymbolMapper {
  // 实现接口方法...
}

// ❌ 错误：在shared中定义只被单个模块使用的接口
// 不要在 src/common/interfaces/ 中定义只被symbol-mapper使用的接口
```

#### 10.4.2 常量和枚举原则

**只有被多个模块使用的常量才放在shared中**：

```typescript
// ✅ 正确：真正共享的常量在shared中
// src/common/constants/market.constants.ts
export enum Market {
  HK = "HK",
  US = "US", 
  SZ = "SZ",
  SH = "SH"
}

// ✅ 正确：模块特定的常量在模块内部
// src/core/query/enums/data-source-type.enum.ts
export enum DataSourceType {
  CACHE = 'cache',
  PERSISTENT = 'persistent',
  REALTIME = 'realtime'
}

// ❌ 错误：在shared中定义只被单个模块使用的枚举
// 不要将DataSourceType放在shared中，因为它只被query模块使用
```

#### 10.4.3 复用判断标准

**判断代码是否应该放在shared中的标准**：

1. **使用频率**: 被3个或以上模块使用
2. **功能性质**: 基础设施类功能（日志、异常处理、响应格式化等）
3. **业务无关性**: 与具体业务逻辑无关的通用功能
4. **稳定性**: 定义相对稳定，不会频繁变更

```typescript
// ✅ 符合shared标准的组件示例：

// 1. 日志配置 - 被所有模块使用，基础设施，业务无关，稳定
import { createLogger } from '@common/config/logger.config';

// 2. 市场常量 - 被多个模块使用，业务相关但通用，稳定
import { Market, MARKETS } from '@common/constants/market.constants';

// 3. 响应格式 - 被所有控制器使用，基础设施，业务无关，稳定
import { PaginatedResponseDto } from '@common/dto/common-response.dto';

// 4. Swagger装饰器 - 被所有控制器使用，基础设施，业务无关，稳定
import { ApiStandardResponses } from '@common/decorators/swagger-responses.decorator';

// ❌ 不符合shared标准的组件示例：

// 1. 只被单个模块使用的接口
interface ISymbolMapper { ... }  // 应该在symbol-mapper模块中

// 2. 特定业务逻辑的类型
interface TransformRequest { ... }  // 应该在transformer模块中

// 3. 模块特定的枚举
enum QueryType { ... }  // 应该在query模块中
```

### 10.5 架构清理成果总结



#### 10.5.1 核心原则总结

1. **最小必要原则**: shared只包含必需的共享组件
2. **单一职责原则**: 每个组件只负责一个明确的功能
3. **模块内聚原则**: 业务相关代码放在对应业务模块中
4. **依赖明确原则**: 明确区分框架基础设施和业务逻辑

#### 10.5.2 开发者检查清单

在开发新功能时，请按以下检查清单确保正确使用shared组件：

- [ ] **日志记录**: 使用 `createLogger` 和 `sanitizeLogData`
- [ ] **市场处理**: 使用 `Market`、`MARKETS`、`MARKET_NAMES` 等常量
- [ ] **响应格式**: 使用 `PaginatedResponseDto` 等标准DTO
- [ ] **API文档**: 使用shared的Swagger装饰器
- [ ] **HTTP头处理**: 使用 `HttpHeadersUtil` 工具
- [ ] **异常处理**: 确保全局异常过滤器正常工作
- [ ] **响应拦截**: 确保响应拦截器自动格式化

**避免的行为**：
- [ ] 不要在shared中添加只被单个模块使用的代码
- [ ] 不要重复定义已存在的类型或常量
- [ ] 不要绕过shared的基础设施组件
- [ ] 不要在业务模块中重新实现通用功能

### 10.6 DTO复用清单

**每个DTO必须复用以下 common 组件**：

```typescript
// 🎯 DTO复用清单
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsString, IsEnum, IsOptional } from 'class-validator';

// ✅ 必须复用：通用类型
import { Market, ProviderName } from '@common/types/common.types';

// ✅ 必须复用：通用常量
import { DataType } from '@common/constants/data-type.constants';
import { MARKETS } from '@common/constants/markets.constants';
import { PROVIDERS } from '@common/constants/providers.constants';

export class ExampleDto {
  @ApiProperty({ description: '名称' })
  @IsString()
  name: string;

  // ✅ 必须复用：shared 枚举
  @ApiPropertyOptional({
    description: '市场类型',
    enum: MARKETS,
    example: MARKETS.HK
  })
  @IsOptional()
  @IsEnum(MARKETS, { message: '不支持的市场类型' })
  market?: Market;

  // ✅ 必须复用：shared 数据类型
  @ApiPropertyOptional({
    description: '数据类型过滤器',
    enum: DataType,
    example: DataType.STOCK_QUOTE
  })
  @IsOptional()
  @IsEnum(DataType, { message: '不支持的数据类型' })
  queryTypeFilter?: DataType;
}
```

### 10.4 复用验证清单

在开发新功能时，请使用以下清单确保最大化复用 common 模块：

#### 10.4.1 开发前检查

- [ ] 检查 `@common/constants` 是否已有所需常量
- [ ] 检查 `@common/types` 是否已有所需类型定义
- [ ] 检查 `@common/interfaces` 是否已有所需接口
- [ ] 检查 `@common/dto` 是否已有类似的响应格式

#### 10.4.2 编码时检查

- [ ] 所有导入使用 `@common` 路径别名
- [ ] 所有枚举使用 common 模块的常量
- [ ] 所有类型使用 common 模块的类型定义
- [ ] 所有日志使用 common 模块的日志配置
- [ ] 所有响应使用 common 模块的装饰器

#### 10.4.3 完成后检查

- [ ] 没有重复定义 common 模块已有的类型
- [ ] 没有硬编码 common 模块已有的常量
- [ ] 所有异常处理使用标准NestJS异常
- [ ] 所有响应格式符合 common 模块标准

### 10.5 反模式警告

#### 10.5.1 禁止的做法

```typescript
// ❌ 禁止：重复定义类型
type Market = 'HK' | 'US' | 'SZ' | 'SH';

// ❌ 禁止：硬编码常量
const SUPPORTED_MARKETS = ['HK', 'US', 'SZ', 'SH'];

// ❌ 禁止：手动构造响应格式
return {
  statusCode: 200,
  message: '成功',
  data: result,
  timestamp: new Date().toISOString()
};

// ❌ 禁止：不使用日志脱敏
this.logger.log('用户登录', {
  username: user.username,
  password: user.password  // 敏感信息未脱敏
});

// ❌ 禁止：使用相对路径导入
import { DataType } from '../../../common/constants/data-type.constants';
```

#### 10.5.2 必须的做法

```typescript
// ✅ 必须：使用 common 类型
import { Market } from '@common/types/common.types';

// ✅ 必须：使用 common 常量
import { MARKETS } from '@common/constants/markets.constants';

// ✅ 必须：让拦截器处理响应格式
return result; // ResponseInterceptor 自动包装

// ✅ 必须：使用日志脱敏
import { sanitizeLogData } from '@common/config/logger.config';
this.logger.log('用户登录', sanitizeLogData({
  username: user.username,
  password: user.password  // 自动脱敏
}));

// ✅ 必须：使用路径别名
import { DataType } from '@common/constants/data-type.constants';
```

## 11. 测试规范

**🔧 当前测试状态**：
- ✅ 核心系统功能验证通过（手动测试）
- ✅ 开发服务器启动成功，所有API端点可访问
- ⚠️ 部分自动化测试配置可能需要更新（合规整改后）
- 📋 建议：优先编写新功能的测试，逐步完善测试覆盖

### 11.1 单元测试

🎯 **测试也必须复用 common 模块的组件**：

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { ExampleService } from './example.service';
import { ExampleRepository } from './repositories/example.repository';
// 🎯 测试中也要复用 common 模块
import { Market, ProviderName } from '@common/types/common.types';
import { DataType } from '@common/constants/data-type.constants';
import { MARKETS } from '@common/constants/markets.constants';
import { createLogger } from '@common/config/logger.config';
// 🎯 分页服务测试
import { PaginationService } from '@common/modules/pagination/services/pagination.service';
import { PaginatedDataDto } from '@common/modules/pagination/dto/paginated-data';

describe('ExampleService', () => {
  let service: ExampleService;
  let repository: ExampleRepository;
  let paginationService: PaginationService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ExampleService,
        PaginationService, // ⭐ 添加分页服务
        {
          provide: ExampleRepository,
          useValue: {
            create: jest.fn(),
            findById: jest.fn(),
            findByMarketAndType: jest.fn(),
            findPaginated: jest.fn(), // ⭐ 添加分页方法
            // 其他mock方法
          },
        },
      ],
    }).compile();

    service = module.get<ExampleService>(ExampleService);
    repository = module.get<ExampleRepository>(ExampleRepository);
    paginationService = module.get<PaginationService>(PaginationService);
  });

  describe('create', () => {
    it('应该成功创建实体', async () => {
      // Given - 🎯 使用 common 模块的类型
      const createDto = {
        name: 'test',
        market: MARKETS.HK as Market,
        storageClassification: DataType.STOCK_QUOTE
      };
      const mockEntity = {
        id: '1',
        name: 'test',
        market: MARKETS.HK,
        storageClassification: DataType.STOCK_QUOTE
      };
      jest.spyOn(repository, 'create').mockResolvedValue(mockEntity);

      // When
      const result = await service.create(createDto);

      // Then - 🎯 验证 common 模块类型
      expect(result).toEqual(expect.objectContaining({
        id: '1',
        name: 'test',
        market: MARKETS.HK,
        storageClassification: DataType.STOCK_QUOTE
      }));
      expect(repository.create).toHaveBeenCalledWith(createDto);
    });

    it('应该验证不支持的市场类型', async () => {
      // Given - 🎯 使用无效的市场类型测试验证
      const createDto = {
        name: 'test',
        market: 'INVALID_MARKET' as Market
      };

      // When & Then
      await expect(service.create(createDto))
        .rejects
        .toThrow('不支持的市场类型');
    });
  });

  // ⭐ 分页查询测试
  describe('findPaginated', () => {
    it('应该返回正确的分页响应', async () => {
      // Mock repository返回 { items, total }
      jest.spyOn(repository, 'findPaginated').mockResolvedValue({ items: mockData, total: 25 });
      
      const result = await service.findPaginated({ page: 1, limit: 10 });
      
      // 验证返回PaginatedDataDto格式
      expect(result).toBeInstanceOf(PaginatedDataDto);
      expect(result.pagination.totalPages).toBe(3);
    });
  });

  describe('findByMarketAndType', () => {
    it('应该按市场和数据类型查询', async () => {
      // Given - 🎯 使用 common 模块的枚举
      const market = MARKETS.US;
      const storageClassification = DataType.STOCK_QUOTE;
      const mockResults = [
        { id: '1', market, storageClassification, name: 'test1' },
        { id: '2', market, storageClassification, name: 'test2' }
      ];

      jest.spyOn(repository, 'findByMarketAndClassification').mockResolvedValue(mockResults);

      // When
      const result = await service.findByMarketAndClassification(market, storageClassification);

      // Then
      expect(result).toHaveLength(2);
      expect(repository.findByMarketAndClassification).toHaveBeenCalledWith(market, storageClassification);
    });
  });
});
```

### 11.2 集成测试

🎯 **集成测试中复用 common 模块进行端到端验证**：

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../app.module';
// 🎯 集成测试也要复用 common 模块
import { ApiResponseDto, PaginatedResponseDto } from '@common/dto/common-response.dto';
import { DataType } from '@common/constants/data-type.constants';
import { MARKETS } from '@common/constants/markets.constants';

describe('ExampleController (e2e)', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();

    // 🎯 应用全局拦截器和过滤器（与生产环境一致）
    app.useGlobalInterceptors(new ResponseInterceptor());
    app.useGlobalFilters(new GlobalExceptionFilter());

    await app.init();

    // 获取测试用的认证token
    authToken = await getTestAuthToken(app);
  });

  afterAll(async () => {
    await app.close();
  });

  describe('GET /examples', () => {
    it('应该返回标准分页响应格式', async () => {
      const response = await request(app.getHttpServer())
        .get('/api/v1/examples')
        .set('Authorization', `Bearer ${authToken}`)
        .query({
          page: 1,
          limit: 10,
          market: MARKETS.HK,  // 🎯 使用 common 常量
          queryTypeFilter: DataType.STOCK_QUOTE  // 🎯 使用 common 枚举
        })
        .expect(200);

      // 🎯 验证响应符合 PaginatedDataDto 标准格式
      expect(response.body).toMatchObject({
        statusCode: 200,
        message: expect.any(String),
        data: {
          items: expect.any(Array),        // ⭐ 使用items字段
          pagination: {
            page: 1,
            limit: 10,
            total: expect.any(Number),
            totalPages: expect.any(Number),
            hasNext: expect.any(Boolean),
            hasPrev: expect.any(Boolean)
          }
        },
        timestamp: expect.any(String)
      });

      // 🎯 验证数据项包含 common 模块的字段
      if (response.body.data.items.length > 0) {
        const firstItem = response.body.data.items[0];
        expect(firstItem).toMatchObject({
          id: expect.any(String),
          name: expect.any(String),
          market: expect.stringMatching(new RegExp(Object.values(MARKETS).join('|'))),
          storageClassification: expect.stringMatching(new RegExp(Object.values(DataType).join('|')))
        });
      }
    });

    it('应该正确处理无效的市场类型', async () => {
      const response = await request(app.getHttpServer())
        .get('/api/v1/examples')
        .set('Authorization', `Bearer ${authToken}`)
        .query({
          market: 'INVALID_MARKET'  // 无效市场
        })
        .expect(400);

      // 🎯 验证错误响应符合 common 模块的标准格式
      expect(response.body).toMatchObject({
        statusCode: 400,
        message: expect.stringContaining('不支持的市场类型'),
        error: 'Bad Request',
        timestamp: expect.any(String),
        path: '/api/v1/examples'
      });
    });
  });

  describe('POST /examples', () => {
    it('应该创建新实体并返回标准响应格式', async () => {
      const createDto = {
        name: 'Test Example',
        market: MARKETS.US,  // 🎯 使用 common 常量
        storageClassification: DataType.STOCK_BASIC_INFO  // 🎯 使用 common 枚举
      };

      const response = await request(app.getHttpServer())
        .post('/api/v1/examples')
        .set('Authorization', `Bearer ${authToken}`)
        .send(createDto)
        .expect(201);

      // 🎯 验证创建响应符合标准格式
      expect(response.body).toMatchObject({
        statusCode: 201,
        message: expect.any(String),
        data: {
          id: expect.any(String),
          name: createDto.name,
          market: createDto.market,
          storageClassification: createDto.storageClassification,
          createdAt: expect.any(String),
          updatedAt: expect.any(String)
        },
        timestamp: expect.any(String)
      });
    });
  });
});

// 🎯 测试工具函数也要复用 common 模块
async function getTestAuthToken(app: INestApplication): Promise<string> {
  const loginResponse = await request(app.getHttpServer())
    .post('/auth/login')
    .send({
      username: 'test@example.com',
      password: 'testpassword'
    })
    .expect(200);

  // 验证登录响应格式
  expect(loginResponse.body).toMatchObject({
    statusCode: 200,
    message: expect.any(String),
    data: {
      accessToken: expect.any(String),
      user: expect.any(Object)
    },
    timestamp: expect.any(String)
  });

  return loginResponse.body.data.accessToken;
}
```

### 11.3 测试中的 Shared 模块复用最佳实践

#### 11.3.1 Mock 数据使用 Shared 常量

```typescript
// ✅ 正确：使用 common 常量创建测试数据
import { MARKETS } from '@common/constants/markets.constants';
import { DataType } from '@common/constants/data-type.constants';

const mockData = {
  market: MARKETS.HK,
  storageClassification: DataType.STOCK_QUOTE,
  symbols: ['700.HK', '0005.HK']
};

// ❌ 错误：硬编码测试数据
const mockData = {
  market: 'HK',
  receiverType: 'get-stock-quote', // 统一使用get-前缀格式
  symbols: ['700.HK', '0005.HK']
};
```

#### 11.3.2 响应格式验证

```typescript
// ✅ 正确：验证响应符合 common 模块标准
expect(response.body).toMatchObject({
  statusCode: expect.any(Number),
  message: expect.any(String),
  data: expect.anything(),
  timestamp: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/)
});

// ❌ 错误：不验证标准响应格式
expect(response.body.data).toBeDefined();
```

#### 11.3.3 异常测试

```typescript
// ✅ 正确：测试异常处理使用 common 模块验证
it('应该正确处理业务异常', async () => {
  const invalidData = { market: 'INVALID' };

  await expect(service.processData(invalidData))
    .rejects
    .toThrow('不支持的市场类型');
});

// 集成测试中验证异常响应格式
const response = await request(app.getHttpServer())
  .post('/api/v1/data')
  .send(invalidData)
  .expect(400);

expect(response.body).toMatchObject({
  statusCode: 400,
  message: expect.stringContaining('不支持的市场类型'),
  error: 'Bad Request',
  timestamp: expect.any(String),
  path: expect.any(String)
});
```


## 13. API版本控制

### 13.1 版本策略

- URL路径版本控制：`/api/v1/`, `/api/v2/`
- 主要版本更新时创建新的控制器版本
- 向后兼容性原则：新版本不破坏现有API

### 11.2 版本实现

```typescript
@Controller('api/v1/examples')  // v1版本
export class ExamplesV1Controller {
  // v1实现
}

@Controller('api/v2/examples')  // v2版本
export class ExamplesV2Controller {
  // v2实现，增强功能但保持向后兼容
}
```

## 14. 安全规范

### 14.1 输入验证

- 所有输入必须通过DTO验证
- 使用`class-validator`进行数据验证
- 敏感操作需要额外的业务规则验证

### 12.2 敏感信息处理

```typescript
// Schema中排除敏感字段
Schema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.password;
  delete obj.secretKey;
  return obj;
};

// 日志中避免记录敏感信息
this.logger.log('用户登录', {
  userId: user.id,
  // 不记录密码等敏感信息
});
```

### 12.3 安全审计

- 使用`SecurityAuditService`记录安全事件
- 敏感操作自动记录审计日志
- 异常访问模式检测和告警

### 12.4 HTTP Headers 工具类

系统提供了统一的HTTP Headers处理工具类 `HttpHeadersUtil`，位于 `@common/utils/http-headers.util.ts`，用于标准化和安全地处理HTTP请求头。

#### 12.4.1 工具类功能

```typescript
import { HttpHeadersUtil } from '@common/utils/http-headers.util';

// 1. 安全获取header值
const apiKey = HttpHeadersUtil.getHeader(req, 'X-API-Key');
const userAgent = HttpHeadersUtil.getUserAgent(req);

// 2. 验证API凭证格式
const { appKey, appSecret } = HttpHeadersUtil.validateApiCredentials(req);

// 3. 获取客户端IP
const clientIp = HttpHeadersUtil.getClientIP(req);

// 4. 获取JWT Token
const token = HttpHeadersUtil.getBearerToken(req);

// 5. 安全记录headers（过滤敏感信息）
const safeHeaders = HttpHeadersUtil.getSafeHeaders(req);
this.logger.log('请求信息', { headers: safeHeaders });
```

#### 12.4.2 API凭证验证规范

**严格的格式验证**：
```typescript
// ✅ 正确的API凭证格式
X-API-Key: your_api_key_here
X-API-Secret: your_api_secret_here

// ❌ 不允许的格式（包含空白字符）
X-API-Key: " your_api_key_here "    // 包含空格
X-API-Secret: "your_api_secret\n"   // 包含换行符
X-API-Key: "your\tapi\tkey"         // 包含制表符
```

**验证规则**：
- 拒绝任何包含空白字符的API凭证（空格、制表符、换行符等）
- 提供明确的错误信息区分不同错误类型
- 兼容大小写差异和数组形式的header值

#### 12.4.3 使用示例

**在认证策略中使用**：
```typescript
@Injectable()
export class ApiKeyStrategy extends PassportStrategy(Strategy, 'api-key') {
  async validate(req: Request): Promise<ApiKeyPayload> {
    try {
      // 使用统一工具验证API凭证
      const { appKey, appSecret } = HttpHeadersUtil.validateApiCredentials(req);
      
      // 验证API Key
      const apiKey = await this.authService.validateApiKey(appKey, appSecret);
      if (!apiKey) {
        throw new UnauthorizedException('API凭证无效');
      }
      
      return { apiKey, clientIp: HttpHeadersUtil.getClientIP(req) };
    } catch (error) {
      this.logger.error('API Key验证失败', {
        error: error.message,
        clientIp: HttpHeadersUtil.getClientIP(req),
        userAgent: HttpHeadersUtil.getUserAgent(req)
      });
      throw error;
    }
  }
}
```

**在中间件中使用**：
```typescript
@Injectable()
export class SecurityMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // 获取客户端信息
    const clientIp = HttpHeadersUtil.getClientIP(req);
    const userAgent = HttpHeadersUtil.getUserAgent(req);
    
    // 检测API Key请求
    const apiCredentials = HttpHeadersUtil.getApiCredentials(req);
    if (apiCredentials) {
      // 记录API访问日志
      this.logger.log('API访问请求', {
        clientIp,
        userAgent,
        hasApiKey: true,
        path: req.path,
        method: req.method
      });
    }
    
    next();
  }
}
```

**在异常过滤器中使用**：
```typescript
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const request = ctx.getRequest<Request>();
    
    // 使用工具类获取请求信息
    const errorContext = {
      path: request.url,
      method: request.method,
      clientIp: HttpHeadersUtil.getClientIP(request),
      userAgent: HttpHeadersUtil.getUserAgent(request),
      headers: HttpHeadersUtil.getSafeHeaders(request) // 过滤敏感信息
    };
    
    this.logger.error('请求异常', { exception, context: errorContext });
  }
}
```

#### 12.4.4 最佳实践

1. **统一使用工具类**：
   - 所有HTTP headers处理都应使用 `HttpHeadersUtil`
   - 避免直接访问 `req.headers` 对象
   - 消除项目中的重复代码

2. **安全第一**：
   - 使用 `getSafeHeaders()` 记录日志，自动过滤敏感信息
   - 严格验证API凭证格式，拒绝包含空白字符的凭证
   - 提供明确的错误信息帮助调试

3. **兼容性处理**：
   - 自动处理header名称的大小写差异
   - 支持数组形式的header值
   - 优雅处理缺失的header

4. **性能优化**：
   - 使用缓存机制避免重复解析
   - 提供轻量级的getter方法
   - 支持批量获取多个header值

#### 12.4.5 错误处理

工具类会抛出以下异常类型：

```typescript
// API凭证缺失
throw new UnauthorizedException('缺少API凭证');

// API凭证格式错误
throw new BadRequestException('API凭证格式无效，不能包含空白字符');

// 其他格式错误
throw new BadRequestException('无效的认证头格式');
```

#### 12.4.6 项目集成检查

在项目中使用此工具类时，需要检查以下文件是否已更新：

- ✅ `auth/strategies/apikey.strategy.ts` - API Key认证策略
- ✅ `security/middleware/security.middleware.ts` - 安全中间件
- ✅ `auth/filters/rate-limit.filter.ts` - 限流异常过滤器
- ✅ `common/filters/global-exception.filter.ts` - 全局异常过滤器
- ✅ `auth/guards/rate-limit.guard.ts` - 限流守卫

确保所有相关文件都已更新为使用统一的 `HttpHeadersUtil` 工具类，避免代码重复和不一致的处理逻辑。

## 15. CI/CD和部署规范

### 15.1 代码质量检查

```bash
# 开发时运行
bun run lint          # ESLint检查和自动修复
bun run format        # Prettier格式化
bun run typecheck     # TypeScript类型检查

# CI/CD管道
bun test              # 单元测试
bun run test:integration  # 集成测试
bun run test:e2e      # 端到端测试
bun run security:deps # 依赖安全扫描
```

### 13.2 构建和部署

```bash
# 构建
bun run build         # TypeScript编译

# 生产环境启动
bun run start:prod    # 生产模式

# 健康检查
curl http://localhost:3000/health
```

## 16. 开发工具和配置

### 16.1 IDE配置

推荐VSCode扩展：
- TypeScript Importer
- ESLint
- Prettier
- REST Client
- MongoDB for VS Code

### 14.2 环境变量管理

**必需的环境变量**（详细配置见 [CLAUDE.md](../CLAUDE.md#environment-setup)）：

```typescript
// 类型安全的环境变量
interface EnvironmentVariables {
  // 基础配置
  NODE_ENV: 'development' | 'production' | 'test';
  PORT: number;
  
  // 数据库配置
  MONGODB_URI: string;
  REDIS_HOST: string;
  REDIS_PORT: number;
  REDIS_PASSWORD?: string;
  
  // 认证配置
  JWT_SECRET: string;
  JWT_EXPIRES_IN: string;
  
  // LongPort SDK配置 (生产数据源)
  LONGPORT_APP_KEY: string;      // 必需：LongPort应用密钥
  LONGPORT_APP_SECRET: string;   // 必需：LongPort应用密钥
  LONGPORT_ACCESS_TOKEN: string; // 必需：LongPort访问令牌
  
  // 其他数据源配置 (预留)
  ITICK_API_KEY?: string;
  FUTU_APP_ID?: string;
  TWELVEDATA_API_KEY?: string;
}
```

**环境变量设置示例**：
```bash
# 开发环境 (.env.development)
NODE_ENV=development
PORT=3000
MONGODB_URI=mongodb://localhost:27017/smart-stock-data
REDIS_HOST=localhost
REDIS_PORT=6379
JWT_SECRET=your_32_char_jwt_secret_key_here
JWT_EXPIRES_IN=24h

# LongPort SDK (必需)
LONGPORT_APP_KEY=your_longport_app_key
LONGPORT_APP_SECRET=your_longport_app_secret
LONGPORT_ACCESS_TOKEN=your_longport_access_token
```

## 17. 最佳实践总结

### 17.1 代码质量

1. **类型安全**：充分利用TypeScript的类型系统
2. **错误处理**：使用标准异常类型，提供有意义的错误信息
3. **日志记录**：结构化日志，包含上下文信息
4. **性能优化**：使用缓存、数据库索引、查询优化
5. **安全第一**：输入验证、认证授权、敏感信息保护

### 15.2 团队协作

1. **代码审查**：所有代码变更必须经过审查
2. **文档维护**：API文档、架构文档保持最新
3. **测试覆盖**：关键业务逻辑必须有测试覆盖
4. **持续集成**：自动化测试、构建、部署

### 15.3 系统监控

1. **性能监控**：响应时间、错误率、资源使用
2. **业务监控**：API调用量、用户活动、数据质量
3. **安全监控**：异常访问、安全事件、漏洞扫描
4. **告警机制**：及时发现和响应系统问题

## 结语

本开发规范基于NestJS最佳实践和项目实际需求制定，旨在确保代码质量、开发效率和系统稳定性。所有团队成员都应严格遵守这些规范，并在实践中不断完善和优化。

### 📚 相关文档

- **[CLAUDE.md](../CLAUDE.md)** - 系统架构概览和快速上手指南
- **[系统架构概览](./system-architecture-overview.md)** - 完整的技术架构文档  
- **[安全配置参考](./security-configuration-reference.md)** - 生产环境安全配置



---

*本文档与 [CLAUDE.md](../CLAUDE.md) 配套使用，共同构成完整的项目开发指南体系。*