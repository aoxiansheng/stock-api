# å¢å¼ºæä¾›å•†æ³¨å†Œç³»ç»Ÿæ¶æ„æ–‡æ¡£

## æ¦‚è¿°

å¢å¼ºæä¾›å•†æ³¨å†Œç³»ç»Ÿæ˜¯å¯¹åŸæœ‰æ–‡ä»¶å‘ç°æœºåˆ¶çš„é‡å¤§å‡çº§ï¼Œå¼•å…¥äº†è£…é¥°å™¨é©±åŠ¨çš„ç°ä»£åŒ–æ¶æ„ï¼ŒåŒæ—¶ä¿æŒå®Œå…¨çš„å‘åå…¼å®¹æ€§ã€‚è¯¥ç³»ç»Ÿé€šè¿‡å¤šå±‚ç­–ç•¥ã€æ™ºèƒ½é”™è¯¯å¤„ç†å’Œè‡ªåŠ¨åŒ–å·¥å…·ï¼Œå¤§å¹…æå‡äº†æ•°æ®æºæ¥å…¥çš„å¼€å‘ä½“éªŒå’Œç³»ç»Ÿç¨³å®šæ€§ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

### æ ¸å¿ƒç»„ä»¶

```
å¢å¼ºæä¾›å•†æ³¨å†Œç³»ç»Ÿ
â”œâ”€â”€ è£…é¥°å™¨ç³»ç»Ÿ (Decorator System)
â”‚   â”œâ”€â”€ @Provider è£…é¥°å™¨
â”‚   â”œâ”€â”€ @Capability è£…é¥°å™¨  
â”‚   â”œâ”€â”€ @StreamCapability è£…é¥°å™¨
â”‚   â””â”€â”€ CapabilityCollector (å…ƒæ•°æ®æ”¶é›†å™¨)
â”œâ”€â”€ æ™ºèƒ½è·¯å¾„è§£æ (Smart Path Resolution)
â”‚   â”œâ”€â”€ SmartPathResolver (å¤šç­–ç•¥è·¯å¾„è§£æ)
â”‚   â””â”€â”€ é¡¹ç›®æ ¹ç›®å½•è‡ªåŠ¨æ£€æµ‹
â”œâ”€â”€ çº¦å®šæ‰«æå™¨ (Convention Scanner)
â”‚   â”œâ”€â”€ ConventionScanner (æ–‡ä»¶ç³»ç»Ÿæ‰«æ)
â”‚   â””â”€â”€ çº¦å®šéªŒè¯å’Œè¿è§„æ£€æµ‹
â”œâ”€â”€ æ™ºèƒ½é”™è¯¯å¤„ç† (Smart Error Handling)
â”‚   â”œâ”€â”€ SmartErrorHandler (é”™è¯¯åˆ†æå’Œè‡ªåŠ¨ä¿®å¤)
â”‚   â””â”€â”€ æ¨¡æ¿ç”Ÿæˆå’Œé—®é¢˜ä¿®å¤
â”œâ”€â”€ CLI å·¥å…·é“¾ (CLI Toolchain)
â”‚   â”œâ”€â”€ ProviderGeneratorCLI (ä»£ç ç”Ÿæˆ)
â”‚   â””â”€â”€ éªŒè¯ã€ä¿®å¤ã€æ‰«æå‘½ä»¤
â””â”€â”€ å¢å¼ºæ³¨å†Œè¡¨ (Enhanced Registry)
    â”œâ”€â”€ EnhancedCapabilityRegistryService (æ ¸å¿ƒæ³¨å†ŒæœåŠ¡)
    â””â”€â”€ å¤šç­–ç•¥æ··åˆæ³¨å†Œæœºåˆ¶
```

### æ•°æ®æµæ¶æ„

```
å¼€å‘æ—¶ (Development Time)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CLI å·¥å…·       â”‚ => â”‚   è£…é¥°å™¨ç³»ç»Ÿ      â”‚ => â”‚   ä»£ç ç”Ÿæˆ       â”‚
â”‚ - ç”Ÿæˆå‘½ä»¤       â”‚    â”‚ - @Provider      â”‚    â”‚ - æ¨¡æ¿æ–‡ä»¶       â”‚
â”‚ - éªŒè¯å‘½ä»¤       â”‚    â”‚ - @Capability    â”‚    â”‚ - ç»“æ„åˆ›å»º       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¿è¡Œæ—¶ (Runtime)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è£…é¥°å™¨æ”¶é›†     â”‚ => â”‚   æ–‡ä»¶ç³»ç»Ÿæ‰«æ    â”‚ => â”‚   æ™ºèƒ½åˆå¹¶       â”‚
â”‚ - å…ƒæ•°æ®æå–     â”‚    â”‚ - ä¼ ç»Ÿèƒ½åŠ›å‘ç°    â”‚    â”‚ - å†²çªè§£å†³       â”‚
â”‚ - ç±»å‹éªŒè¯       â”‚    â”‚ - çº¦å®šæ£€æŸ¥       â”‚    â”‚ - ç»Ÿä¸€æ³¨å†Œ       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                        â”‚
                                                        v
                                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                â”‚     å¢å¼ºæ³¨å†Œè¡¨                   â”‚
                                â”‚ - ç»Ÿè®¡ä¿¡æ¯ç”Ÿæˆ                   â”‚
                                â”‚ - è°ƒè¯•ä¿¡æ¯æ”¶é›†                   â”‚
                                â”‚ - å‘åå…¼å®¹æ”¯æŒ                   â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¯ è£…é¥°å™¨ç³»ç»Ÿè¯¦è§£

### è®¾è®¡ç†å¿µ

è£…é¥°å™¨ç³»ç»Ÿé‡‡ç”¨**å£°æ˜å¼ç¼–ç¨‹**èŒƒå¼ï¼Œé€šè¿‡å…ƒæ•°æ®æ³¨è§£çš„æ–¹å¼å®ç°èƒ½åŠ›å’Œæä¾›å•†çš„è‡ªåŠ¨æ³¨å†Œï¼Œç›¸æ¯”ä¼ ç»Ÿçš„å‘½ä»¤å¼é…ç½®æ–¹å¼å…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

- **ç¼–è¯‘æ—¶éªŒè¯**: TypeScriptè£…é¥°å™¨åœ¨ç¼–è¯‘æ—¶è¿›è¡Œç±»å‹æ£€æŸ¥
- **ä»£ç å³æ–‡æ¡£**: è£…é¥°å™¨å‚æ•°ç›´æ¥ä½“ç°é…ç½®ä¿¡æ¯
- **è‡ªåŠ¨æ¨æ–­**: æ ¹æ®æ–‡ä»¶è·¯å¾„å’Œç±»åæ™ºèƒ½æ¨æ–­é…ç½®
- **IDEæ”¯æŒ**: å®Œæ•´çš„æ™ºèƒ½æç¤ºå’Œé‡æ„æ”¯æŒ

### æ ¸å¿ƒè£…é¥°å™¨å®ç°

#### @Provider è£…é¥°å™¨

```typescript
// src/providers/decorators/provider.decorator.ts
export function Provider(metadata: ProviderMetadata) {
  return function <T extends Constructor>(target: T) {
    // 1. éªŒè¯å…ƒæ•°æ®å®Œæ•´æ€§
    validateProviderMetadata(metadata);
    
    // 2. è‡ªåŠ¨æ¨æ–­ç¼ºå¤±ä¿¡æ¯
    const enrichedMetadata = enrichProviderMetadata(metadata, target);
    
    // 3. æ³¨å†Œåˆ°å…¨å±€æ”¶é›†å™¨
    CapabilityCollector.registerProvider(target.name, {
      class: target,
      metadata: enrichedMetadata,
      filePath: getCallerFilePath(),
      registeredAt: new Date()
    });
    
    // 4. è®¾ç½®åå°„å…ƒæ•°æ®
    Reflect.defineMetadata(PROVIDER_METADATA_KEY, enrichedMetadata, target);
    
    return target;
  };
}
```

**å…³é”®ç‰¹æ€§**:
- **è‡ªåŠ¨æ¨æ–­**: ä»æ–‡ä»¶è·¯å¾„æ¨æ–­æä¾›å•†åç§°
- **éªŒè¯æœºåˆ¶**: ç¡®ä¿å…ƒæ•°æ®çš„å®Œæ•´æ€§å’Œæ­£ç¡®æ€§
- **åå°„æ”¯æŒ**: æ”¯æŒè¿è¡Œæ—¶å…ƒæ•°æ®è®¿é—®
- **å…¨å±€æ³¨å†Œ**: è‡ªåŠ¨æ·»åŠ åˆ°å…¨å±€èƒ½åŠ›æ”¶é›†å™¨

#### @Capability è£…é¥°å™¨

```typescript
// src/providers/decorators/capability.decorator.ts
export function Capability(metadata: CapabilityMetadata) {
  return function <T extends Constructor>(target: T) {
    // 1. æ™ºèƒ½æ¨æ–­æä¾›å•†åç§°
    const providerName = metadata.provider || inferProviderFromPath();
    
    // 2. éªŒè¯èƒ½åŠ›æ¥å£å®ç°
    validateCapabilityImplementation(target);
    
    // 3. ç”Ÿæˆå”¯ä¸€æ ‡è¯†ç¬¦
    const uniqueKey = generateCapabilityKey(providerName, metadata.name);
    
    // 4. æ³¨å†Œèƒ½åŠ›
    CapabilityCollector.registerCapability(uniqueKey, {
      class: target,
      metadata: { ...metadata, provider: providerName },
      provider: providerName,
      filePath: getCallerFilePath(),
      registeredAt: new Date()
    });
    
    return target;
  };
}
```

**æ™ºèƒ½æ¨æ–­ç®—æ³•**:
```typescript
function inferProviderFromPath(): string {
  const filePath = getCallerFilePath();
  // åŒ¹é…è·¯å¾„æ¨¡å¼: /providers/{provider-name}/capabilities/
  const match = filePath.match(/\/providers\/([^\/]+)\/capabilities\//);
  return match?.[1] || 'unknown';
}
```

### å…ƒæ•°æ®æ”¶é›†å™¨ (CapabilityCollector)

```typescript
// src/providers/decorators/capability-collector.ts
export class CapabilityCollector {
  private static capabilities = new Map<string, CapabilityCollectionItem>();
  private static providers = new Map<string, ProviderCollectionItem>();
  
  // èƒ½åŠ›æ³¨å†Œ
  static registerCapability(key: string, item: CapabilityCollectionItem): void {
    this.capabilities.set(key, item);
    this.updateProviderCapabilities(item.provider, item.metadata.name);
  }
  
  // æä¾›å•†æ³¨å†Œ  
  static registerProvider(name: string, item: ProviderCollectionItem): void {
    this.providers.set(name, item);
  }
  
  // æ•°æ®éªŒè¯
  static validate(): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    
    // éªŒè¯èƒ½åŠ›å®Œæ•´æ€§
    for (const [key, item] of this.capabilities) {
      if (!this.validateCapabilityItem(item)) {
        errors.push(`èƒ½åŠ› ${key} éªŒè¯å¤±è´¥`);
      }
    }
    
    // éªŒè¯æä¾›å•†ä¸€è‡´æ€§
    for (const [name, item] of this.providers) {
      if (!this.validateProviderItem(item)) {
        warnings.push(`æä¾›å•† ${name} å¯èƒ½å­˜åœ¨é—®é¢˜`);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
}
```

## ğŸ” æ™ºèƒ½è·¯å¾„è§£æç³»ç»Ÿ

### å¤šç­–ç•¥è·¯å¾„è§£æ

æ™ºèƒ½è·¯å¾„è§£æå™¨é‡‡ç”¨**å¤šé‡å›é€€ç­–ç•¥**ï¼Œç¡®ä¿åœ¨å„ç§ç¯å¢ƒå’Œéƒ¨ç½²åœºæ™¯ä¸‹éƒ½èƒ½æ­£ç¡®å®šä½é¡¹ç›®æ–‡ä»¶ï¼š

```typescript
// src/providers/utils/smart-path-resolver.ts
export class SmartPathResolver {
  private static strategies: PathResolutionStrategy[] = [
    new RuntimePathStrategy(),      // è¿è¡Œæ—¶è·¯å¾„æ¨æ–­
    new PackageJsonStrategy(),      // package.json å®šä½
    new SrcDirectoryStrategy(),     // src ç›®å½•æœç´¢  
    new GitRootStrategy(),          // Git æ ¹ç›®å½•
    new ProcessCwdStrategy()        // è¿›ç¨‹å·¥ä½œç›®å½•
  ];
  
  static getProjectRoot(): string {
    for (const strategy of this.strategies) {
      try {
        const root = strategy.resolve();
        if (this.validateProjectRoot(root)) {
          return root;
        }
      } catch (error) {
        // å°è¯•ä¸‹ä¸€ä¸ªç­–ç•¥
        continue;
      }
    }
    throw new Error('æ— æ³•ç¡®å®šé¡¹ç›®æ ¹ç›®å½•');
  }
  
  private static validateProjectRoot(path: string): boolean {
    // éªŒè¯æ ‡è¯†æ–‡ä»¶å­˜åœ¨
    const indicators = ['package.json', 'src/', 'tsconfig.json'];
    return indicators.some(indicator => 
      existsSync(join(path, indicator))
    );
  }
}
```

### è·¯å¾„æ¨æ–­ç­–ç•¥

#### 1. è¿è¡Œæ—¶è·¯å¾„ç­–ç•¥
```typescript
class RuntimePathStrategy implements PathResolutionStrategy {
  resolve(): string {
    // ä»è°ƒç”¨æ ˆæ¨æ–­è·¯å¾„
    const stack = new Error().stack;
    const projectPath = this.extractProjectPathFromStack(stack);
    return projectPath;
  }
  
  private extractProjectPathFromStack(stack: string): string {
    const lines = stack.split('\n');
    for (const line of lines) {
      const match = line.match(/\((.+)\/src\/providers\//);
      if (match) {
        return match[1];
      }
    }
    throw new Error('æ— æ³•ä»è°ƒç”¨æ ˆæ¨æ–­é¡¹ç›®è·¯å¾„');
  }
}
```

#### 2. Package.json ç­–ç•¥
```typescript
class PackageJsonStrategy implements PathResolutionStrategy {
  resolve(): string {
    let currentDir = process.cwd();
    
    while (currentDir !== '/') {
      const packageJsonPath = join(currentDir, 'package.json');
      if (existsSync(packageJsonPath)) {
        const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
        // éªŒè¯æ˜¯å¦ä¸ºç›®æ ‡é¡¹ç›®
        if (this.isTargetProject(packageJson)) {
          return currentDir;
        }
      }
      currentDir = dirname(currentDir);
    }
    
    throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„ package.json');
  }
  
  private isTargetProject(packageJson: any): boolean {
    return packageJson.name?.includes('stock') || 
           packageJson.scripts?.dev?.includes('nest');
  }
}
```

## ğŸ”§ çº¦å®šæ‰«æå’ŒéªŒè¯ç³»ç»Ÿ

### çº¦å®šé©±åŠ¨çš„æ¶æ„

ç³»ç»Ÿé‡‡ç”¨**çº¦å®šä¼˜äºé…ç½® (Convention over Configuration)** çš„è®¾è®¡åŸåˆ™ï¼Œé€šè¿‡é¢„å®šä¹‰çš„ç›®å½•ç»“æ„å’Œå‘½åè§„èŒƒç®€åŒ–é…ç½®å·¥ä½œï¼š

```typescript
// æ ‡å‡†çº¦å®š
interface ProviderConventions {
  directoryNaming: 'kebab-case';           // longport, alpha-vantage
  fileNaming: 'kebab-case.extension';     // get-stock-quote.ts
  classNaming: 'PascalCase + Suffix';     // GetStockQuoteCapability
  exportPattern: 'default | named';       // export default Class
}
```

### ConventionScanner å®ç°

```typescript
// src/providers/utils/convention-scanner.ts
export class ConventionScanner {
  async scanProviders(options: ScanOptions = {}): Promise<ScanResult> {
    const providersPath = SmartPathResolver.getProvidersPath();
    const providers: ProviderInfo[] = [];
    const violations: ConventionViolation[] = [];
    
    const directories = await this.getProviderDirectories(providersPath);
    
    for (const dirName of directories) {
      try {
        const providerInfo = await this.scanProvider(dirName);
        providers.push(providerInfo);
        
        if (options.validateConventions) {
          const providerViolations = await this.validateProvider(dirName);
          violations.push(...providerViolations);
        }
      } catch (error) {
        violations.push({
          type: 'scan_error',
          path: join(providersPath, dirName),
          message: `æ‰«ææä¾›å•†å¤±è´¥: ${error.message}`,
          severity: 'high',
          autoFixable: false
        });
      }
    }
    
    return {
      providers,
      violations,
      stats: this.generateScanStats(providers, violations)
    };
  }
  
  private async validateProvider(providerName: string): Promise<ConventionViolation[]> {
    const violations: ConventionViolation[] = [];
    const providerPath = SmartPathResolver.getProviderPath(providerName);
    
    // éªŒè¯ç›®å½•ç»“æ„
    violations.push(...await this.validateDirectoryStructure(providerPath));
    
    // éªŒè¯æ–‡ä»¶å‘½å
    violations.push(...await this.validateFileNaming(providerPath));
    
    // éªŒè¯å¯¼å‡ºæ¨¡å¼
    violations.push(...await this.validateExportPatterns(providerPath));
    
    // éªŒè¯æ¥å£å®ç°
    violations.push(...await this.validateInterfaceImplementation(providerPath));
    
    return violations;
  }
}
```

### çº¦å®šè¿è§„æ£€æµ‹

#### 1. ç›®å½•ç»“æ„éªŒè¯
```typescript
private async validateDirectoryStructure(providerPath: string): Promise<ConventionViolation[]> {
  const violations: ConventionViolation[] = [];
  const requiredDirs = ['capabilities', 'module'];
  const recommendedDirs = ['services', 'tests'];
  
  for (const dir of requiredDirs) {
    const dirPath = join(providerPath, dir);
    if (!existsSync(dirPath)) {
      violations.push({
        type: 'missing_directory',
        path: dirPath,
        message: `ç¼ºå°‘å¿…éœ€ç›®å½•: ${dir}`,
        severity: 'high',
        autoFixable: true,
        suggestion: `åˆ›å»ºç›®å½•: mkdir -p ${dirPath}`
      });
    }
  }
  
  return violations;
}
```

#### 2. å‘½åçº¦å®šéªŒè¯
```typescript
private async validateFileNaming(providerPath: string): Promise<ConventionViolation[]> {
  const violations: ConventionViolation[] = [];
  const capabilitiesPath = join(providerPath, 'capabilities');
  
  if (existsSync(capabilitiesPath)) {
    const files = await readdir(capabilitiesPath);
    
    for (const file of files) {
      if (file.endsWith('.ts') && !this.isValidKebabCase(file.replace('.ts', ''))) {
        violations.push({
          type: 'naming_convention',
          path: join(capabilitiesPath, file),
          message: `æ–‡ä»¶åä¸ç¬¦åˆ kebab-case çº¦å®š: ${file}`,
          severity: 'medium',
          autoFixable: false,
          suggestion: `é‡å‘½åä¸º: ${this.toKebabCase(file)}`
        });
      }
    }
  }
  
  return violations;
}
```

## ğŸ”¨ æ™ºèƒ½é”™è¯¯å¤„ç†å’Œè‡ªåŠ¨ä¿®å¤

### é”™è¯¯åˆ†æå¼•æ“

æ™ºèƒ½é”™è¯¯å¤„ç†å™¨é‡‡ç”¨**æ¨¡å¼åŒ¹é…**å’Œ**å¯å‘å¼åˆ†æ**ç›¸ç»“åˆçš„æ–¹å¼ï¼Œè‡ªåŠ¨è¯†åˆ«å¸¸è§é—®é¢˜å¹¶æä¾›ä¿®å¤æ–¹æ¡ˆï¼š

```typescript
// src/providers/utils/smart-error-handler.ts
export class SmartErrorHandler {
  private static errorPatterns: ErrorPattern[] = [
    {
      pattern: /cannot find module.*\/capabilities\/(.+)/,
      type: 'missing_capability_file',
      severity: 'high',
      autoFixable: true,
      analyzer: (error, match) => ({
        capabilityName: match[1],
        suggestedAction: 'generate_capability_template'
      })
    },
    {
      pattern: /does not implement.*ICapability/,
      type: 'interface_implementation',
      severity: 'high',
      autoFixable: false,
      analyzer: (error) => ({
        suggestedAction: 'implement_interface_methods'
      })
    }
  ];
  
  static analyzeProviderError(providerName: string, error: Error): ErrorAnalysis {
    for (const pattern of this.errorPatterns) {
      const match = error.message.match(pattern.pattern);
      if (match) {
        return {
          errorType: pattern.type,
          severity: pattern.severity,
          autoFixable: pattern.autoFixable,
          suggestions: this.generateSuggestions(pattern, match),
          fixes: this.generateAutoFixes(pattern, match, providerName)
        };
      }
    }
    
    return this.handleUnknownError(providerName, error);
  }
}
```

### è‡ªåŠ¨ä¿®å¤æœºåˆ¶

#### 1. æ¨¡æ¿ç”Ÿæˆä¿®å¤
```typescript
private static generateAutoFixes(
  pattern: ErrorPattern,
  match: RegExpMatchArray,
  providerName: string
): AutoFix[] {
  const fixes: AutoFix[] = [];
  
  switch (pattern.type) {
    case 'missing_capability_file':
      fixes.push({
        type: 'create_file',
        description: `ç”Ÿæˆç¼ºå¤±çš„èƒ½åŠ›æ–‡ä»¶: ${match[1]}.ts`,
        action: async () => {
          const capabilityTemplate = await this.generateCapabilityTemplate(
            providerName,
            match[1]
          );
          const filePath = SmartPathResolver.getCapabilityFilePath(
            providerName,
            match[1]
          );
          await writeFile(filePath, capabilityTemplate);
        }
      });
      break;
      
    case 'missing_directory':
      fixes.push({
        type: 'create_directory',
        description: `åˆ›å»ºç¼ºå¤±çš„ç›®å½•ç»“æ„`,
        action: async () => {
          const dirPath = SmartPathResolver.getProviderCapabilitiesPath(providerName);
          await mkdir(dirPath, { recursive: true });
        }
      });
      break;
  }
  
  return fixes;
}
```

#### 2. æ‰¹é‡ä¿®å¤å¤„ç†
```typescript
static async autoFixViolations(violations: ConventionViolation[]): Promise<AutoFixResult> {
  const result: AutoFixResult = {
    success: false,
    fixedIssues: [],
    remainingIssues: [],
    generatedFiles: []
  };
  
  // æŒ‰ä¿®å¤ä¼˜å…ˆçº§æ’åº
  const sortedViolations = violations.sort((a, b) => 
    this.getFixPriority(a.type) - this.getFixPriority(b.type)
  );
  
  for (const violation of sortedViolations) {
    if (violation.autoFixable) {
      try {
        await this.fixViolation(violation);
        result.fixedIssues.push(`ä¿®å¤: ${violation.message}`);
      } catch (error) {
        result.remainingIssues.push(`ä¿®å¤å¤±è´¥: ${violation.message} - ${error.message}`);
      }
    } else {
      result.remainingIssues.push(violation.message);
    }
  }
  
  result.success = result.remainingIssues.length === 0;
  return result;
}
```

## ğŸš€ å¢å¼ºæ³¨å†Œè¡¨æ ¸å¿ƒé€»è¾‘

### å¤šç­–ç•¥æ··åˆæ³¨å†Œ

å¢å¼ºæ³¨å†Œè¡¨é‡‡ç”¨**å››é˜¶æ®µæ··åˆç­–ç•¥**ï¼Œç¡®ä¿è£…é¥°å™¨å’Œæ–‡ä»¶ç³»ç»Ÿä¸¤ç§æ–¹å¼çš„èƒ½åŠ›éƒ½èƒ½è¢«æ­£ç¡®æ³¨å†Œï¼š

```typescript
// src/providers/services/enhanced-capability-registry.service.ts
export class EnhancedCapabilityRegistryService {
  async initializeRegistry(): Promise<void> {
    // é˜¶æ®µ1: æ”¶é›†è£…é¥°å™¨æ³¨å†Œçš„èƒ½åŠ›
    await this.collectDecoratorCapabilities();
    
    // é˜¶æ®µ2: æ‰«ææ–‡ä»¶ç³»ç»Ÿå‘ç°ä¼ ç»Ÿèƒ½åŠ›
    await this.scanFileSystemCapabilities();
    
    // é˜¶æ®µ3: æ™ºèƒ½åˆå¹¶å’Œå†²çªè§£å†³
    await this.mergeAndValidate();
    
    // é˜¶æ®µ4: å¡«å……å‘åå…¼å®¹çš„æ•°æ®ç»“æ„
    this.populateLegacyStructures();
    
    // ç”Ÿæˆç»Ÿè®¡å’Œè°ƒè¯•ä¿¡æ¯
    this.generateStats();
  }
}
```

### å†²çªè§£å†³ç­–ç•¥

å½“è£…é¥°å™¨å’Œæ–‡ä»¶ç³»ç»Ÿå‘ç°åŒåèƒ½åŠ›æ—¶ï¼Œç³»ç»Ÿé‡‡ç”¨ä»¥ä¸‹ä¼˜å…ˆçº§è§„åˆ™ï¼š

```typescript
private resolveCapabilityConflict(
  decoratorCap: CapabilityRegistration,
  fileSystemCap: CapabilityRegistration
): CapabilityRegistration {
  // è£…é¥°å™¨ä¼˜å…ˆçº§é«˜äºæ–‡ä»¶ç³»ç»Ÿå‘ç°
  if (decoratorCap && fileSystemCap) {
    this.logger.warn(
      `èƒ½åŠ›å†²çª: ${decoratorCap.name}, ä½¿ç”¨è£…é¥°å™¨ç‰ˆæœ¬`,
      { decorator: decoratorCap.priority, fileSystem: fileSystemCap.priority }
    );
    return decoratorCap;
  }
  
  return decoratorCap || fileSystemCap;
}
```

### ç»Ÿè®¡ä¿¡æ¯ç”Ÿæˆ

```typescript
private generateStats(): void {
  const stats: RegistryStats = {
    totalCapabilities: 0,
    totalProviders: 0,
    decoratorCapabilities: this.decoratorCapabilities.size,
    fileSystemCapabilities: 0,
    streamCapabilities: 0,
    restCapabilities: 0,
    capabilitiesByProvider: {},
    errors: [],
    warnings: []
  };
  
  // æŒ‰æä¾›å•†ç»Ÿè®¡èƒ½åŠ›æ•°é‡
  for (const [providerName, capabilities] of this.capabilities) {
    stats.capabilitiesByProvider[providerName] = capabilities.size;
    stats.totalCapabilities += capabilities.size;
  }
  
  // ç»Ÿè®¡èƒ½åŠ›ç±»å‹åˆ†å¸ƒ
  for (const [providerName, streamCaps] of this.streamCapabilities) {
    stats.streamCapabilities += streamCaps.size;
  }
  stats.restCapabilities = stats.totalCapabilities - stats.streamCapabilities;
  
  this.registryStats = stats;
}
```

## ğŸ›ï¸ CLIå·¥å…·æ¶æ„

### å‘½ä»¤æ¨¡å¼è®¾è®¡

CLIå·¥å…·é‡‡ç”¨**å‘½ä»¤æ¨¡å¼ (Command Pattern)** è®¾è®¡ï¼Œæ¯ä¸ªå‘½ä»¤éƒ½æ˜¯ç‹¬ç«‹çš„ã€å¯æ‰©å±•çš„ç»„ä»¶ï¼š

```typescript
// src/providers/cli/provider-generator.cli.ts
export class ProviderGeneratorCLI {
  static registerCommands(program: Command): void {
    // æ³¨å†Œæ‰€æœ‰å‘½ä»¤
    this.registerProviderCommands(program);
    this.registerCapabilityCommands(program);
    this.registerManagementCommands(program);
  }
  
  private static registerProviderCommands(program: Command): void {
    program
      .command('provider:generate <name>')
      .description('ç”Ÿæˆæ–°çš„æ•°æ®æºæä¾›å•†')
      .option('-c, --capabilities <capabilities>', 'èƒ½åŠ›åˆ—è¡¨', 'get-stock-quote')
      .action(this.executeProviderGenerate.bind(this));
  }
  
  private static async executeProviderGenerate(
    name: string,
    options: GenerateOptions
  ): Promise<void> {
    // å‘½ä»¤æ‰§è¡Œé€»è¾‘
    const generator = new ProviderGenerator();
    await generator.generate(name, options);
  }
}
```

### æ’ä»¶åŒ–æ¶æ„

CLIæ”¯æŒæ’ä»¶æ‰©å±•ï¼Œå¯ä»¥æ·»åŠ è‡ªå®šä¹‰å‘½ä»¤ï¼š

```typescript
// æ’ä»¶æ¥å£
interface CLIPlugin {
  name: string;
  version: string;
  registerCommands(program: Command): void;
}

// æ’ä»¶æ³¨å†Œå™¨
class PluginRegistry {
  private plugins: CLIPlugin[] = [];
  
  register(plugin: CLIPlugin): void {
    this.plugins.push(plugin);
  }
  
  applyAll(program: Command): void {
    for (const plugin of this.plugins) {
      plugin.registerCommands(program);
    }
  }
}
```

## ğŸ” æ€§èƒ½ä¼˜åŒ–å’Œå†…å­˜ç®¡ç†

### æ‡’åŠ è½½æœºåˆ¶

ç³»ç»Ÿé‡‡ç”¨æ‡’åŠ è½½ç­–ç•¥ï¼Œé¿å…å¯åŠ¨æ—¶åŠ è½½æ‰€æœ‰èƒ½åŠ›ç±»ï¼š

```typescript
class LazyCapabilityLoader {
  private loadedCapabilities = new Map<string, any>();
  
  async loadCapability(providerName: string, capabilityName: string): Promise<any> {
    const key = `${providerName}:${capabilityName}`;
    
    if (this.loadedCapabilities.has(key)) {
      return this.loadedCapabilities.get(key);
    }
    
    // åŠ¨æ€å¯¼å…¥èƒ½åŠ›æ¨¡å—
    const capabilityModule = await import(
      `../providers/${providerName}/capabilities/${capabilityName}`
    );
    
    const capability = this.instantiateCapability(capabilityModule);
    this.loadedCapabilities.set(key, capability);
    
    return capability;
  }
}
```

### å†…å­˜ä½¿ç”¨ä¼˜åŒ–

```typescript
class MemoryOptimizedRegistry {
  // ä½¿ç”¨WeakMapé¿å…å†…å­˜æ³„æ¼
  private classMetadata = new WeakMap<Constructor, any>();
  
  // å®šæœŸæ¸…ç†æœªä½¿ç”¨çš„ç¼“å­˜
  private cleanupTimer = setInterval(() => {
    this.cleanupUnusedCapabilities();
  }, 300000); // 5åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
  
  private cleanupUnusedCapabilities(): void {
    const now = Date.now();
    for (const [key, item] of this.loadedCapabilities) {
      if (now - item.lastAccessed > 600000) { // 10åˆ†é’Ÿæœªä½¿ç”¨
        this.loadedCapabilities.delete(key);
      }
    }
  }
}
```

## ğŸ§ª æµ‹è¯•æ¶æ„

### æµ‹è¯•å±‚æ¬¡ç»“æ„

```
æµ‹è¯•æ¶æ„
â”œâ”€â”€ å•å…ƒæµ‹è¯• (Unit Tests)
â”‚   â”œâ”€â”€ è£…é¥°å™¨åŠŸèƒ½æµ‹è¯•
â”‚   â”œâ”€â”€ è·¯å¾„è§£ææµ‹è¯•
â”‚   â”œâ”€â”€ é”™è¯¯å¤„ç†æµ‹è¯•
â”‚   â””â”€â”€ CLIå‘½ä»¤æµ‹è¯•
â”œâ”€â”€ é›†æˆæµ‹è¯• (Integration Tests)
â”‚   â”œâ”€â”€ æ³¨å†Œè¡¨é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ æ–‡ä»¶ç³»ç»Ÿæ‰«ææµ‹è¯•
â”‚   â””â”€â”€ ç«¯åˆ°ç«¯èƒ½åŠ›æ³¨å†Œæµ‹è¯•
â””â”€â”€ E2Eæµ‹è¯• (End-to-End Tests)
    â”œâ”€â”€ å®Œæ•´æä¾›å•†ç”Ÿæˆæµç¨‹
    â”œâ”€â”€ è‡ªåŠ¨ä¿®å¤åŠŸèƒ½æµ‹è¯•
    â””â”€â”€ CLIå·¥å…·å®Œæ•´æ€§æµ‹è¯•
```

### æµ‹è¯•å·¥å…·å’ŒMock

```typescript
// æµ‹è¯•å·¥å…·ç±»
export class TestingUtils {
  static createMockProvider(name: string): ProviderCollectionItem {
    return {
      class: class MockProvider {},
      metadata: { name, description: `Mock ${name}` },
      filePath: `/mock/providers/${name}/index.ts`,
      registeredAt: new Date()
    };
  }
  
  static createMockCapability(
    provider: string,
    name: string
  ): CapabilityCollectionItem {
    return {
      class: class MockCapability {},
      metadata: { name, provider },
      provider,
      filePath: `/mock/providers/${provider}/capabilities/${name}.ts`,
      registeredAt: new Date()
    };
  }
}
```

## ğŸ”’ å®‰å…¨æ€§è€ƒè™‘

### è·¯å¾„å®‰å…¨éªŒè¯

```typescript
class SecurityValidator {
  static validatePath(path: string): boolean {
    // é˜²æ­¢è·¯å¾„éå†æ”»å‡»
    if (path.includes('..') || path.includes('~')) {
      return false;
    }
    
    // é™åˆ¶åœ¨é¡¹ç›®ç›®å½•å†…
    const projectRoot = SmartPathResolver.getProjectRoot();
    const absolutePath = resolve(path);
    return absolutePath.startsWith(projectRoot);
  }
  
  static sanitizeFileName(fileName: string): string {
    // ç§»é™¤å±é™©å­—ç¬¦
    return fileName.replace(/[^a-zA-Z0-9\-_\.]/g, '');
  }
}
```

### ä»£ç æ³¨å…¥é˜²æŠ¤

```typescript
class CodeInjectionProtection {
  static validateTemplateInput(input: string): boolean {
    // æ£€æŸ¥æ¶æ„ä»£ç æ¨¡å¼
    const dangerousPatterns = [
      /eval\s*\(/,
      /Function\s*\(/,
      /require\s*\(/,
      /import\s*\(/,
      /__dirname/,
      /__filename/
    ];
    
    return !dangerousPatterns.some(pattern => pattern.test(input));
  }
}
```

## ğŸ“ˆ ç›‘æ§å’Œè¯Šæ–­

### æ€§èƒ½ç›‘æ§

```typescript
class PerformanceMonitor {
  private static metrics = new Map<string, PerformanceMetric>();
  
  static startTimer(operation: string): string {
    const timerId = `${operation}_${Date.now()}`;
    this.metrics.set(timerId, {
      operation,
      startTime: performance.now(),
      endTime: null
    });
    return timerId;
  }
  
  static endTimer(timerId: string): number {
    const metric = this.metrics.get(timerId);
    if (metric) {
      metric.endTime = performance.now();
      const duration = metric.endTime - metric.startTime;
      
      // è®°å½•æ…¢æ“ä½œ
      if (duration > 1000) { // è¶…è¿‡1ç§’
        console.warn(`æ…¢æ“ä½œæ£€æµ‹: ${metric.operation} è€—æ—¶ ${duration}ms`);
      }
      
      return duration;
    }
    return 0;
  }
}
```

### å¥åº·æ£€æŸ¥

```typescript
class SystemHealthChecker {
  async checkSystemHealth(): Promise<HealthReport> {
    const report: HealthReport = {
      overall: 'healthy',
      components: {}
    };
    
    // æ£€æŸ¥è£…é¥°å™¨ç³»ç»Ÿ
    report.components.decorators = await this.checkDecorators();
    
    // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿ
    report.components.filesystem = await this.checkFileSystem();
    
    // æ£€æŸ¥æ³¨å†Œè¡¨
    report.components.registry = await this.checkRegistry();
    
    // è®¡ç®—æ•´ä½“å¥åº·çŠ¶æ€
    report.overall = this.calculateOverallHealth(report.components);
    
    return report;
  }
}
```

## ğŸ”„ ç‰ˆæœ¬å…¼å®¹æ€§å’Œè¿ç§»

### æ¸è¿›å¼è¿ç§»ç­–ç•¥

ç³»ç»Ÿè®¾è®¡æ”¯æŒä»ä¼ ç»Ÿæ–¹å¼åˆ°è£…é¥°å™¨æ–¹å¼çš„æ¸è¿›å¼è¿ç§»ï¼š

```typescript
// é˜¶æ®µ1: å…¼å®¹è¿è¡Œ - ä¼ ç»Ÿå’Œè£…é¥°å™¨å¹¶å­˜
// é˜¶æ®µ2: é€æ­¥è¿ç§» - éƒ¨åˆ†èƒ½åŠ›ä½¿ç”¨è£…é¥°å™¨
// é˜¶æ®µ3: å®Œå…¨è¿ç§» - æ‰€æœ‰èƒ½åŠ›ä½¿ç”¨è£…é¥°å™¨
// é˜¶æ®µ4: æ¸…ç†é˜¶æ®µ - ç§»é™¤ä¼ ç»Ÿæ”¯æŒä»£ç 

class MigrationManager {
  static async checkMigrationStatus(): Promise<MigrationStatus> {
    const decoratorCount = CapabilityCollector.getAllCapabilities().size;
    const fileSystemCount = await this.countFileSystemCapabilities();
    
    const total = decoratorCount + fileSystemCount;
    const migrationPercentage = total > 0 ? (decoratorCount / total) * 100 : 0;
    
    return {
      totalCapabilities: total,
      decoratorCapabilities: decoratorCount,
      fileSystemCapabilities: fileSystemCount,
      migrationPercentage,
      recommendedAction: this.getRecommendedAction(migrationPercentage)
    };
  }
}
```

## ğŸ¯ æœªæ¥æ‰©å±•è§„åˆ’

### è®¡åˆ’ä¸­çš„åŠŸèƒ½

1. **è¿œç¨‹èƒ½åŠ›åŠ è½½**: æ”¯æŒä»è¿œç¨‹ä»“åº“åŠ¨æ€åŠ è½½èƒ½åŠ›
2. **èƒ½åŠ›å¸‚åœº**: å»ºç«‹èƒ½åŠ›ç»„ä»¶çš„å…±äº«å¸‚åœº
3. **å¯è§†åŒ–ç®¡ç†ç•Œé¢**: Webç•Œé¢ç®¡ç†æä¾›å•†å’Œèƒ½åŠ›
4. **æ™ºèƒ½ä¾èµ–ç®¡ç†**: è‡ªåŠ¨å¤„ç†èƒ½åŠ›é—´çš„ä¾èµ–å…³ç³»
5. **æ€§èƒ½åŸºå‡†æµ‹è¯•**: å†…ç½®æ€§èƒ½æµ‹è¯•å’Œæ¯”è¾ƒå·¥å…·

### æ‰©å±•æ¥å£

```typescript
// æœªæ¥æ‰©å±•æ¥å£
interface FutureExtensions {
  // è¿œç¨‹èƒ½åŠ›åŠ è½½å™¨
  remoteLoader?: RemoteCapabilityLoader;
  
  // å¯è§†åŒ–ç®¡ç†æ¥å£
  webInterface?: WebManagementInterface;
  
  // æ™ºèƒ½ä¾èµ–è§£æå™¨
  dependencyResolver?: DependencyResolver;
  
  // æ€§èƒ½åŸºå‡†æµ‹è¯•å™¨
  benchmarkRunner?: BenchmarkRunner;
}
```

## ğŸ“ æ€»ç»“

å¢å¼ºæä¾›å•†æ³¨å†Œç³»ç»Ÿé€šè¿‡å¼•å…¥ç°ä»£åŒ–çš„è£…é¥°å™¨æ¶æ„ï¼Œåœ¨ä¿æŒå®Œå…¨å‘åå…¼å®¹çš„å‰æä¸‹ï¼Œå¤§å¹…æå‡äº†ç³»ç»Ÿçš„å¼€å‘ä½“éªŒã€å¯ç»´æŠ¤æ€§å’Œç¨³å®šæ€§ã€‚ç³»ç»Ÿçš„æ ¸å¿ƒä¼˜åŠ¿åŒ…æ‹¬ï¼š

### æŠ€æœ¯ä¼˜åŠ¿
- **å£°æ˜å¼ç¼–ç¨‹**: è£…é¥°å™¨è®©é…ç½®æ›´ç›´è§‚ã€æ›´å®‰å…¨
- **æ™ºèƒ½æ¨æ–­**: å‡å°‘æ‰‹åŠ¨é…ç½®ï¼Œé™ä½å‡ºé”™æ¦‚ç‡
- **å¤šå±‚å®¹é”™**: å¤šç§ç­–ç•¥ç¡®ä¿ç³»ç»Ÿåœ¨å„ç§ç¯å¢ƒä¸‹ç¨³å®šè¿è¡Œ
- **è‡ªåŠ¨åŒ–å·¥å…·**: CLIå·¥å…·å¤§å¹…æå‡å¼€å‘æ•ˆç‡

### æ¶æ„ä¼˜åŠ¿
- **æ¨¡å—åŒ–è®¾è®¡**: å„ç»„ä»¶èŒè´£æ¸…æ™°ï¼Œæ˜“äºæ‰©å±•å’Œç»´æŠ¤
- **æ’ä»¶åŒ–æ¶æ„**: æ”¯æŒåŠŸèƒ½æ‰©å±•è€Œä¸å½±å“æ ¸å¿ƒç³»ç»Ÿ
- **æ€§èƒ½ä¼˜åŒ–**: æ‡’åŠ è½½å’Œå†…å­˜ç®¡ç†ç¡®ä¿ç³»ç»Ÿé«˜æ•ˆè¿è¡Œ
- **å®‰å…¨å¯é **: å¤šå±‚å®‰å…¨éªŒè¯é˜²æ­¢å„ç§æ”»å‡»

### å¼€å‘ä½“éªŒ
- **5åˆ†é’Ÿæ¥å…¥**: ä»é›¶åˆ°å¯ç”¨çš„æ–°æä¾›å•†ä»…éœ€5åˆ†é’Ÿ
- **æ™ºèƒ½ä¿®å¤**: è‡ªåŠ¨æ£€æµ‹å’Œä¿®å¤å¸¸è§é—®é¢˜
- **å®Œæ•´å·¥å…·é“¾**: ä»ç”Ÿæˆåˆ°éƒ¨ç½²çš„å…¨æµç¨‹å·¥å…·æ”¯æŒ
- **è¯¦ç»†è°ƒè¯•**: ä¸°å¯Œçš„ç»Ÿè®¡å’Œè°ƒè¯•ä¿¡æ¯

è¯¥ç³»ç»Ÿä¸ºæ•°æ®æºæä¾›å•†çš„å¼€å‘å’Œç®¡ç†å»ºç«‹äº†ç°ä»£åŒ–ã€é«˜æ•ˆçš„åŸºç¡€è®¾æ–½ï¼Œä¸ºé¡¹ç›®çš„é•¿æœŸå‘å±•å¥ å®šäº†åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚