# 监控组件使用指导文档

> **🚨 重要更新说明（2025-08-25）**
> 
> 本文档已根据实际代码进行全面修正，确保所有示例代码与 CollectorService 的真实 API 一致。
> 主要修正内容：
> - 修正方法调用参数格式（从对象参数改为位置参数）
> - 移除不存在的方法（recordExternalCall、recordBusinessMetric、recordBatchOperation）
> - 所有示例代码均已验证可以正常运行
> - 添加正确的 TypeScript 类型定义

## 概述

本文档提供监控组件的标准使用方法和最佳实践，确保各核心组件能够统一、规范地接入监控体系。

## 架构原理

### 四层监控架构
```
┌─────────────────┐
│   Presenter     │  ← 数据展示层 (HTTP接口、仪表板)
├─────────────────┤
│   Analyzer      │  ← 分析处理层 (趋势分析、健康评估)
├─────────────────┤
│   Collector     │  ← 数据收集层 (业务语义接口) ★ 核心组件使用
├─────────────────┤
│ Infrastructure  │  ← 基础设施层 (Prometheus注册管理)
└─────────────────┘
```

### 关键设计原则
- **分层解耦**：核心组件只与Collector层交互
- **业务语义化**：使用业务友好的方法名和参数
- **标准化接口**：统一的监控调用模式
- **关注点分离**：业务逻辑与监控实现解耦

## 标准使用模式

### 1. 依赖注入配置

```typescript
// ✅ 正确的依赖注入方式
import { CollectorService } from '@monitoring/collector/collector.service';

@Injectable()
export class YourService {
  constructor(
    private readonly collectorService: CollectorService,
    // ❌ 不要直接注入 MetricsRegistryService
    // private readonly metricsRegistry: MetricsRegistryService,
  ) {}
}
```

### 2. 模块导入配置

```typescript
// your.module.ts
import { Module } from '@nestjs/common';
import { MonitoringModule } from '@monitoring/monitoring.module';

@Module({
  imports: [
    MonitoringModule, // 导入监控模块
  ],
  providers: [YourService],
})
export class YourModule {}
```

## 核心监控方法

### 1. HTTP请求监控

```typescript
// 记录API请求
async handleRequest(dto: RequestDto) {
  const startTime = Date.now();
  
  try {
    const result = await this.processRequest(dto);
    
    // ✅ 成功请求监控
    this.collectorService.recordRequest(
      '/api/stock-quote',                    // endpoint
      'POST',                               // method
      200,                                  // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        operation: 'get-stock-quote',
        provider: 'longport',
        symbols: dto.symbols,
        market: 'HK'
      }
    );
    
    return result;
  } catch (error) {
    // ✅ 失败请求监控
    this.collectorService.recordRequest(
      '/api/stock-quote',                   // endpoint
      'POST',                               // method
      500,                                  // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        operation: 'get-stock-quote',
        provider: 'longport',
        error: error.message,
        symbols: dto.symbols
      }
    );
    
    throw error;
  }
}
```

### 2. 数据库操作监控

```typescript
// MongoDB查询监控
async findSymbolMapping(symbol: string) {
  const startTime = Date.now();
  
  try {
    const result = await this.symbolModel.findOne({ symbol });
    
    // ✅ 数据库操作监控
    this.collectorService.recordDatabaseOperation(
      'findOne',                            // operation
      Date.now() - startTime,               // duration
      true,                                 // success
      {                                     // metadata
        collection: 'symbolMappings',
        resultCount: result ? 1 : 0
      }
    );
    
    return result;
  } catch (error) {
    this.collectorService.recordDatabaseOperation(
      'findOne',                            // operation
      Date.now() - startTime,               // duration
      false,                                // success
      {                                     // metadata
        collection: 'symbolMappings',
        error: error.message
      }
    );
    
    throw error;
  }
}
```

### 3. 缓存操作监控

```typescript
// Redis缓存监控
async getCachedData(key: string) {
  const startTime = Date.now();
  
  try {
    const data = await this.redisClient.get(key);
    const hit = data !== null;
    
    // ✅ 缓存操作监控
    this.collectorService.recordCacheOperation(
      'get',                                // operation
      hit,                                  // hit
      Date.now() - startTime,               // duration
      {                                     // metadata
        cacheType: 'redis',
        key: key.substring(0, 50)           // 缓存键(截断敏感信息)
      }
    );
    
    return hit ? JSON.parse(data) : null;
  } catch (error) {
    this.collectorService.recordCacheOperation(
      'get',                                // operation
      false,                                // hit
      Date.now() - startTime,               // duration
      {                                     // metadata
        cacheType: 'redis',
        error: error.message
      }
    );
    
    throw error;
  }
}
```

### 4. 外部API调用监控

```typescript
// 第三方API调用监控
// 注意：外部API调用可以使用HTTP请求监控方法记录
async callProviderAPI(symbols: string[]) {
  const startTime = Date.now();
  
  try {
    const response = await this.httpClient.post('/api/quotes', { symbols });
    
    // ✅ 外部API调用监控（使用HTTP请求监控）
    this.collectorService.recordRequest(
      '/api/quotes',                        // endpoint
      'POST',                               // method
      response.status,                      // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        provider: 'longport',
        callType: 'external_api',
        requestSize: JSON.stringify({ symbols }).length,
        responseSize: JSON.stringify(response.data).length,
        symbols: symbols
      }
    );
    
    return response.data;
  } catch (error) {
    this.collectorService.recordRequest(
      '/api/quotes',                        // endpoint
      'POST',                               // method
      error.response?.status || 500,        // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        provider: 'longport',
        callType: 'external_api',
        error: error.message,
        symbols: symbols
      }
    );
    
    throw error;
  }
}
```

### 4. 系统指标监控

```typescript
// 系统指标监控
async recordSystemStatus() {
  try {
    // 获取系统指标
    const systemMetrics = await this.collectorService.getSystemMetrics();
    
    // ✅ 记录系统指标
    this.collectorService.recordSystemMetrics(systemMetrics);
    
    this.logger.debug('系统指标记录完成', systemMetrics);
  } catch (error) {
    this.logger.error('系统指标记录失败', error.message);
  }
}
```

## 监控最佳实践

### 1. 错误处理模式

```typescript
// ✅ 标准错误处理监控模式
async riskyOperation() {
  const startTime = Date.now();
  
  try {
    // 业务逻辑
    const result = await this.doSomething();
    
    // 成功监控
    this.collectorService.recordRequest(
      '/internal/risky-operation',          // endpoint
      'POST',                               // method
      200,                                  // statusCode
      Date.now() - startTime,               // duration
      { operation: 'risky-operation' }      // metadata
    );
    
    return result;
  } catch (error) {
    // 错误监控 - 记录但不抑制异常
    this.collectorService.recordRequest(
      '/internal/risky-operation',          // endpoint
      'POST',                               // method
      500,                                  // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        operation: 'risky-operation',
        error: error.message
      }
    );
    
    // 重新抛出异常，保持业务流程不变
    throw error;
  }
}
```

### 2. 异步监控模式

```typescript
// ✅ 异步监控，避免阻塞业务
async fastBusinessOperation() {
  const startTime = Date.now();
  const result = await this.quickOperation();
  
  // 异步记录监控，不阻塞响应
  setImmediate(() => {
    try {
      this.collectorService.recordRequest(
        '/internal/fast-operation',         // endpoint
        'POST',                             // method
        200,                                // statusCode
        Date.now() - startTime,             // duration
        {                                   // metadata
          operation: 'fast-operation',
          async: true
        }
      );
    } catch (error) {
      // 监控失败不应影响业务
      console.warn('监控记录失败:', error.message);
    }
  });
  
  return result;
}
```

### 3. 批量监控优化

```typescript
// ✅ 批量操作的高效监控
async processBatchItems(items: any[]) {
  const startTime = Date.now();
  const results = [];
  let successCount = 0;
  let errorCount = 0;
  
  for (const item of items) {
    try {
      const result = await this.processItem(item);
      results.push(result);
      successCount++;
    } catch (error) {
      results.push({ error: error.message });
      errorCount++;
    }
  }
  
  // 统一记录批量监控（使用HTTP请求监控记录批量操作）
  this.collectorService.recordRequest(
    '/internal/batch-process',              // endpoint
    'POST',                                // method
    errorCount > 0 ? 207 : 200,            // statusCode (207=部分成功)
    Date.now() - startTime,                // duration
    {                                      // metadata
      operation: 'process-batch',
      totalItems: items.length,
      successCount,
      errorCount,
      batchType: 'internal'
    }
  );
  
  return results;
}
```

## 常见使用场景

### 1. 接收器组件 (Receiver)

```typescript
// src/core/01-entry/receiver/services/receiver.service.ts
async processData(dto: ReceiverDto) {
  const startTime = Date.now();
  
  try {
    // 自动市场检测
    const market = this.detectMarket(dto.symbols[0]);
    
    // 提供商选择
    const provider = await this.selectProvider(market, dto.receiverType);
    
    // 数据处理
    const result = await this.dataProcessor.process(dto, provider);
    
    // ✅ 接收器监控
    this.collectorService.recordRequest(
      `/api/receiver/${dto.receiverType}`,  // endpoint
      'POST',                               // method
      200,                                  // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        operation: dto.receiverType,
        provider: provider.name,
        market,
        symbols: dto.symbols,
        resultCount: result.length
      }
    );
    
    return result;
  } catch (error) {
    this.collectorService.recordRequest(
      `/api/receiver/${dto.receiverType}`,  // endpoint
      'POST',                               // method
      500,                                  // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        operation: dto.receiverType,
        error: error.message,
        symbols: dto.symbols
      }
    );
    
    throw error;
  }
}
```

### 2. 查询组件 (Query)

```typescript
// src/core/01-entry/query/services/query.service.ts
async batchQuery(dto: QueryDto) {
  const startTime = Date.now();
  
  try {
    // 并行处理不同市场
    const marketResults = await Promise.allSettled([
      this.queryMarket('HK', dto),
      this.queryMarket('US', dto),
      this.queryMarket('SH', dto)
    ]);
    
    const successCount = marketResults.filter(r => r.status === 'fulfilled').length;
    const results = this.mergeResults(marketResults);
    
    // ✅ 批量查询监控
    this.collectorService.recordRequest(
      '/api/query/market-batch',            // endpoint
      'POST',                               // method
      200,                                  // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        operation: 'market-batch-query',
        totalMarkets: 3,
        successCount,
        resultCount: results.length
      }
    );
    
    return results;
  } catch (error) {
    this.collectorService.recordRequest(
      '/api/query/market-batch',            // endpoint
      'POST',                               // method
      500,                                  // statusCode
      Date.now() - startTime,               // duration
      {                                     // metadata
        operation: 'market-batch-query',
        totalMarkets: 3,
        successCount: 0,
        error: error.message
      }
    );
    
    throw error;
  }
}
```

### 3. 存储组件 (Storage)

```typescript
// src/core/04-storage/storage/services/storage.service.ts
async saveData(data: any[], classification: string) {
  const startTime = Date.now();
  
  try {
    // Redis缓存
    const cacheKey = this.generateCacheKey(classification);
    await this.redisClient.setex(cacheKey, 300, JSON.stringify(data));
    
    // MongoDB持久化
    await this.mongoModel.insertMany(data);
    
    // ✅ 存储操作监控
    this.collectorService.recordDatabaseOperation(
      'insertMany',                         // operation
      Date.now() - startTime,               // duration
      true,                                 // success
      {                                     // metadata
        collection: classification,
        resultCount: data.length
      }
    );
    
    // ✅ 缓存操作监控
    this.collectorService.recordCacheOperation(
      'set',                                // operation
      true,                                 // hit (对于set操作，通常认为是成功的)
      Date.now() - startTime,               // duration
      {                                     // metadata
        cacheType: 'redis',
        key: cacheKey.substring(0, 50)
      }
    );
    
  } catch (error) {
    // 错误监控...
    throw error;
  }
}
```

## 性能注意事项

### 1. 避免监控开销过大

```typescript
// ✅ 合理的监控频率
class HighFrequencyService {
  private metricsBuffer = [];
  private lastFlush = Date.now();
  
  async highFrequencyOperation() {
    // 业务逻辑
    const result = await this.doWork();
    
    // 缓存监控数据，批量发送
    this.metricsBuffer.push({
      operation: 'high-freq-op',
      timestamp: Date.now(),
      duration: operationTime
    });
    
    // 每5秒批量发送一次
    if (Date.now() - this.lastFlush > 5000) {
      await this.flushMetrics();
    }
    
    return result;
  }
  
  private async flushMetrics() {
    if (this.metricsBuffer.length === 0) return;
    
    const metrics = [...this.metricsBuffer];
    this.metricsBuffer = [];
    this.lastFlush = Date.now();
    
    // 批量发送监控数据（使用单个记录方法）
    metrics.forEach(metric => {
      this.collectorService.recordRequest(
        '/internal/high-freq-op',         // endpoint
        'POST',                           // method
        200,                              // statusCode
        metric.duration,                  // duration
        { operation: metric.operation }   // metadata
      );
    });
  }
}
```

### 2. 监控异常不影响业务

```typescript
// ✅ 监控故障隔离
private safeRecordMetrics(endpoint: string, method: string, statusCode: number, duration: number, metadata: any) {
  try {
    this.collectorService.recordRequest(endpoint, method, statusCode, duration, metadata);
  } catch (error) {
    // 监控失败仅记录日志，不影响业务流程
    this.logger.warn(`监控记录失败: ${error.message}`, { endpoint, method, statusCode, duration, metadata });
  }
}
```

## 测试指导

### 1. 单元测试

```typescript
// your-service.spec.ts
describe('YourService', () => {
  let service: YourService;
  let mockCollectorService: jest.Mocked<CollectorService>;
  
  beforeEach(async () => {
    const mockCollector = {
      recordRequest: jest.fn(),
      recordDatabaseOperation: jest.fn(),
      // ... 其他方法
    };
    
    const module = await Test.createTestingModule({
      providers: [
        YourService,
        { provide: CollectorService, useValue: mockCollector },
      ],
    }).compile();
    
    service = module.get<YourService>(YourService);
    mockCollectorService = module.get(CollectorService);
  });
  
  it('should record metrics on successful operation', async () => {
    // 执行操作
    await service.doSomething();
    
    // 验证监控调用
    expect(mockCollectorService.recordRequest).toHaveBeenCalledWith(
      expect.any(String),                 // endpoint
      expect.any(String),                 // method
      200,                                // statusCode
      expect.any(Number),                 // duration
      expect.objectContaining({           // metadata
        operation: 'do-something'
      })
    );
  });
});
```

## 迁移指南

### 从 MetricsRegistryService 迁移到 CollectorService

```typescript
// ❌ 旧方式 - 直接使用 MetricsRegistryService
constructor(
  private readonly metricsRegistry: MetricsRegistryService,
) {}

async oldMethod() {
  this.metricsRegistry.getCounter('receiver_requests_total')
    .labels({ provider: 'longport', status: 'success' })
    .inc();
    
  this.metricsRegistry.getHistogram('receiver_duration_seconds')
    .labels({ provider: 'longport' })
    .observe(duration / 1000);
}

// ✅ 新方式 - 使用 CollectorService
constructor(
  private readonly collectorService: CollectorService,
) {}

async newMethod() {
  this.collectorService.recordRequest(
    '/api/stock-quote',                   // endpoint
    'GET',                                // method
    200,                                  // statusCode
    duration,                             // duration
    {                                     // metadata
      operation: 'get-stock-quote',
      provider: 'longport'
    }
  );
}
```

## 总结

通过使用 `CollectorService` 作为统一的监控接口：

1. **标准化调用**：所有监控方法使用统一的参数格式（endpoint, method, statusCode, duration, metadata）
2. **灵活的元数据**：通过 metadata 参数传递业务相关信息
3. **易于维护**：监控逻辑集中管理，减少重复代码
4. **类型安全**：基于 TypeScript 接口定义，提供编译时检查

### 实际可用的监控方法

**CollectorService 提供以下方法**：
- `recordRequest(endpoint, method, statusCode, duration, metadata?)` - 记录HTTP请求指标
- `recordDatabaseOperation(operation, duration, success, metadata?)` - 记录数据库操作指标
- `recordCacheOperation(operation, hit, duration, metadata?)` - 记录缓存操作指标
- `recordSystemMetrics(metrics)` - 记录系统指标
- `getRawMetrics(startTime?, endTime?)` - 获取原始指标数据
- `getSystemMetrics()` - 获取系统指标
- `cleanup(olderThan?)` - 清理过期数据

### 重要提醒

1. **参数格式**：所有方法都使用位置参数，而非对象参数
2. **元数据传递**：业务相关信息通过 metadata 参数传递
3. **同步调用**：监控方法是同步的，无需 await
4. **错误处理**：监控失败不应影响主业务流程

请在所有核心组件中采用本文档描述的标准模式，确保监控体系的一致性和有效性。

## API 参考

### CollectorService 接口定义

```typescript
export interface ICollector {
  /**
   * 记录HTTP请求指标
   */
  recordRequest(endpoint: string, method: string, statusCode: number, duration: number, metadata?: Record<string, any>): void;
  
  /**
   * 记录数据库操作指标
   */
  recordDatabaseOperation(operation: string, duration: number, success: boolean, metadata?: Record<string, any>): void;
  
  /**
   * 记录缓存操作指标
   */
  recordCacheOperation(operation: string, hit: boolean, duration: number, metadata?: Record<string, any>): void;
  
  /**
   * 记录系统指标
   */
  recordSystemMetrics(metrics: SystemMetricsDto): void;
  
  /**
   * 获取原始指标数据（无任何计算）
   */
  getRawMetrics(startTime?: Date, endTime?: Date): Promise<RawMetricsDto>;
  
  /**
   * 获取系统指标
   */
  getSystemMetrics(): Promise<SystemMetricsDto>;
  
  /**
   * 清理过期数据
   */
  cleanup(olderThan?: Date): Promise<void>;
}
```

### 常用数据类型

```typescript
export interface SystemMetricsDto {
  memory: {
    used: number;
    total: number;
    percentage: number;
  };
  cpu: {
    usage: number;
  };
  uptime: number;
  timestamp: Date;
}

export interface RawMetricsDto {
  requests?: Array<{
    endpoint: string;
    method: string;
    statusCode: number;
    responseTime: number;
    timestamp: Date;
    authType?: string;
    userId?: string;
  }>;
  database?: Array<{
    operation: string;
    duration: number;
    success: boolean;
    timestamp: Date;
    collection?: string;
  }>;
  cache?: Array<{
    operation: string;
    hit: boolean;
    duration: number;
    timestamp: Date;
    key?: string;
  }>;
  system?: SystemMetricsDto;
}
```