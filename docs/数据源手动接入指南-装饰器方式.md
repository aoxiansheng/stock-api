# 数据源手动接入指南 - 装饰器方式

## 概述

手动接入方式适合需要**精确控制代码结构**或**学习系统内部机制**的开发者。通过手动创建文件和编写装饰器代码，您可以完全理解新装饰器系统的工作原理。

> **注意**: 如果您希望快速接入数据源，建议使用 [CLI工具方式](./数据源快速接入指南-CLI工具方式.md)，只需5分钟即可完成。

## 🎯 装饰器系统核心概念

### 装饰器的优势

相比传统的文件导出方式，装饰器方式具有以下优势：

- **编译时验证**: TypeScript编译器检查类型和接口实现
- **自动注册**: 无需手动配置路径和导入
- **智能推断**: 自动从文件路径推断提供商名称
- **IDE支持**: 完整的智能提示和重构支持
- **声明式**: 配置即文档，清晰直观

### 核心装饰器

```typescript
// 提供商装饰器
@Provider({
  name: string,              // 提供商唯一名称
  description?: string,      // 描述信息
  autoRegister?: boolean,    // 是否自动注册（默认true）
  healthCheck?: boolean      // 是否启用健康检查（默认false）
})

// REST能力装饰器
@Capability({
  name: string,              // 能力名称（如：get-stock-quote）
  provider?: string,         // 提供商名称（可自动推断）
  description?: string,      // 能力描述
  markets?: string[],        // 支持的市场
  priority?: number,         // 优先级（默认1）
  enabled?: boolean         // 是否启用（默认true）
})

// WebSocket流能力装饰器
@StreamCapability({
  // 继承@Capability的所有属性
  type: 'websocket'         // 固定为websocket
})
```

## 🏗️ 手动接入完整步骤

### 步骤1: 创建目录结构

```bash
# 在 src/providers/ 下创建提供商目录
mkdir -p src/providers/alpha-vantage/{capabilities,module,services}
mkdir -p src/providers/alpha-vantage/tests
```

**推荐的目录结构**:
```
src/providers/alpha-vantage/
├── index.ts                    # 主Provider类
├── module/
│   └── alpha-vantage.module.ts # NestJS模块
├── capabilities/               # 能力实现目录
│   ├── get-stock-quote.ts     
│   ├── get-stock-basic-info.ts
│   └── stream-real-time.ts    # 流能力示例
├── services/                   # 可选：辅助服务
│   └── alpha-vantage-client.ts
├── types.ts                    # 类型定义
├── README.md                   # 文档
└── tests/                      # 可选：测试文件
    └── alpha-vantage.spec.ts
```

### 步骤2: 创建主Provider类

```typescript
// src/providers/alpha-vantage/index.ts
import { Injectable } from '@nestjs/common';
import { Provider } from '../decorators';
import { IDataProvider } from '../interfaces/provider.interface';

@Provider({
  name: 'alpha-vantage',
  description: 'Alpha Vantage 免费股票API数据源',
  autoRegister: true,
  healthCheck: true
})
@Injectable()
export class AlphaVantageProvider implements IDataProvider {
  readonly name = 'alpha-vantage';
  readonly description = 'Alpha Vantage 免费股票API数据源';

  constructor(
    // 可以注入配置服务或其他依赖
    // @Inject('CONFIG_SERVICE') private configService: ConfigService
  ) {}

  async initialize(): Promise<void> {
    console.log(`${this.name} 数据源初始化开始...`);
    
    // TODO: 实现初始化逻辑
    // - 验证API密钥
    // - 设置连接池
    // - 初始化缓存
    
    console.log(`${this.name} 数据源初始化完成`);
  }

  async testConnection(): Promise<boolean> {
    try {
      // TODO: 实现连接测试
      // const response = await this.apiClient.ping();
      // return response.status === 'ok';
      
      console.log(`${this.name} 连接测试通过`);
      return true;
    } catch (error) {
      console.error(`${this.name} 连接测试失败:`, error.message);
      return false;
    }
  }

  getCapability(name: string): any {
    // TODO: 如果需要运行时获取能力实例，在这里实现
    // 装饰器系统会自动处理大部分情况
    return null;
  }
}

export default AlphaVantageProvider;
```

### 步骤3: 创建能力实现

#### REST能力示例

```typescript
// src/providers/alpha-vantage/capabilities/get-stock-quote.ts
import { Capability } from '../../decorators';
import { ICapability } from '../../interfaces/capability.interface';
import { DataRequest, DataResponse } from '../../interfaces/data.interface';

@Capability({
  name: 'get-stock-quote',
  provider: 'alpha-vantage', // 可省略，会自动从路径推断
  description: '获取股票实时报价数据',
  markets: ['US', 'UK'], // Alpha Vantage主要支持美国和英国市场
  priority: 2, // 优先级稍低，因为有请求限制
  symbolFormats: ['SYMBOL', 'SYMBOL.EXCHANGE'],
  config: {
    rateLimit: {
      requestsPerMinute: 5, // Alpha Vantage免费版限制
      requestsPerDay: 500
    }
  }
})
export class GetStockQuoteCapability implements ICapability {
  readonly name = 'get-stock-quote';
  readonly supportedMarkets = ['US', 'UK'];
  readonly supportedSymbolFormats = ['SYMBOL', 'SYMBOL.EXCHANGE'];

  async execute(request: DataRequest): Promise<DataResponse> {
    const { symbols } = request;
    
    try {
      // 输入验证
      this.validateRequest(request);
      
      // 获取API密钥
      const apiKey = this.getApiKey();
      
      // 调用Alpha Vantage API
      const quotes = await this.fetchQuotes(symbols, apiKey);
      
      // 转换为标准格式
      const standardizedData = this.transformToStandardFormat(quotes);
      
      return {
        success: true,
        data: standardizedData,
        timestamp: new Date(),
        metadata: {
          provider: 'alpha-vantage',
          rateLimitRemaining: quotes.rateLimitRemaining
        }
      };
    } catch (error) {
      throw new Error(`Alpha Vantage获取股票报价失败: ${error.message}`);
    }
  }

  private validateRequest(request: DataRequest): void {
    if (!request.symbols || request.symbols.length === 0) {
      throw new Error('symbols参数不能为空');
    }
    
    if (request.symbols.length > 5) {
      throw new Error('Alpha Vantage免费版单次请求最多支持5个股票代码');
    }
  }

  private getApiKey(): string {
    const apiKey = process.env.ALPHA_VANTAGE_API_KEY;
    if (!apiKey) {
      throw new Error('请设置ALPHA_VANTAGE_API_KEY环境变量');
    }
    return apiKey;
  }

  private async fetchQuotes(symbols: string[], apiKey: string): Promise<any> {
    const quotes = [];
    
    // Alpha Vantage需要逐个请求股票数据
    for (const symbol of symbols) {
      const url = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${apiKey}`;
      
      const response = await fetch(url);
      const data = await response.json();
      
      if (data['Error Message']) {
        throw new Error(`Alpha Vantage API错误: ${data['Error Message']}`);
      }
      
      if (data['Note']) {
        throw new Error('Alpha Vantage API请求频率限制，请稍后重试');
      }
      
      quotes.push({
        symbol,
        rawData: data['Global Quote']
      });
      
      // 避免触发频率限制
      if (symbols.length > 1) {
        await this.sleep(200); // 200ms延迟
      }
    }
    
    return quotes;
  }

  private transformToStandardFormat(quotes: any[]): any[] {
    return quotes.map(quote => {
      const rawData = quote.rawData;
      
      return {
        symbol: quote.symbol,
        lastPrice: parseFloat(rawData['05. price']) || 0,
        change: parseFloat(rawData['09. change']) || 0,
        changePercent: parseFloat(rawData['10. change percent']?.replace('%', '')) || 0,
        volume: parseInt(rawData['06. volume']) || 0,
        high: parseFloat(rawData['03. high']) || 0,
        low: parseFloat(rawData['04. low']) || 0,
        open: parseFloat(rawData['02. open']) || 0,
        previousClose: parseFloat(rawData['08. previous close']) || 0,
        timestamp: rawData['07. latest trading day'],
        market: this.inferMarket(quote.symbol)
      };
    });
  }

  private inferMarket(symbol: string): string {
    // 简单的市场推断逻辑
    if (symbol.includes('.L') || symbol.includes('.LON')) {
      return 'UK';
    }
    return 'US';
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export default GetStockQuoteCapability;
```

#### WebSocket流能力示例

```typescript
// src/providers/alpha-vantage/capabilities/stream-real-time.ts
import { StreamCapability } from '../../decorators';
import { IStreamCapability, ConnectionStatus } from '../../interfaces/stream-capability.interface';

@StreamCapability({
  name: 'stream-real-time-quotes',
  provider: 'alpha-vantage',
  description: 'Alpha Vantage实时股价流（WebSocket）',
  markets: ['US'],
  type: 'websocket',
  priority: 3
})
export class StreamRealTimeQuotesCapability implements IStreamCapability {
  readonly name = 'stream-real-time-quotes';
  readonly supportedMarkets = ['US'];
  readonly supportedSymbolFormats = ['SYMBOL'];

  private wsConnection: WebSocket | null = null;
  private isConnectedFlag = false;
  private subscribers = new Set<string>();
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  async execute(request: any): Promise<any> {
    // 流能力通过connect/subscribe方式工作，而不是execute
    throw new Error('流能力请使用connect()和subscribe()方法');
  }

  async connect(): Promise<void> {
    if (this.isConnectedFlag) {
      return;
    }

    try {
      const apiKey = process.env.ALPHA_VANTAGE_API_KEY;
      if (!apiKey) {
        throw new Error('请设置ALPHA_VANTAGE_API_KEY环境变量');
      }

      // Alpha Vantage实际上不提供WebSocket，这里是示例代码
      // 实际使用时需要替换为真实的WebSocket URL
      const wsUrl = `wss://ws.alphavantage.co/stream?apikey=${apiKey}`;
      
      this.wsConnection = new WebSocket(wsUrl);
      
      this.wsConnection.onopen = () => {
        console.log('Alpha Vantage WebSocket连接已建立');
        this.isConnectedFlag = true;
        this.reconnectAttempts = 0;
      };

      this.wsConnection.onmessage = (event) => {
        this.handleMessage(event.data);
      };

      this.wsConnection.onerror = (error) => {
        console.error('Alpha Vantage WebSocket错误:', error);
      };

      this.wsConnection.onclose = () => {
        console.log('Alpha Vantage WebSocket连接已关闭');
        this.isConnectedFlag = false;
        this.attemptReconnect();
      };

      // 等待连接建立
      await this.waitForConnection();
    } catch (error) {
      throw new Error(`Alpha Vantage WebSocket连接失败: ${error.message}`);
    }
  }

  async disconnect(): Promise<void> {
    if (this.wsConnection) {
      this.wsConnection.close();
      this.wsConnection = null;
    }
    this.isConnectedFlag = false;
    this.subscribers.clear();
  }

  async subscribe(symbols: string[]): Promise<void> {
    if (!this.isConnectedFlag) {
      throw new Error('WebSocket未连接，请先调用connect()');
    }

    for (const symbol of symbols) {
      if (!this.subscribers.has(symbol)) {
        // 发送订阅消息
        const subscribeMessage = {
          action: 'subscribe',
          symbols: [symbol]
        };
        
        this.wsConnection?.send(JSON.stringify(subscribeMessage));
        this.subscribers.add(symbol);
        
        console.log(`已订阅股票: ${symbol}`);
      }
    }
  }

  async unsubscribe(symbols: string[]): Promise<void> {
    if (!this.isConnectedFlag) {
      return;
    }

    for (const symbol of symbols) {
      if (this.subscribers.has(symbol)) {
        // 发送取消订阅消息
        const unsubscribeMessage = {
          action: 'unsubscribe',
          symbols: [symbol]
        };
        
        this.wsConnection?.send(JSON.stringify(unsubscribeMessage));
        this.subscribers.delete(symbol);
        
        console.log(`已取消订阅股票: ${symbol}`);
      }
    }
  }

  isConnected(): boolean {
    return this.isConnectedFlag;
  }

  getConnectionStatus(): ConnectionStatus {
    return {
      status: this.isConnectedFlag ? 'connected' : 'disconnected',
      connectedAt: this.isConnectedFlag ? new Date() : null,
      errorCount: this.reconnectAttempts
    };
  }

  private handleMessage(data: string): void {
    try {
      const message = JSON.parse(data);
      
      // 处理实时价格数据
      if (message.type === 'quote') {
        const standardizedQuote = this.transformStreamData(message);
        
        // 触发数据事件（实际实现中需要事件发射器）
        console.log('收到实时报价:', standardizedQuote);
      }
    } catch (error) {
      console.error('处理WebSocket消息失败:', error);
    }
  }

  private transformStreamData(rawMessage: any): any {
    return {
      symbol: rawMessage.symbol,
      lastPrice: rawMessage.price,
      change: rawMessage.change,
      changePercent: rawMessage.changePercent,
      volume: rawMessage.volume,
      timestamp: new Date(rawMessage.timestamp),
      market: 'US'
    };
  }

  private async waitForConnection(): Promise<void> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('WebSocket连接超时'));
      }, 10000);

      const checkConnection = () => {
        if (this.isConnectedFlag) {
          clearTimeout(timeout);
          resolve();
        } else {
          setTimeout(checkConnection, 100);
        }
      };

      checkConnection();
    });
  }

  private attemptReconnect(): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`尝试重连 Alpha Vantage WebSocket (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      
      setTimeout(() => {
        this.connect().catch(error => {
          console.error('重连失败:', error);
        });
      }, 1000 * this.reconnectAttempts); // 递增延迟
    } else {
      console.error('Alpha Vantage WebSocket重连失败，已达到最大重试次数');
    }
  }
}

export default StreamRealTimeQuotesCapability;
```

### 步骤4: 创建类型定义

```typescript
// src/providers/alpha-vantage/types.ts

/**
 * Alpha Vantage 配置接口
 */
export interface AlphaVantageConfig {
  apiKey: string;
  baseUrl?: string;
  timeout?: number;
  retryAttempts?: number;
  rateLimitBuffer?: number; // 请求间隔缓冲时间(ms)
}

/**
 * Alpha Vantage API 原始响应格式
 */
export interface AlphaVantageQuoteResponse {
  'Global Quote': {
    '01. symbol': string;
    '02. open': string;
    '03. high': string;
    '04. low': string;
    '05. price': string;
    '06. volume': string;
    '07. latest trading day': string;
    '08. previous close': string;
    '09. change': string;
    '10. change percent': string;
  };
}

/**
 * Alpha Vantage 错误响应
 */
export interface AlphaVantageErrorResponse {
  'Error Message'?: string;
  'Note'?: string; // 频率限制提示
}

/**
 * Alpha Vantage WebSocket 消息格式
 */
export interface AlphaVantageStreamMessage {
  type: 'quote' | 'error' | 'heartbeat';
  symbol?: string;
  price?: number;
  change?: number;
  changePercent?: number;
  volume?: number;
  timestamp?: string;
  error?: string;
}

/**
 * 内部使用的标准化报价数据
 */
export interface StandardizedQuote {
  symbol: string;
  lastPrice: number;
  change: number;
  changePercent: number;
  volume: number;
  high: number;
  low: number;
  open: number;
  previousClose: number;
  timestamp: string;
  market: string;
}
```

### 步骤5: 创建NestJS模块

```typescript
// src/providers/alpha-vantage/module/alpha-vantage.module.ts
import { Module } from '@nestjs/common';
import { AlphaVantageProvider } from '../index';

@Module({
  providers: [AlphaVantageProvider],
  exports: [AlphaVantageProvider]
})
export class AlphaVantageModule {}
```

### 步骤6: 注册到主模块

```typescript
// src/providers/module/providers.module.ts
import { Module, OnModuleInit } from '@nestjs/common';
import { AuthModule } from '../../auth/module/auth.module';

// 导入现有模块
import { LongportModule } from '../longport/module/longport.module';
import { LongportSgModule } from '../longport-sg/module/longport-sg.module';

// 导入新模块
import { AlphaVantageModule } from '../alpha-vantage/module/alpha-vantage.module';

// 导入注册表服务
import { CapabilityRegistryService } from '../services/capability-registry.service';
import { EnhancedCapabilityRegistryService } from '../services/enhanced-capability-registry.service';

// 导入Provider实例
import { LongportProvider } from '../longport/longport.provider';
import { LongportSgProvider } from '../longport-sg/longport-sg.provider';
import { AlphaVantageProvider } from '../alpha-vantage';

// 导入控制器
import { ProvidersController } from '../controller/providers-controller';

@Module({
  imports: [
    AuthModule,
    LongportModule,
    LongportSgModule,
    AlphaVantageModule, // 添加新模块
  ],
  controllers: [ProvidersController],
  providers: [
    CapabilityRegistryService,
    EnhancedCapabilityRegistryService,
    {
      provide: 'ENHANCED_CAPABILITY_REGISTRY',
      useClass: EnhancedCapabilityRegistryService
    }
  ],
  exports: [CapabilityRegistryService, EnhancedCapabilityRegistryService],
})
export class ProvidersModule implements OnModuleInit {
  constructor(
    private readonly capabilityRegistry: CapabilityRegistryService,
    private readonly longportProvider: LongportProvider,
    private readonly longportSgProvider: LongportSgProvider,
    private readonly alphaVantageProvider: AlphaVantageProvider, // 注入新Provider
  ) {}

  async onModuleInit() {
    await this.registerProviders();
  }

  private async registerProviders(): Promise<void> {
    // 注册现有Provider
    this.capabilityRegistry.registerProvider(this.longportProvider);
    this.capabilityRegistry.registerProvider(this.longportSgProvider);
    
    // 注册新Provider
    this.capabilityRegistry.registerProvider(this.alphaVantageProvider);
  }
}
```

### 步骤7: 创建文档（可选）

```markdown
<!-- src/providers/alpha-vantage/README.md -->
# Alpha Vantage 数据源

Alpha Vantage是一个免费的股票API服务，提供全球股市数据。

## 支持的能力

- `get-stock-quote` - 获取股票实时报价
- `get-stock-basic-info` - 获取股票基本信息
- `stream-real-time-quotes` - 实时股价流（WebSocket）

## 配置说明

### 环境变量

```bash
# 必需：Alpha Vantage API密钥
export ALPHA_VANTAGE_API_KEY=your_api_key_here

# 可选：API基础URL（默认：https://www.alphavantage.co）
export ALPHA_VANTAGE_BASE_URL=https://www.alphavantage.co

# 可选：请求超时时间（默认：5000ms）
export ALPHA_VANTAGE_TIMEOUT=5000
```

### 获取API密钥

1. 访问 [Alpha Vantage](https://www.alphavantage.co/support/#api-key)
2. 免费注册账户
3. 获取API密钥
4. 设置环境变量

## 使用限制

- **免费版**: 每分钟5次请求，每天500次请求
- **付费版**: 更高的请求限制

## 使用示例

```bash
# 获取股票报价
curl -X POST http://localhost:3000/api/v1/receiver/data \
  -H "X-App-Key: YOUR_APP_KEY" \
  -H "X-Access-Token: YOUR_ACCESS_TOKEN" \
  -d '{
    "symbols": ["AAPL", "GOOGL"],
    "receiverType": "get-stock-quote",
    "options": {"preferredProvider": "alpha-vantage"}
  }'
```

## 注意事项

1. **请求频率**: 免费版有严格的频率限制，超出会返回错误
2. **市场支持**: 主要支持美国和英国市场
3. **符号格式**: 使用标准股票代码，如 AAPL、GOOGL
4. **WebSocket**: 示例代码中的WebSocket功能为演示用途，Alpha Vantage实际不提供WebSocket接口
```

## 🧪 测试和验证

### 1. 启动服务验证

```bash
# 启动开发服务器
bun run dev

# 查看启动日志，确认注册成功
# 应该看到类似信息：
# [EnhancedCapabilityRegistryService] 装饰器数据收集完成
# [ProvidersModule] Provider实例注册成功: alpha-vantage
```

### 2. API测试

```bash
# 1. 检查能力注册
curl http://localhost:3000/api/v1/providers/capabilities | grep alpha-vantage

# 2. 测试获取报价（需要设置API认证）
curl -X POST http://localhost:3000/api/v1/receiver/data \
  -H "X-App-Key: YOUR_APP_KEY" \
  -H "X-Access-Token: YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "symbols": ["AAPL"],
    "receiverType": "get-stock-quote"
  }'
```

### 3. 单元测试（可选）

```typescript
// src/providers/alpha-vantage/tests/alpha-vantage.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AlphaVantageProvider } from '../index';
import { GetStockQuoteCapability } from '../capabilities/get-stock-quote';

describe('AlphaVantageProvider', () => {
  let provider: AlphaVantageProvider;
  let capability: GetStockQuoteCapability;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AlphaVantageProvider, GetStockQuoteCapability],
    }).compile();

    provider = module.get<AlphaVantageProvider>(AlphaVantageProvider);
    capability = module.get<GetStockQuoteCapability>(GetStockQuoteCapability);
  });

  it('should be defined', () => {
    expect(provider).toBeDefined();
    expect(capability).toBeDefined();
  });

  it('should initialize successfully', async () => {
    await expect(provider.initialize()).resolves.not.toThrow();
  });

  it('should test connection', async () => {
    const result = await provider.testConnection();
    expect(typeof result).toBe('boolean');
  });
});
```

## 🎯 手动接入的优势

### 1. 完全控制

- **精确配置**: 可以精确控制每个配置项
- **自定义结构**: 可以根据需要调整目录结构
- **特殊需求**: 可以实现特殊的业务逻辑

### 2. 学习价值

- **深入理解**: 完全理解装饰器系统的工作原理
- **调试能力**: 遇到问题时能够快速定位和解决
- **扩展能力**: 具备扩展和修改系统的能力

### 3. 灵活性

- **渐进实现**: 可以逐步实现各个能力
- **自定义装饰器**: 可以根据需要创建自定义装饰器
- **高级功能**: 可以实现复杂的业务逻辑

## 🚨 常见问题

### 1. 装饰器不生效

**问题**: 能力或提供商未被系统发现

**原因**: 
- 装饰器语法错误
- 文件路径不正确
- 模块未正确注册

**解决**:
```typescript
// 确保装饰器语法正确
@Provider({
  name: 'alpha-vantage', // 必需
  description: '...'     // 推荐
})

// 确保正确实现接口
export class AlphaVantageProvider implements IDataProvider {
  // 必须实现所有接口方法
}
```

### 2. 自动推断失败

**问题**: 提供商名称推断不正确

**解决**: 明确指定提供商名称
```typescript
@Capability({
  name: 'get-stock-quote',
  provider: 'alpha-vantage', // 明确指定，不依赖推断
})
```

### 3. Provider实例未注册

**问题**: 运行时找不到Provider实例

**解决**: 确保在ProvidersModule中完成三个步骤
```typescript
@Module({
  imports: [AlphaVantageModule], // 1. 导入模块
})
export class ProvidersModule {
  constructor(
    private readonly alphaVantageProvider: AlphaVantageProvider, // 2. 注入实例
  ) {}

  private async registerProviders(): Promise<void> {
    this.capabilityRegistry.registerProvider(this.alphaVantageProvider); // 3. 注册实例
  }
}
```

## 📋 手动接入检查清单

- [ ] **目录结构**: 创建了完整的提供商目录结构
- [ ] **主Provider类**: 使用@Provider装饰器，实现IDataProvider接口
- [ ] **能力实现**: 使用@Capability装饰器，实现ICapability接口
- [ ] **类型定义**: 创建了完整的TypeScript类型定义
- [ ] **NestJS模块**: 创建了模块文件并正确导出Provider
- [ ] **模块注册**: 在ProvidersModule中导入、注入、注册
- [ ] **环境配置**: 设置了必要的环境变量
- [ ] **业务逻辑**: 实现了具体的API调用和数据转换逻辑
- [ ] **错误处理**: 添加了完善的错误处理机制
- [ ] **测试验证**: 通过启动日志和API调用验证功能正常

## 📚 进阶主题

### 1. 自定义装饰器

```typescript
// 创建专用于特定数据源的装饰器
export function AlphaVantageCapability(metadata: Partial<CapabilityMetadata>) {
  return Capability({
    provider: 'alpha-vantage',
    markets: ['US', 'UK'],
    ...metadata
  });
}

// 使用自定义装饰器
@AlphaVantageCapability({
  name: 'get-earnings-data',
  description: '获取财报数据'
})
export class GetEarningsCapability implements ICapability {
  // ...
}
```

### 2. 复杂配置管理

```typescript
@Provider({
  name: 'alpha-vantage',
  config: {
    endpoints: {
      quote: '/query?function=GLOBAL_QUOTE',
      fundamentals: '/query?function=OVERVIEW',
      earnings: '/query?function=EARNINGS'
    },
    rateLimits: {
      free: { perMinute: 5, perDay: 500 },
      premium: { perMinute: 75, perDay: 75000 }
    }
  }
})
```

### 3. 依赖注入集成

```typescript
@Provider({
  name: 'alpha-vantage'
})
@Injectable()
export class AlphaVantageProvider implements IDataProvider {
  constructor(
    @Inject('CONFIG_SERVICE') private configService: ConfigService,
    @Inject('CACHE_SERVICE') private cacheService: CacheService,
    @Inject('METRICS_SERVICE') private metricsService: MetricsService,
  ) {}
}
```

---

*手动接入方式提供了最大的灵活性和控制力，适合需要深度定制或学习系统内部机制的开发者。如果您需要快速接入，建议使用CLI工具方式。*