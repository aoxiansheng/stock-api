需要剥离的常量识别

  Alert系统专属常量

  应该剥离到: src/alert/constants/

  1. ALERT_MESSAGES (49次外部引用)
    - 外部引用位置：
        - alert/constants/composite/index.ts
      - alert/services/alerting.service.ts
      - alert/services/rule-engine.service.ts
    - 剥离原因：仅被alert组件使用，属于alert领域专属
  2. AlertSeverity (30次外部引用)
    - 外部引用位置：
        - alert/dto/alert-rule.dto.ts
      - alert/dto/alert.dto.ts
      - alert/schemas/alert-history.schema.ts
      - alert/schemas/alert-rule.schema.ts
      - alert/services/notification-senders/slack.sender.ts
      - alert/interfaces/alert.interface.ts
    - 剥离原因：完全是alert系统的业务常量
  3. AlertStatus (40次外部引用)
    - 外部引用位置：全部在alert目录下
    - 剥离原因：alert状态枚举，应属于alert模块

  Core组件专属常量

  应该剥离到: src/core/shared/constants/

  4. CORE_LIMITS (37次外部引用)
    - 外部引用位置：
        - core/00-prepare/data-mapper/constants/
      - core/02-processing/transformer/constants/
      - alert/constants/core/ (这部分保留引用)
    - 剥离原因：主要被core组件使用

  Auth系统专属常量

  应该剥离到: src/auth/constants/

  5. RateLimitStrategy (18次外部引用)
    - 外部引用位置：
        - core/01-entry/stream-receiver/guards/ws-auth.guard.ts
      - auth/services/rate-limit.service.ts
      - auth/guards/rate-limit.guard.ts
      - auth/interfaces/rate-limit.interface.ts
    - 剥离原因：主要被auth和相关guard使用

  Cache系统专属常量

  应该剥离到: src/cache/constants/

  6. CACHE_TTL_SEMANTICS (2次外部引用)
    - 外部引用位置：cache/constants/cache.constants.ts
    - 剥离原因：仅被cache组件使用

  Monitoring系统专属常量

  应该剥离到: src/monitoring/constants/

  7. MONITORING_BUSINESS (13次外部引用)
    - 外部引用位置：
        - core/03-fetching/stream-data-fetcher/services/
      - core/01-entry/stream-receiver/services/
      - monitoring/analyzer/ (多个文件)
    - 剥离原因：主要被monitoring组件使用

⏺ 🚀 剥离策略设计

  剥离判断标准

  1. 单组件主导: 外部引用80%以上来自同一个组件
  2. 业务专属性: 常量与特定业务领域强绑定
  3. 逻辑内聚: 常量定义和使用逻辑属于同一模块

  目标剥离架构

  Alert模块 (src/alert/constants/)

  src/alert/constants/
  ├── severity.ts          # AlertSeverity
  ├── status.ts            # AlertStatus
  ├── messages.ts          # ALERT_MESSAGES
  └── index.ts            # Alert模块统一导出

  Auth模块 (src/auth/constants/)

  src/auth/constants/
  ├── rate-limit.ts        # RateLimitStrategy
  └── index.ts            # Auth模块统一导出

  Core模块 (src/core/shared/constants/)

  src/core/shared/constants/
  ├── limits.ts            # CORE_LIMITS
  └── index.ts            # Core模块统一导出

  Cache模块 (src/cache/constants/)

  src/cache/constants/
  ├── ttl-semantics.ts     # CACHE_TTL_SEMANTICS
  └── index.ts            # Cache模块统一导出

  Monitoring模块 (src/monitoring/constants/)

  src/monitoring/constants/
  ├── business.ts          # MONITORING_BUSINESS
  └── index.ts            # Monitoring模块统一导出

  跨组件引用处理

  对于剥离后仍需要跨组件引用的情况：

  // 例如: core组件需要使用alert常量
  // ❌ 错误做法 - 直接引用
  import { AlertSeverity } from '@/alert/constants';

  // ✅ 正确做法 - 通过接口/类型定义
  // alert/types/index.ts
  export type AlertSeverityType = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';

  // core组件使用类型而非常量
  import type { AlertSeverityType } from '@/alert/types';

⏺ 🚀 常量剥离策略

  剥离判断标准

  1. 单一组件主导：80%以上外部引用来自同一组件/模块
  2. 业务域相关性：常量语义与特定业务域强相关
  3. 依赖方向：常量系统不应依赖具体业务模块

  目标位置映射

  现有位置 → 目标位置

  # Alert相关常量
  common/constants/domain/alert-domain.constants.ts → src/alert/constants/
  ├── ALERT_MESSAGES → alert/constants/messages.ts
  ├── AlertSeverity → alert/constants/enums.ts  
  └── AlertStatus → alert/constants/enums.ts

  # Auth相关常量
  common/constants/domain/rate-limit-domain.constants.ts → src/auth/constants/
  └── RateLimitStrategy → auth/constants/rate-limit.ts

  # Cache相关常量
  common/constants/semantic/cache-semantics.constants.ts → src/cache/constants/
  └── CACHE_TTL_SEMANTICS → cache/constants/ttl.ts

  # Monitoring相关常量
  common/constants/domain/monitoring-business.constants.ts → src/monitoring/constants/
  └── MONITORING_BUSINESS → monitoring/constants/business.ts

  # Core相关常量（部分剥离）
  common/constants/foundation/core-limits.constants.ts → src/core/shared/constants/
  └── CORE_LIMITS → core/shared/constants/limits.ts

  剥离后的导入模式

  // ❌ 剥离前（从常量系统导入）
  import { AlertSeverity } from '@/common/constants';

  // ✅ 剥离后（从业务模块导入）
  import { AlertSeverity } from '@/alert/constants';

⏺ 📋 更新后的架构设计

  🎯 新的常量分层原则

  1. 真正的通用常量层 (共享基础设施)

  src/common/constants/shared/
  ├── numeric.ts                 # NUMERIC_CONSTANTS (252次, 跨多组件)
  ├── market.ts                  # Market, MarketStatus (184+64次, 跨多组件) 
  ├── reference-data.ts          # REFERENCE_DATA (239次, 跨多组件)
  ├── operations.ts              # API_OPERATIONS (61次, 跨多组件)
  ├── application-config.ts      # default (166次, 跨多组件)
  └── index.ts
  标准：被3个以上不同组件/模块使用，且无明显业务域归属

  2. 组内常量层 (常量系统内部)

  src/common/constants/internal/
  ├── http-semantics/
  │   ├── status.ts             # HTTP_STATUS_SEMANTICS (仅内部使用)
  │   ├── timeouts.ts           # HTTP_TIMEOUTS (仅内部使用)
  │   └── headers.ts            
  ├── retry-semantics/
  │   ├── delays.ts             # RETRY_DELAY_SEMANTICS (仅内部使用)
  │   └── templates.ts          
  ├── message-semantics/
  │   └── templates.ts          # MESSAGE_TEMPLATE_FUNCTIONS (仅内部使用)
  └── index.ts
  标准：仅在常量系统内部使用，不被外部组件直接引用

  3. 业务模块专属常量 (剥离到各自模块)

  # Alert模块常量
  src/alert/constants/
  ├── enums.ts                  # AlertSeverity, AlertStatus
  ├── messages.ts               # ALERT_MESSAGES
  └── index.ts

  # Auth模块常量  
  src/auth/constants/
  ├── rate-limit.ts             # RateLimitStrategy
  └── index.ts

  # Cache模块常量
  src/cache/constants/ 
  ├── ttl.ts                    # CACHE_TTL_SEMANTICS
  └── index.ts

  # Monitoring模块常量
  src/monitoring/constants/
  ├── business.ts               # MONITORING_BUSINESS
  └── index.ts

  # Core模块常量
  src/core/shared/constants/
  ├── limits.ts                 # CORE_LIMITS
  └── index.ts

  📊 剥离效果分析

  剥离前后对比

  | 位置                     | 剥离前常量数 | 剥离后常量数 | 减少比例 |
  |------------------------|--------|--------|------|
  | common/constants/      | 156    | ~80    | 49%  |
  | alert/constants/       | 0      | 10+    | 新增   |
  | auth/constants/        | 0      | 5+     | 新增   |
  | cache/constants/       | 0      | 3+     | 新增   |
  | monitoring/constants/  | 0      | 5+     | 新增   |
  | core/shared/constants/ | 0      | 8+     | 新增   |

  架构收益

  1. 职责清晰：常量归属明确，不存在跨边界依赖
  2. 维护成本低：修改业务常量不影响其他组件
  3. 导入路径直观：从使用的模块导入，语义清晰
  4. 循环依赖消除：业务常量不再通过common层传递

  🚀 实施优先级

  第一阶段：高优先级剥离

  1. Alert相关常量 → src/alert/constants/
  2. Auth相关常量 → src/auth/constants/
  3. 删除3个未使用常量

  第二阶段：中优先级剥离

  1. Cache相关常量 → src/cache/constants/
  2. Monitoring相关常量 → src/monitoring/constants/

  第三阶段：重构优化

  1. Core相关常量部分剥离
  2. 清理单引用工具函数
  3. 优化导出结构

⏺ ✅ 修正后的架构方案总结

  你的观点完全正确！按照"被引用常量被外部同一个组件使用，应该彻底剥离到外部组件"的原则，我重新设计了架构：

  🎯 核心改进

  1. 常量系统瘦身：从156个常量减少到~80个（49%减少）
  2. 业务常量剥离：Alert、Auth、Cache、Monitoring、Core等模块的专属常量全部剥离
  3. 真正的通用性：保留的常量都是被多个不同组件使用的基础设施常量
  4. 消除循环依赖：业务常量不再通过common层传递，直接在各自模块管理

  📋 剥离清单

  - Alert系统：AlertSeverity、AlertStatus、ALERT_MESSAGES → src/alert/constants/
  - Auth系统：RateLimitStrategy → src/auth/constants/
  - Cache系统：CACHE_TTL_SEMANTICS → src/cache/constants/
  - Monitoring系统：MONITORING_BUSINESS → src/monitoring/constants/
  - Core系统：CORE_LIMITS → src/core/shared/constants/

  🏗️ 最终架构

  - 共享层：仅保留真正跨组件的基础设施常量（数值、市场、引用数据等）
  - 内部层：常量系统内部的语义常量（HTTP、重试、消息语义等）
  - 业务层：各业务模块管理自己的专属常量

  这样的架构完全符合你提出的原则，实现了职责清晰、维护简单、无循环依赖的目标。