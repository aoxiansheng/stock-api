/**
 * CoreÊ®°ÂùóÈõÜÊàêÊµãËØï
 * ÊµãËØï6‰∏™Ê†∏ÂøÉÁªÑ‰ª∂ÁöÑÂÆåÊï¥ÈõÜÊàêÂíåÂçè‰Ωú
 */

import { INestApplication } from "@nestjs/common";
import { getModelToken } from "@nestjs/mongoose";
import { Model } from "mongoose";
import * as request from "supertest";
import { TestDataHelper } from "../../../../../../test/config/integration.setup";

// ÂØºÂÖ•Ê†∏ÂøÉÊúçÂä°‰ª•‰æøÁõ¥Êé•ÊµãËØï

import { DataMapperService } from "../../../../../../src/core/data-mapper/services/data-mapper.service";
import { CapabilityRegistryService } from "../../../../../../src/providers/services/capability-registry.service";
// ÂÖ∂‰ªñÊúçÂä°ÊåâÈúÄÂØºÂÖ•

describe("Core Modules Integration Tests", () => {
  let app: INestApplication;
  let httpServer: any;
  let userModel: Model<any>;
  let apiKeyModel: Model<any>;
  let symbolMappingModel: Model<any>;
  let dataMappingModel: Model<any>;
  let testApiKey: any;

  // Ê†∏ÂøÉÊúçÂä°ÂÆû‰æã
  let dataMapperService: DataMapperService;
  let capabilityRegistryService: CapabilityRegistryService;

  beforeAll(() => {
    app = (global as any).testApp;
    httpServer = app.getHttpServer();
    userModel = app.get(getModelToken("User"));
    apiKeyModel = app.get(getModelToken("ApiKey"));
    symbolMappingModel = app.get(getModelToken("SymbolMappingRuleDocument"));
    dataMappingModel = app.get(getModelToken("DataMappingRule"));

    // Ëé∑ÂèñÊ†∏ÂøÉÊúçÂä°ÂÆû‰æãÁî®‰∫éÂÜÖÈÉ®ÊµãËØï
    dataMapperService = app.get<DataMapperService>(DataMapperService);
    capabilityRegistryService = app.get<CapabilityRegistryService>(
      CapabilityRegistryService,
    );
  });

  beforeEach(async () => {
    // ‰∏∫ÊØè‰∏™ÊµãËØïÂàõÂª∫ÊµãËØïÁî®Êà∑ÂíåAPIÂØÜÈí•
    const user = await TestDataHelper.createTestUser(userModel, {
      username: `coreuser-${Date.now()}-${Math.random()}`,
      email: `core-${Date.now()}@test.com`,
      role: "admin",
    });

    testApiKey = await TestDataHelper.createFullAccessApiKey(
      apiKeyModel,
      user.id,
      {
        rateLimit: {
          requests: 1000,
          window: "1h",
        },
      },
    );
  });

  afterEach(() => {
    // Á°Æ‰øùÂú®ÊØè‰∏™ÊµãËØïÂêéÊÅ¢Â§çÊâÄÊúâÊ®°Êãü
    jest.restoreAllMocks();
  });

  describe("üéØ Receiver Module - Á≥ªÁªüÂÖ•Âè£ÁÇπ", () => {
    let uniqueDataSourceName: string;

    beforeEach(async () => {
      uniqueDataSourceName = `longport-r-${Date.now()}`; // 'r' for receiver

      // Ê®°ÊãüËÉΩÂäõÊ≥®ÂÜåË°®ÔºåÈò≤Ê≠¢ÊúçÂä°ÂõûÈÄÄÂà∞ÈªòËÆ§ provider
      jest
        .spyOn(capabilityRegistryService, "getCapability")
        .mockImplementation((provider, capability) => {
          if (provider === uniqueDataSourceName) {
            return {
              name: capability,
              description: "Mocked capability for receiver test",
              supportedMarkets: ["HK", "US", "CN"],
              supportedSymbolFormats: ["SYMBOL.MARKET", "SYMBOL"],
              rateLimit: {
                requestsPerSecond: 10,
                requestsPerDay: 10000,
              },
              execute: jest.fn().mockResolvedValue([]), // Ê®°ÊãüÊàêÂäüÊâßË°åÔºåËøîÂõûÁ©∫Êï∞ÊçÆ
            } as any;
          }
          // ÂØπ‰∫éÈùûÊ®°ÊãüÁöÑ providerÔºåË∞ÉÁî®ÂéüÂßãÂÆûÁé∞
          return jest
            .requireActual(
              "../../../../src/providers/capability-registry.service",
            )
            .CapabilityRegistryService.prototype.getCapability.call(
              capabilityRegistryService,
              provider,
              capability,
            );
        });

      // ÂàõÂª∫Á¨¶Âè∑Êò†Â∞ÑËßÑÂàô
      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: uniqueDataSourceName,
        SymbolMappingRule: [
          { inputSymbol: "700.HK", outputSymbol: "00700", market: "HK" },
          { inputSymbol: "AAPL.US", outputSymbol: "AAPL", market: "US" },
          { inputSymbol: "AMD.US", outputSymbol: "AMD", market: "US" },
        ],
      });
    });

    it("Â∫îËØ•Â§ÑÁêÜÂÆåÊï¥ÁöÑËÇ°Á•®Êï∞ÊçÆËØ∑Ê±ÇÊµÅÁ®ã", async () => {
      const dataRequest = {
        symbols: ["700.HK", "AAPL.US"],
        receiverType: "get-stock-quote",
        options: { preferredProvider: uniqueDataSourceName },
      };

      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(dataRequest)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(response.body.data.metadata.provider).toBe(uniqueDataSourceName);
      expect(response.body.data.data).toEqual([]); // È™åËØÅËøîÂõû‰∫ÜÊ®°ÊãüÁöÑÁ©∫Êï∞ÁªÑ
    });

    it("Â∫îËØ•Ê≠£Á°ÆËØÜÂà´Ê∑∑ÂêàÂ∏ÇÂú∫ËÇ°Á•®‰ª£Á†Å", async () => {
      const mixedMarketRequest = {
        symbols: ["700.HK", "AAPL.US", "AMD.US"],
        receiverType: "get-stock-quote",
        options: { preferredProvider: uniqueDataSourceName },
      };

      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(mixedMarketRequest)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(response.body.data.metadata.provider).toBe(uniqueDataSourceName);
    });

    it("Â∫îËØ•Â§ÑÁêÜÂü∫Êú¨‰ø°ÊÅØÊï∞ÊçÆËØ∑Ê±Ç", async () => {
      const basicInfoRequest = {
        symbols: ["700.HK"],
        receiverType: "get-stock-basic-info",
        options: { preferredProvider: uniqueDataSourceName },
      };

      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(basicInfoRequest)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(response.body.data.metadata.provider).toBe(uniqueDataSourceName);
    });

    it("Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜÊó†ÊïàÁöÑÊï∞ÊçÆÁ±ªÂûãËØ∑Ê±Ç", async () => {
      const invalidReceiverTypeRequest = {
        symbols: ["700.HK"],
        receiverType: "invalid-capability-type",
      };

      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(invalidReceiverTypeRequest)
        .expect(400);

      expect(response.body.statusCode).toBe(400);
      expect(response.body.message).toContain("‰∏çÊîØÊåÅÁöÑËÉΩÂäõÁ±ªÂûã");
    });

    it("Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜÁ©∫ËÇ°Á•®‰ª£Á†ÅÂàóË°®", async () => {
      const emptySymbolsRequest = {
        symbols: [],
        receiverType: "get-stock-quote",
      };

      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(emptySymbolsRequest)
        .expect(400);

      expect(response.body.statusCode).toBe(400);
      expect(response.body.message).toContain("ËÇ°Á•®‰ª£Á†ÅÂàóË°®‰∏çËÉΩ‰∏∫Á©∫");
    });
  });

  describe("üîÄ Symbol Mapping Module", () => {
    it("should create symbol mapping configuration", async () => {
      const mappingData = {
        dataSourceName: "test-provider",
        description: "Test mapping configuration",
        SymbolMappingRule: [
          {
            inputSymbol: "700.HK",
            outputSymbol: "00700.HK",
            market: "HK",
            symbolType: "stock",
            isActive: true,
          },
          {
            inputSymbol: "AAPL",
            outputSymbol: "AAPL.US",
            market: "US",
            symbolType: "stock",
            isActive: true,
          },
        ],
      };

      const response = await request(httpServer)
        .post("/api/v1/symbol-mapper")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(mappingData)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(response.body.data).toHaveProperty("id");
      expect(response.body.data.dataSourceName).toBe(
        mappingData.dataSourceName,
      );
      expect(response.body.data.SymbolMappingRule).toHaveLength(2);

      // Verify in database
      const savedMapping = await symbolMappingModel.findById(
        response.body.data.id,
      );
      expect(savedMapping).toBeTruthy();
      expect(savedMapping.SymbolMappingRule).toHaveLength(2);
    });

    it("should transform symbols using mapping rules", async () => {
      // Create symbol mapping first
      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: "longport",
        SymbolMappingRule: [
          {
            inputSymbol: "700.HK",
            outputSymbol: "00700",
            market: "HK",
            symbolType: "stock",
            isActive: true,
          },
          {
            inputSymbol: "AAPL.US",
            outputSymbol: "AAPL",
            market: "US",
            symbolType: "stock",
            isActive: true,
          },
        ],
      });

      const transformRequest = {
        dataSourceName: "longport",
        symbols: ["700.HK", "AAPL.US"],
      };

      const response = await request(httpServer)
        .post("/api/v1/symbol-mapper/transform")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(transformRequest)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(response.body.data).toHaveProperty("dataSourceName", "longport");
      expect(response.body.data).toHaveProperty("transformedSymbols");
      expect(response.body.data).toHaveProperty("processingTimeMs");

      const transformedSymbols = response.body.data.transformedSymbols;
      expect(transformedSymbols["700.HK"]).toBe("00700");
      expect(transformedSymbols["AAPL.US"]).toBe("AAPL");
    });

    it("should list available data sources", async () => {
      // Create multiple symbol mappings
      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: "longport",
      });
      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: "futu",
      });

      const response = await request(httpServer)
        .get("/api/v1/symbol-mapper/data-sources")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(Array.isArray(response.body.data)).toBe(true);
      expect(response.body.data).toContain("longport");
      expect(response.body.data).toContain("futu");
    });

    it("should handle symbol mapping with pagination", async () => {
      // Create multiple mappings
      for (let i = 0; i < 15; i++) {
        await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
          dataSourceName: `provider-${i}`,
        });
      }

      const response = await request(httpServer)
        .get("/api/v1/symbol-mapper?page=1&limit=10")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      const responseData = response.body.data;
      expect(responseData).toHaveProperty("items");
      expect(responseData).toHaveProperty("pagination");
      expect(Array.isArray(responseData.items)).toBe(true);
      expect(responseData.items).toHaveLength(10);
      expect(responseData.items[0]).toHaveProperty("dataSourceName");
    });
  });

  describe("Data Mapping Module", () => {
    it("should create data mapping rules", async () => {
      const mappingData = {
        name: "LongPort Stock Quote Mapping",
        provider: "longport",
        transDataRuleListType: "quote_fields",
        description: "Maps LongPort stock quote data to standard format",
        sharedDataFieldMappings: [
          {
            sourceField: "last_done",
            targetField: "lastPrice",
          },
          {
            sourceField: "volume",
            targetField: "volume",
          },
        ],
      };

      const response = await request(httpServer)
        .post("/api/v1/data-mapper")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(mappingData)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(response.body.data).toHaveProperty("id");
      expect(response.body.data.name).toBe(mappingData.name);
      expect(response.body.data.sharedDataFieldMappings).toHaveLength(2);

      // Verify in database
      const savedMapping = await dataMappingModel.findById(
        response.body.data.id,
      );
      expect(savedMapping).toBeTruthy();
      expect(savedMapping.sharedDataFieldMappings).toHaveLength(2);
    });

    it("should retrieve mapping rules by provider and type", async () => {
      await TestDataHelper.createTestDataMapping(dataMappingModel, {
        provider: "longport",
        transDataRuleListType: "quote_fields",
        sharedDataFieldMappings: [],
      });

      const response = await request(httpServer)
        .get("/api/v1/data-mapper/best-match/longport/quote_fields")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(response.body.data).toHaveProperty("provider", "longport");
      expect(response.body.data).toHaveProperty("transDataRuleListType", "quote_fields");
      expect(response.body.data).toHaveProperty("id");
      expect(response.body.data).toHaveProperty("name");
    });

    it("should suggest field mappings", async () => {
      const suggestionRequest = {
        sourceFields: [
          "symbol",
          "last_done",
          "volume",
          "turnover",
          "pre_close",
        ],
        targetFields: [
          "symbol",
          "lastPrice",
          "volume",
          "turnover",
          "previousClosePrice",
        ],
      };

      const response = await request(httpServer)
        .post("/api/v1/data-mapper/field-suggestions")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(suggestionRequest)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(response.body.data).toHaveProperty("suggestions");
      expect(Array.isArray(response.body.data.suggestions)).toBe(true);

      const suggestions = response.body.data.suggestions;
      expect(suggestions.some((s) => s.sourceField === "last_done")).toBe(true);
      expect(suggestions.some((s) => s.sourceField === "volume")).toBe(true);
    });

    it("should parse JSON data structures", async () => {
      const parseRequest = {
        jsonData: {
          secu_quote: [
            {
              symbol: "700.HK",
              last_done: 503.0,
              volume: 1000000,
            },
          ],
          basic_info: [
            {
              symbol: "700.HK",
              name: "Tencent Holdings",
              industry: "Technology",
            },
          ],
        },
      };

      const response = await request(httpServer)
        .post("/api/v1/data-mapper/parse-json")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(parseRequest)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(response.body.data).toHaveProperty("structure");
      expect(response.body.data).toHaveProperty("fields");
      expect(Array.isArray(response.body.data.fields)).toBe(true);

      const fields = response.body.data.fields;
      expect(fields.some((f) => f.includes("secu_quote"))).toBe(true);
      expect(fields.some((f) => f.includes("basic_info"))).toBe(true);
    });
  });

  describe("üîÑ Cross-Module Integration - Ë∑®Ê®°ÂùóÂçè‰Ωú", () => {
    let uniqueDataSourceName: string;

    beforeEach(async () => {
      uniqueDataSourceName = `longport-x-${Date.now()}`; // 'x' for cross-module

      jest
        .spyOn(capabilityRegistryService, "getCapability")
        .mockImplementation((provider, capabilityName) => {
          if (provider === uniqueDataSourceName) {
            return {
              name: capabilityName,
              description: "Mocked capability for cross-module test",
              supportedMarkets: ["HK", "US", "CN"],
              supportedSymbolFormats: ["SYMBOL.MARKET", "SYMBOL"],
              rateLimit: {
                requestsPerSecond: 10,
                requestsPerDay: 10000,
              },
              execute: jest
                .fn()
                .mockResolvedValue([{ symbol: "AAPL.US", price: 151 }]), // Return some data
            } as any;
          }
          return jest
            .requireActual(
              "../../../../src/providers/capability-registry.service",
            )
            .CapabilityRegistryService.prototype.getCapability.call(
              capabilityRegistryService,
              provider,
              capabilityName,
            );
        });

      // ‰∏∫Symbol MapperÂàõÂª∫ËßÑÂàô
      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: uniqueDataSourceName,
        SymbolMappingRule: [
          { inputSymbol: "AAPL.US", outputSymbol: "AAPL-LP" },
          { inputSymbol: "700.HK", outputSymbol: "700-LP" },
        ],
      });

      // ‰∏∫Data MapperÂàõÂª∫ËßÑÂàô - ‰∏∫transformerÂÖºÂÆπÂàõÂª∫‰∏§ÁßçÊò†Â∞ÑËßÑÂàô
      await TestDataHelper.createTestDataMapping(dataMappingModel, {
        provider: uniqueDataSourceName,
        transDataRuleListType: TestDataHelper.mapReceiverTypeToRuleListType("stock-quote"), // Ê≠£Á°ÆÁöÑÂÄº: quote_fields
        sharedDataFieldMappings: [
          { sourceField: "price", targetField: "lastPrice" },
          { sourceField: "size", targetField: "volume" },
        ],
      });

      // Ê®°ÊãüdataMapperService.findBestMatchingRule‰ª•Â§ÑÁêÜ receiverType Âà∞ruleListTypeÁöÑÊò†Â∞Ñ
      const originalFindBestMatchingRule =
        dataMapperService.findBestMatchingRule;
      jest
        .spyOn(dataMapperService, "findBestMatchingRule")
        .mockImplementation(async (provider: string, transDataRuleListType: string) => {
          // Â¶ÇÊûúËØ∑Ê±ÇÁöÑÊòØ receiverType Ê†ºÂºèÔºåËΩ¨Êç¢‰∏∫Ê≠£Á°ÆÁöÑruleListType
          const mappedRuleListType =
            TestDataHelper.mapReceiverTypeToRuleListType(transDataRuleListType);
          return await originalFindBestMatchingRule.call(
            dataMapperService,
            provider,
            mappedRuleListType,
          );
        });
    });

    it("Â∫îËØ•ÂÆåÊàêÂÆåÊï¥ÁöÑÊï∞ÊçÆËØ∑Ê±ÇÁîüÂëΩÂë®Êúü", async () => {
      const dataRequest = {
        symbols: ["AAPL.US"],
        receiverType: "get-stock-quote",
        options: { preferredProvider: uniqueDataSourceName },
      };

      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(dataRequest)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(response.body.data.metadata.provider).toBe(uniqueDataSourceName);
      expect(response.body.data.data).toEqual([
        { symbol: "AAPL.US", price: 151 },
      ]);
    });

    it("Â∫îËØ•Âú®Symbol MapperÂíåData Mapper‰πãÈó¥‰øùÊåÅÊï∞ÊçÆ‰∏ÄËá¥ÊÄß", async () => {
      const transformRequest = {
        provider: uniqueDataSourceName,
        transDataRuleListType: "quote_fields",
        rawData: { price: 503.0, size: 1000000, symbol: "AAPL-LP" },
      };

      const dataTransformResponse = await request(httpServer)
        .post("/api/v1/transformer/transform")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(transformRequest)
        .expect(201);

      expect(dataTransformResponse.body.statusCode).toBe(201);
      expect(dataTransformResponse.body.data).toHaveProperty("transformedData");
      expect(dataTransformResponse.body.data.transformedData[0]).toHaveProperty(
        "lastPrice",
        503.0,
      );
      expect(dataTransformResponse.body.data.transformedData[0]).toHaveProperty(
        "volume",
        1000000,
      );
    });

    it("Â∫îËØ•Âú®È´òÂπ∂ÂèëÊÉÖÂÜµ‰∏ã‰øùÊåÅÊï∞ÊçÆ‰∏ÄËá¥ÊÄß", async () => {
      const dataRequest = {
        symbols: ["AAPL.US"],
        receiverType: "get-stock-quote",
        options: { preferredProvider: uniqueDataSourceName },
      };

      const concurrentRequests = 5;
      const requests = Array.from({ length: concurrentRequests }, () =>
        request(httpServer)
          .post("/api/v1/receiver/data")
          .set("X-App-Key", testApiKey.appKey)
          .set("X-Access-Token", testApiKey.accessToken)
          .send(dataRequest),
      );

      const responses = await Promise.all(requests);

      responses.forEach((response) => {
        expect(response.status).toBe(200);
        expect(response.body.data.metadata.provider).toBe(uniqueDataSourceName);
      });

      const requestIds = responses.map((r) => r.body.data.metadata.requestId);
      const uniqueRequestIds = [...new Set(requestIds)];
      expect(uniqueRequestIds).toHaveLength(requestIds.length);
    });
  });

  describe("üîß Transformer Module", () => {
    let uniqueDataSourceName: string;
    beforeEach(async () => {
      uniqueDataSourceName = `longport-t-${Date.now()}`; // 't' for transformer

      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: uniqueDataSourceName,
        SymbolMappingRule: [{ inputSymbol: "700.HK", outputSymbol: "700-LP" }],
      });
      await TestDataHelper.createTestDataMapping(dataMappingModel, {
        provider: uniqueDataSourceName,
        transDataRuleListType: TestDataHelper.mapReceiverTypeToRuleListType("stock-quote"), // Ê≠£Á°ÆÁöÑÂÄº: quote_fields
        sharedDataFieldMappings: [
          { sourceField: "last_price", targetField: "lastPrice" },
          { sourceField: "vol", targetField: "volume" },
        ],
      });

      // Ê®°ÊãüdataMapperService.findBestMatchingRule‰ª•Â§ÑÁêÜ receiverType Âà∞ruleListTypeÁöÑÊò†Â∞Ñ
      const originalFindBestMatchingRule =
        dataMapperService.findBestMatchingRule;
      jest
        .spyOn(dataMapperService, "findBestMatchingRule")
        .mockImplementation(async (provider: string, transDataRuleListType: string) => {
          // Â¶ÇÊûúËØ∑Ê±ÇÁöÑÊòØ receiverType Ê†ºÂºèÔºåËΩ¨Êç¢‰∏∫Ê≠£Á°ÆÁöÑruleListType
          const mappedRuleListType =
            TestDataHelper.mapReceiverTypeToRuleListType(transDataRuleListType);
          return await originalFindBestMatchingRule.call(
            dataMapperService,
            provider,
            mappedRuleListType,
          );
        });
    });

    it("should transform data using mapping rules", async () => {
      const transformRequest = {
        provider: uniqueDataSourceName,
        transDataRuleListType: "quote_fields",
        rawData: { last_price: 503.0, vol: 1000000, symbol: "700.HK" },
      };

      const response = await request(httpServer)
        .post("/api/v1/transformer/transform")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(transformRequest)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      const transformed = response.body.data.transformedData[0];
      expect(transformed).toHaveProperty("lastPrice", 503.0);
      expect(transformed).toHaveProperty("volume", 1000000);
    });

    it("should handle batch transformation", async () => {
      const batchRequest = [
        {
          provider: uniqueDataSourceName,
          transDataRuleListType: "quote_fields",
          rawData: { symbol: "700.HK", last_price: 503.0 },
        },
        {
          provider: uniqueDataSourceName,
          transDataRuleListType: "quote_fields",
          rawData: { symbol: "AAPL.US", last_price: 150.0 },
        },
      ];

      const response = await request(httpServer)
        .post("/api/v1/transformer/transform-batch")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(batchRequest)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(Array.isArray(response.body.data)).toBe(true);
      expect(response.body.data).toHaveLength(2);
    });

    it("should preview transformation without saving", async () => {
      // ÂàõÂª∫È¢ÑËßàËØ∑Ê±Ç
      const previewRequest = {
        provider: uniqueDataSourceName,
        transDataRuleListType: "quote_fields",
        rawData: {
          last_price: 503.0,
          vol: 1000000,
          symbol: "700.HK",
          timestamp: "2023-01-01T10:00:00Z",
        },
      };

      const response = await request(httpServer)
        .post("/api/v1/transformer/preview")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(previewRequest)
        .expect(201);

      // È™åËØÅÂìçÂ∫îÁªìÊûÑ
      expect(response.body.statusCode).toBe(201);
      expect(response.body.data).toHaveProperty("transformMappingRule");
      expect(response.body.data).toHaveProperty("sampleInput");
      expect(response.body.data).toHaveProperty("expectedOutput");
      expect(response.body.data).toHaveProperty("sharedDataFieldMappings");

      // È™åËØÅÊò†Â∞ÑËßÑÂàô‰ø°ÊÅØ
      const transformMappingRule = response.body.data.transformMappingRule;
      expect(transformMappingRule).toHaveProperty("id");
      expect(transformMappingRule).toHaveProperty("name");
      expect(transformMappingRule.provider).toBe(uniqueDataSourceName);
      expect(transformMappingRule.transDataRuleListType).toBe("quote_fields");
      expect(transformMappingRule.dataFieldMappingsCount).toBeGreaterThan(0);

      // È™åËØÅÊ†∑Êú¨ËæìÂÖ•Êï∞ÊçÆ
      expect(response.body.data.sampleInput).toEqual(previewRequest.rawData);

      // È™åËØÅÂ≠óÊÆµÊò†Â∞ÑÈ¢ÑËßà
      const sharedDataFieldMappings = response.body.data.sharedDataFieldMappings;
      expect(Array.isArray(sharedDataFieldMappings)).toBe(true);
      expect(sharedDataFieldMappings.length).toBeGreaterThan(0);

      // È™åËØÅÂ≠óÊÆµÊò†Â∞ÑÂåÖÂê´Êàë‰ª¨ÂàõÂª∫ÁöÑÂ≠óÊÆµ
      const lastPriceMapping = sharedDataFieldMappings.find(
        (m) => m.sourceField === "last_price",
      );
      expect(lastPriceMapping).toBeDefined();
      expect(lastPriceMapping.targetField).toBe("lastPrice");
      expect(lastPriceMapping.sampleSourceValue).toBe(503.0);

      const volumeMapping = sharedDataFieldMappings.find((m) => m.sourceField === "vol");
      expect(volumeMapping).toBeDefined();
      expect(volumeMapping.targetField).toBe("volume");
      expect(volumeMapping.sampleSourceValue).toBe(1000000);

      // È™åËØÅÈ¢ÑÊúüËæìÂá∫ÂåÖÂê´ËΩ¨Êç¢ÂêéÁöÑÂ≠óÊÆµ
      const expectedOutput = response.body.data.expectedOutput;
      expect(expectedOutput).toHaveProperty("lastPrice", 503.0);
      expect(expectedOutput).toHaveProperty("volume", 1000000);
    });
  });

  describe("Query Module", () => {
    let uniqueDataSourceName: string;
    let dataFetchingService: any;

    beforeEach(async () => {
      uniqueDataSourceName = `longport-q-${Date.now()}`; // 'q' for query

      // Ëé∑ÂèñDataFetchingServiceÂÆû‰æã‰ª•‰æøMock
      const { DataFetchingService } = await import(
        "../../../../../../src/core/shared/services/data-fetching.service"
      );
      dataFetchingService = app.get(DataFetchingService);

      // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÁõ¥Êé•Mock DataFetchingService.fetchSingleDataÊñπÊ≥ï
      // Ê≥®ÊÑèÔºöfetchSingleDataËøîÂõûÂçï‰∏™Êï∞ÊçÆÈ°πÔºå‰∏çÊòØÊï∞ÁªÑ
      jest.spyOn(dataFetchingService, "fetchSingleData").mockResolvedValue({
        data: { symbol: "700.HK", name: "Tencent", lastPrice: 503.0 },
        metadata: {
          source: "PROVIDER",
          timestamp: new Date(),
          market: "HK",
          marketStatus: "TRADING",
          cacheTTL: 300,
          provider: uniqueDataSourceName,
        },
      });

      // ‰øùÁïôÂéüÊúâÁöÑCapabilityRegistryService Mock‰Ωú‰∏∫Â§áÁî®
      jest
        .spyOn(capabilityRegistryService, "getCapability")
        .mockImplementation((provider, capabilityName) => {
          if (provider === uniqueDataSourceName) {
            return {
              name: capabilityName,
              description: "Mocked capability for query test",
              supportedMarkets: ["HK", "US", "CN"],
              supportedSymbolFormats: ["SYMBOL.MARKET", "SYMBOL"],
              rateLimit: {
                requestsPerSecond: 10,
                requestsPerDay: 10000,
              },
              execute: jest
                .fn()
                .mockResolvedValue([{ symbol: "700.HK", name: "Tencent" }]), // Return some data
            } as any;
          }
          return jest
            .requireActual(
              "../../../../src/providers/capability-registry.service",
            )
            .CapabilityRegistryService.prototype.getCapability.call(
              capabilityRegistryService,
              provider,
              capabilityName,
            );
        });

      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: uniqueDataSourceName,
        SymbolMappingRule: [{ inputSymbol: "700.HK", outputSymbol: "700-LP" }],
      });
    });

    it("should execute symbol-based query", async () => {
      const queryRequest = {
        queryType: "by_symbols",
        symbols: ["700.HK"],
        queryTypeFilter: "stock-quote",
        provider: uniqueDataSourceName,
      };

      const response = await request(httpServer)
        .post("/api/v1/query/execute")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(queryRequest)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(response.body.data.data).toEqual({
        items: [
          { symbol: "700.HK", name: "Tencent", lastPrice: 503.0 },
        ],
        pagination: {
          hasNext: false,
          hasPrev: false,
          limit: 1,
          page: 1,
          total: 1,
          totalPages: 1
        }
      });
    });

    it("should handle bulk query execution", async () => {
      const bulkRequest = {
        queries: [
          {
            queryType: "by_symbols",
            symbols: ["700.HK"],
            provider: uniqueDataSourceName,
          },
        ],
        parallel: true,
      };

      const response = await request(httpServer)
        .post("/api/v1/query/bulk")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(bulkRequest)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(response.body.data.results).toHaveLength(1);
      expect(response.body.data.results[0].data).toEqual({
        items: [
          { symbol: "700.HK", name: "Tencent", lastPrice: 503.0 },
        ],
        pagination: {
          hasNext: false,
          hasPrev: false,
          limit: 1,
          page: 1,
          total: 1,
          totalPages: 1
        }
      });
    });

    it.skip("should handle query with filters and sorting", async () => {
      const queryRequest = {
        queryType: "advanced",
        queryTypeFilter: "stock-quote",
        filters: [{ field: "market", operator: "eq", value: "HK" }],
        provider: uniqueDataSourceName,
      };

      const response = await request(httpServer)
        .post("/api/v1/query/execute")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(queryRequest)
        .expect(201);

      expect(response.body.statusCode).toBe(201);
      expect(response.body.data.data).toEqual([
        { symbol: "700.HK", name: "Tencent", lastPrice: 503.0 },
      ]);
    });
  });

  describe("üíæ Storage Module - ÂèåÂ≠òÂÇ®Á≠ñÁï•", () => {
    beforeEach(async () => {
      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: "test",
        SymbolMappingRule: [{ inputSymbol: "AAPL.US", outputSymbol: "AAPL" }],
      });
    });

    it("Â∫îËØ•ÂÆûÁé∞RedisÁºìÂ≠ò‰ºòÂÖàÁöÑÂ≠òÂÇ®Á≠ñÁï•", async () => {
      const storageData = {
        key: `cache-test-${Date.now()}`,
        data: { symbol: "700.HK", price: 503.0 },
        storageType: "cache",
        storageClassification: "stock_quote" as any,
        provider: "test",
        market: "test",
        options: { cacheTtl: 3600 },
      };

      await request(httpServer)
        .post("/api/v1/storage/store")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(storageData)
        .expect(201);

      const retrieveResponse = await request(httpServer)
        .get(`/api/v1/storage/retrieve/${storageData.key}`)
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .expect(200);

      expect(retrieveResponse.body.data.cacheInfo.hit).toBe(true);
      expect(retrieveResponse.body.data.data.price).toBe(503.0);
    });

    it("Â∫îËØ•Âú®ÁºìÂ≠òÂ§±ÊïàÊó∂‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÊï∞ÊçÆ", async () => {
      // 1. È¶ñÂÖàÂ≠òÂÇ®Êï∞ÊçÆÂà∞ÊåÅ‰πÖÂåñÂ≠òÂÇ®ÔºàÊï∞ÊçÆÂ∫ìÔºâ
      await request(httpServer)
        .post("/api/v1/storage/store")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send({
          key: "cache-miss-test-key",
          data: { test: "data" },
          storageType: "persistent", // Â≠òÂÇ®Âà∞Êï∞ÊçÆÂ∫ì
          storageClassification: "general" as any,
          provider: "test",
          market: "test",
        })
        .expect(201);

      // È™åËØÅÊï∞ÊçÆÁ°ÆÂÆûÂ≠òÂÇ®Âà∞‰∫ÜÊï∞ÊçÆÂ∫ì
      try {
        const StoredDataModel = app.get(getModelToken("StoredData"));
        if (StoredDataModel) {
          const dbRecord = await StoredDataModel.findOne({
            key: "cache-miss-test-key",
          });
          console.log(`üìä Êï∞ÊçÆÂ∫ìËÆ∞ÂΩïÊ£ÄÊü•:`, {
            found: !!dbRecord,
            key: dbRecord?.key,
            hasData: !!dbRecord?.data,
            id: dbRecord?._id?.toString(),
          });
        }
      } catch (error) {
        console.warn("‚ö†Ô∏è Êï∞ÊçÆÂ∫ìÈ™åËØÅÂ§±Ë¥•:", error.message);
      }

      // 2. ÊâãÂä®Âà†Èô§RedisÁºìÂ≠òÔºåÊ®°ÊãüÁºìÂ≠òÂ§±Êïà
      const redis = (global as any).getRedisClient();
      if (redis) {
        try {
          // ‰ΩøÁî®Ê≠£Á°ÆÁöÑRedisÁºìÂ≠òÈîÆÊ†ºÂºèÔºöstock-data:{key}
          // Ê†ºÂºèÊù•Ê∫êÔºöCACHE_CONFIG.KEY_PREFIX + ":" + key
          const cacheKey = `stock-data:cache-miss-test-key`;
          const metaKey = `stock-data:cache-miss-test-key:meta`;

          // ÂÖàÊ£ÄÊü•ÈîÆÊòØÂê¶Â≠òÂú®
          const existsBefore = await redis.exists(cacheKey);
          console.log(`üîç RedisÈîÆÂ≠òÂú®Ê£ÄÊü• - ${cacheKey}: ${existsBefore}`);

          const deletedCount = await redis.del(cacheKey);
          const deletedMetaCount = await redis.del(metaKey);

          console.log(
            `üóëÔ∏è RedisÂà†Èô§ÁªìÊûú - ‰∏ªÈîÆ: ${deletedCount}, ÂÖÉÊï∞ÊçÆÈîÆ: ${deletedMetaCount}`,
          );

          // Á°ÆËÆ§Âà†Èô§ÂêéÈîÆ‰∏çÂ≠òÂú®
          const existsAfter = await redis.exists(cacheKey);
          console.log(`‚úÖ RedisÂà†Èô§ÂêéÊ£ÄÊü• - ${cacheKey}: ${existsAfter}`);
        } catch (error) {
          console.warn("‚ö†Ô∏è RedisÂà†Èô§Êìç‰ΩúÂ§±Ë¥•ÔºåË∑≥Ëøá:", error.message);
        }
      } else {
        console.warn("‚ö†Ô∏è RedisÂÆ¢Êà∑Á´Ø‰∏çÂèØÁî®ÔºåÊó†Ê≥ïÂà†Èô§ÁºìÂ≠ò");
      }

      // 3. Ê£ÄÁ¥¢Êï∞ÊçÆÔºåÊúüÊúõ‰ªéÊï∞ÊçÆÂ∫ìÔºàpersistentÔºâËÄå‰∏çÊòØÁºìÂ≠òËé∑Âèñ
      const retrieveResponse = await request(httpServer)
        .get(`/api/v1/storage/retrieve/cache-miss-test-key`)
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .expect(200);

      // 4. È™åËØÅÊï∞ÊçÆÊù•Ê∫êÊòØÊåÅ‰πÖÂåñÂ≠òÂÇ®ÔºàÊï∞ÊçÆÂ∫ìÔºâ
      expect(retrieveResponse.body.data.cacheInfo.source).toBe("persistent");
      expect(retrieveResponse.body.data.data).toEqual({ test: "data" });
      expect(retrieveResponse.body.data.metadata.key).toBe(
        "cache-miss-test-key",
      );
    });

    it("Â∫îËØ•Êèê‰æõËØ¶ÁªÜÁöÑÂ≠òÂÇ®ÁªüËÆ°‰ø°ÊÅØ", async () => {
      const response = await request(httpServer)
        .get("/api/v1/storage/stats")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(response.body.data).toHaveProperty("cache");
      expect(response.body.data).toHaveProperty("persistent");
    });

    it("Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜÂ≠òÂÇ®ÂÆπÈáèÈôêÂà∂", async () => {
      const largeData = {
        key: `large-data-test-${Date.now()}`,
        data: { largeArray: new Array(1000).fill("test-data") },
        storageType: "cache",
        storageClassification: "general" as any,
        provider: "test",
        market: "test",
      };

      await request(httpServer)
        .post("/api/v1/storage/store")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(largeData)
        .expect(201);
    });
  });

  describe("üîç Error Handling and Edge Cases - ÈîôËØØÂ§ÑÁêÜÂíåËæπÁïåÊÉÖÂÜµ", () => {
    let uniqueDataSourceName: string;
    beforeEach(async () => {
      uniqueDataSourceName = `longport-e-${Date.now()}`;
      await TestDataHelper.createTestSymbolMapping(symbolMappingModel, {
        dataSourceName: uniqueDataSourceName,
        SymbolMappingRule: [
          {
            inputSymbol: "700.HK",
            outputSymbol: "00700",
            market: "HK",
            symbolType: "stock",
            isActive: true,
          },
          {
            inputSymbol: "MSFT.US",
            outputSymbol: "MSFT",
            market: "US",
            symbolType: "stock",
            isActive: true,
          },
        ],
      });

      // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöMock CapabilityRegistryService
      jest
        .spyOn(capabilityRegistryService, "getCapability")
        .mockImplementation((provider) => {
          if (provider === uniqueDataSourceName) {
            // ËøôÈáåÂè™Â§ÑÁêÜÂ∑≤Áü•ÁöÑÊµãËØïprovider
            return {
              name: "get-stock-quote",
              provider: uniqueDataSourceName,
              type: "data",
              description: "Mocked capability for testing",
              supportedMarkets: ["HK"],
              execute: jest.fn().mockResolvedValue([]), // ËøîÂõû‰∏Ä‰∏™Á©∫ÁöÑÊàêÂäüÁªìÊûú
            } as any;
          }
          // ÂØπ‰∫é‰ªª‰ΩïÂÖ∂‰ªñÊú™Áü•ÁöÑ provider (ÂåÖÊã¨ 'non-existent-provider')ÔºåËøîÂõû null Êù•Ê®°Êãü‚ÄúÊú™ÊâæÂà∞‚Äù
          return null;
        });
    });

    it("Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜÊï∞ÊçÆÊ∫êË∂ÖÊó∂", async () => {
      const timeoutRequest = {
        symbols: ["MSFT.US"],
        receiverType: "get-stock-quote",
        options: { preferredProvider: uniqueDataSourceName },
      };

      // Êàë‰ª¨Ë∞ÉÊï¥ÊµãËØïÔºåÂè™È™åËØÅÂΩìÁ¨¶Âè∑Êò†Â∞ÑÊàêÂäüÂêéÔºåËØ∑Ê±ÇË¢´Ê≠£Á°ÆÂàÜÂèë„ÄÇ
      // ÁúüÊ≠£ÁöÑË∂ÖÊó∂ÈÄªËæëÂ∫îÂú® E2E ÊµãËØï‰∏≠Ë¶ÜÁõñ„ÄÇ
      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(timeoutRequest)
        .expect(200); // È¢ÑÊúüÊàêÂäüÔºåÂõ†‰∏∫Êàë‰ª¨mock‰∫Ücapability

      expect(response.body.statusCode).toBe(200);
      // Ê£ÄÊü•ËøîÂõûÁöÑÊï∞ÊçÆÔºåÂõ†‰∏∫mockÁöÑexecuteËøîÂõûÁ©∫Êï∞ÁªÑÔºåÊâÄ‰ª•data‰πüÂ∫îËØ•ÊòØÁ©∫Êï∞ÁªÑ
      expect(response.body.data.data).toEqual([]);
    });

    it("Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜÊó†ÊïàËÇ°Á•®‰ª£Á†Å", async () => {
      const invalidSymbolRequest = {
        symbols: ["INVALID-CODE"],
        receiverType: "get-stock-quote",
        options: { preferredProvider: uniqueDataSourceName },
      };

      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(invalidSymbolRequest)
        .expect(400); // Âõ†‰∏∫Êúâ‰∏Ä‰∏™‰ª£Á†ÅÊó†Ê≥ïÊò†Â∞ÑÔºåÊâÄ‰ª•Â∫îËØ•ÊòØ 400

      expect(response.body.statusCode).toBe(400);
      expect(response.body.message).toContain("ËÇ°Á•®‰ª£Á†ÅÊ†ºÂºè‰∏çÊ≠£Á°Æ");
    });

    it("Â∫îËØ•Âú®Êò†Â∞ÑËßÑÂàôÁº∫Â§±Êó∂Êèê‰æõÈªòËÆ§Â§ÑÁêÜ", async () => {
      const noMappingRequest = {
        symbols: ["NO-MAPPING"],
        receiverType: "get-stock-quote",
        options: { preferredProvider: "non-existent-provider" },
      };

      const response = await request(httpServer)
        .post("/api/v1/receiver/data")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(noMappingRequest)
        .expect(400);

      expect(response.body.message).toContain("ËÇ°Á•®‰ª£Á†ÅÊ†ºÂºè‰∏çÊ≠£Á°Æ");
    });

    it("Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜÂ≠òÂÇ®ÊúçÂä°ÂºÇÂ∏∏", async () => {
      const storeRequest = {
        key: "", // Empty key will cause validation error
        data: { test: "data" },
      };

      const response = await request(httpServer)
        .post("/api/v1/storage/store")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .send(storeRequest)
        .expect(400);

      expect(response.body.statusCode).toBe(400);
    });

    it("Â∫îËØ•Âú®Âπ∂ÂèëËØ∑Ê±Ç‰∏ãÊ≠£Á°ÆÂ§ÑÁêÜÈîôËØØÈöîÁ¶ª", async () => {
      const mixedRequests = [
        request(httpServer)
          .post("/api/v1/receiver/data")
          .set("X-App-Key", testApiKey.appKey)
          .set("X-Access-Token", testApiKey.accessToken)
          .send({
            symbols: ["700.HK"],
            receiverType: "get-stock-quote",
            options: { preferredProvider: uniqueDataSourceName },
          }),
        request(httpServer)
          .post("/api/v1/receiver/data")
          .set("X-App-Key", testApiKey.appKey)
          .set("X-Access-Token", testApiKey.accessToken)
          .send({
            symbols: ["INVALID-CODE"],
            receiverType: "get-stock-quote",
            options: { preferredProvider: uniqueDataSourceName },
          }),
      ];

      const results = await Promise.all(mixedRequests);

      const successResponse = results.find((r) => r.status === 200);
      const errorResponse = results.find((r) => r.status === 400);

      expect(successResponse).toBeDefined();
      expect(errorResponse).toBeDefined();
      expect(successResponse.body.data.metadata.provider).toBe(
        uniqueDataSourceName,
      );
      expect(errorResponse.body.message).toContain("ËÇ°Á•®‰ª£Á†ÅÊ†ºÂºè‰∏çÊ≠£Á°Æ");
    });
  });

  describe("üè≠ Provider Capabilities", () => {
    it("should list available provider capabilities", async () => {
      const response = await request(httpServer)
        .get("/api/v1/providers/capabilities")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(response.body.data).toHaveProperty("longport");
      expect(response.body.data).toHaveProperty("longport-sg");
    });

    it("should get specific provider capabilities", async () => {
      const response = await request(httpServer)
        .get("/api/v1/providers/longport/capabilities")
        .set("X-App-Key", testApiKey.appKey)
        .set("X-Access-Token", testApiKey.accessToken)
        .expect(200);

      expect(response.body.statusCode).toBe(200);
      expect(response.body.data).toHaveProperty("provider", "longport");
      expect(Array.isArray(response.body.data.capabilities)).toBe(true);
    });
  });
});
