/**
 * SymbolMapperCacheService é«˜æ€§èƒ½å‹åŠ›æµ‹è¯•
 * æµ‹è¯•é«˜å¹¶å‘ã€å¤§æ‰¹é‡ã€å†…å­˜ä½¿ç”¨ã€ç¼“å­˜å¤±æ•ˆç­‰æé™åœºæ™¯
 */

import { Test, TestingModule } from '@nestjs/testing';
import { MongooseModule } from '@nestjs/mongoose';
import { SymbolMapperCacheService } from '../../../../../src/core/05-caching/symbol-mapper-cache/services/symbol-mapper-cache.service';
import { SymbolMappingRepository } from '../../../../../src/core/00-prepare/symbol-mapper/repositories/symbol-mapping.repository';
// import { FeatureFlags } from '../../../../../src/common/config/feature-flags.config';
import { MetricsRegistryService } from '../../../../../src/monitoring/metrics/services/metrics-registry.service';
import { PaginationService } from '../../../../../src/common/modules/pagination/services/pagination.service';
import { 
  SymbolMappingRuleDocument, 
  SymbolMappingRuleDocumentSchema 
} from '../../../../../src/core/00-prepare/symbol-mapper/schemas/symbol-mapping-rule.schema';

describe.skip('SymbolMapperCache High-Performance Tests', () => {
  let moduleRef: TestingModule;
  let cacheService: SymbolMapperCacheService;
  let repository: SymbolMappingRepository;

  const testDataSourceName = 'longport_performance_test';
  const performanceMetrics = {
    highConcurrency: {
      totalRequests: 0,
      successfulRequests: 0,
      averageResponseTime: 0,
      maxResponseTime: 0,
      minResponseTime: Number.MAX_VALUE,
      concurrentUsers: 50,
      requestsPerUser: 10
    },
    memoryUsage: {
      initialHeap: 0,
      peakHeap: 0,
      finalHeap: 0,
      gcCollections: 0
    },
    cacheInvalidation: {
      invalidationTime: 0,
      affectedEntries: 0,
      recoveryTime: 0
    }
  };

  beforeAll(async () => {
    // åˆ›å»ºæ€§èƒ½æµ‹è¯•æ¨¡å—
    moduleRef = await Test.createTestingModule({
      imports: [
        MongooseModule.forRoot(process.env.MONGODB_URI_TEST || 'mongodb://localhost:27017/symbol-mapper-perf-test'),
        MongooseModule.forFeature([
          { name: SymbolMappingRuleDocument.name, schema: SymbolMappingRuleDocumentSchema },
        ]),
      ],
      providers: [
        SymbolMapperCacheService,
        SymbolMappingRepository,
        // FeatureFlags,
        PaginationService,
        {
          provide: MetricsRegistryService,
          useValue: {
            streamCacheHitRate: {
              inc: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    cacheService = moduleRef.get<SymbolMapperCacheService>(SymbolMapperCacheService);
    repository = moduleRef.get<SymbolMappingRepository>(SymbolMappingRepository);

    // æ¸…ç†å’Œå‡†å¤‡å¤§è§„æ¨¡æµ‹è¯•æ•°æ®
    await setupLargeScaleTestData();
    
    // è®°å½•åˆå§‹å†…å­˜ä½¿ç”¨
    const initialMemUsage = process.memoryUsage();
    performanceMetrics.memoryUsage.initialHeap = initialMemUsage.heapUsed / 1024 / 1024;
    
    console.log(`\\nğŸš€ å¼€å§‹é«˜æ€§èƒ½å‹åŠ›æµ‹è¯• - åˆå§‹å†…å­˜: ${performanceMetrics.memoryUsage.initialHeap.toFixed(2)}MB`);
  });

  afterAll(async () => {
    // æ¸…ç†æµ‹è¯•æ•°æ®
    await cleanupPerformanceTestData();
    
    // è®°å½•æœ€ç»ˆå†…å­˜ä½¿ç”¨
    const finalMemUsage = process.memoryUsage();
    performanceMetrics.memoryUsage.finalHeap = finalMemUsage.heapUsed / 1024 / 1024;
    
    // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
    generatePerformanceReport();
    
    await moduleRef.close();
  });

  async function cleanupPerformanceTestData() {
    try {
      await repository.deleteByDataSource(testDataSourceName);
      console.log('âœ… Performance test data cleanup completed');
    } catch (error) {
      console.error('âŒ Performance test data cleanup failed:', error.message);
    }
  }

  async function setupLargeScaleTestData() {
    // åˆ›å»ºå¤§è§„æ¨¡æµ‹è¯•æ•°æ®é›† (1000ä¸ªç¬¦å·æ˜ å°„)
    const largeSymbolSet = [];
    
    // æ¸¯è‚¡ç¬¦å· (500ä¸ª)
    for (let i = 1; i <= 500; i++) {
      const paddedNumber = i.toString().padStart(5, '0');
      largeSymbolSet.push({
        standardSymbol: `${paddedNumber}.HK`,
        sdkSymbol: paddedNumber,
        market: 'HK',
        symbolType: 'stock',
        isActive: true,
        description: `HK Stock ${paddedNumber}`
      });
    }
    
    // ç¾è‚¡ç¬¦å· (500ä¸ª)
    const usSymbols = [
      'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'BRK.A', 'JNJ', 'V',
      'PG', 'UNH', 'HD', 'MA', 'BAC', 'DIS', 'ADBE', 'CRM', 'NFLX', 'INTC'
    ];
    
    for (let i = 0; i < 500; i++) {
      const baseSymbol = usSymbols[i % usSymbols.length];
      const suffix = i > 19 ? `_${Math.floor(i / 20)}` : '';
      largeSymbolSet.push({
        standardSymbol: `${baseSymbol}${suffix}.US`,
        sdkSymbol: `${baseSymbol}${suffix}`,
        market: 'US',
        symbolType: 'stock',
        isActive: true,
        description: `US Stock ${baseSymbol}${suffix}`
      });
    }

    const testMappingConfig = {
      dataSourceName: testDataSourceName,
      SymbolMappingRule: largeSymbolSet,
      description: 'Large scale performance test mapping rules',
      version: '1.0.0',
      isActive: true,
      createdBy: 'performance-test'
    };

    try {
      await repository.deleteByDataSource(testDataSourceName);
      await repository.create(testMappingConfig);
      console.log(`âœ… Large scale test data setup completed: ${largeSymbolSet.length} symbols`);
    } catch (error) {
      console.error('âŒ Large scale test data setup failed:', error.message);
    }
  }

  function measureMemoryUsage(): number {
    const memUsage = process.memoryUsage();
    const heapUsedMB = memUsage.heapUsed / 1024 / 1024;
    
    // æ›´æ–°å³°å€¼å†…å­˜ä½¿ç”¨
    if (heapUsedMB > performanceMetrics.memoryUsage.peakHeap) {
      performanceMetrics.memoryUsage.peakHeap = heapUsedMB;
    }
    
    return heapUsedMB;
  }

  async function measureExecutionTime(fn: () => Promise<any>): Promise<{ result: any; time: number }> {
    const start = performance.now();
    const result = await fn();
    const end = performance.now();
    return { result, time: end - start };
  }

  function generatePerformanceReport() {
    console.log('\\nğŸ“Š === é«˜æ€§èƒ½å‹åŠ›æµ‹è¯•æŠ¥å‘Š ===');
    console.log(`ğŸš€ é«˜å¹¶å‘æµ‹è¯•:`);
    console.log(`   - å¹¶å‘ç”¨æˆ·æ•°: ${performanceMetrics.highConcurrency.concurrentUsers}`);
    console.log(`   - æ¯ç”¨æˆ·è¯·æ±‚æ•°: ${performanceMetrics.highConcurrency.requestsPerUser}`);
    console.log(`   - æ€»è¯·æ±‚æ•°: ${performanceMetrics.highConcurrency.totalRequests}`);
    console.log(`   - æˆåŠŸè¯·æ±‚æ•°: ${performanceMetrics.highConcurrency.successfulRequests}`);
    console.log(`   - æˆåŠŸç‡: ${((performanceMetrics.highConcurrency.successfulRequests / performanceMetrics.highConcurrency.totalRequests) * 100).toFixed(2)}%`);
    console.log(`   - å¹³å‡å“åº”æ—¶é—´: ${performanceMetrics.highConcurrency.averageResponseTime.toFixed(2)}ms`);
    console.log(`   - æœ€å¤§å“åº”æ—¶é—´: ${performanceMetrics.highConcurrency.maxResponseTime.toFixed(2)}ms`);
    console.log(`   - æœ€å°å“åº”æ—¶é—´: ${performanceMetrics.highConcurrency.minResponseTime.toFixed(2)}ms`);
    
    console.log(`\\nğŸ’¾ å†…å­˜ä½¿ç”¨:`);
    console.log(`   - åˆå§‹å †å†…å­˜: ${performanceMetrics.memoryUsage.initialHeap.toFixed(2)}MB`);
    console.log(`   - å³°å€¼å †å†…å­˜: ${performanceMetrics.memoryUsage.peakHeap.toFixed(2)}MB`);
    console.log(`   - æœ€ç»ˆå †å†…å­˜: ${performanceMetrics.memoryUsage.finalHeap.toFixed(2)}MB`);
    console.log(`   - å†…å­˜å¢é•¿: ${(performanceMetrics.memoryUsage.finalHeap - performanceMetrics.memoryUsage.initialHeap).toFixed(2)}MB`);
    
    console.log(`\\nğŸ”„ ç¼“å­˜å¤±æ•ˆ:`);
    console.log(`   - å¤±æ•ˆæ—¶é—´: ${performanceMetrics.cacheInvalidation.invalidationTime.toFixed(2)}ms`);
    console.log(`   - å—å½±å“æ¡ç›®: ${performanceMetrics.cacheInvalidation.affectedEntries}`);
    console.log(`   - æ¢å¤æ—¶é—´: ${performanceMetrics.cacheInvalidation.recoveryTime.toFixed(2)}ms`);
  }

  describe('ğŸš€ High-Concurrency Stress Tests', () => {
    it('should handle high-concurrency batch queries efficiently', async () => {
      console.log('\\nğŸš€ å¼€å§‹é«˜å¹¶å‘æ‰¹é‡æŸ¥è¯¢æµ‹è¯•...');
      
      const concurrentUsers = performanceMetrics.highConcurrency.concurrentUsers;
      const requestsPerUser = performanceMetrics.highConcurrency.requestsPerUser;
      const responseTimes: number[] = [];
      
      // ç”Ÿæˆæµ‹è¯•ç¬¦å·é›†åˆ
      const testSymbols = [
        ['00001', '00700', '00005'],
        ['AAPL', 'MSFT', 'GOOGL'],
        ['00002', '00003', '00004'],
        ['AMZN', 'TSLA', 'META'],
        ['00010', '00011', '00012']
      ];
      
      // æ¨¡æ‹Ÿé«˜å¹¶å‘åœºæ™¯
      const concurrentPromises = [];
      
      for (let user = 0; user < concurrentUsers; user++) {
        const userPromise = async () => {
          const userResponseTimes: number[] = [];
          
          for (let req = 0; req < requestsPerUser; req++) {
            const symbolSet = testSymbols[req % testSymbols.length];
            
            try {
              const { result, time } = await measureExecutionTime(async () => {
                return await cacheService.mapSymbols(testDataSourceName, symbolSet, 'to_standard');
              });
              
              userResponseTimes.push(time);
              responseTimes.push(time);
              
              performanceMetrics.highConcurrency.totalRequests++;
              if (result.success) {
                performanceMetrics.highConcurrency.successfulRequests++;
              }
              
              // æ›´æ–°å“åº”æ—¶é—´ç»Ÿè®¡
              if (time > performanceMetrics.highConcurrency.maxResponseTime) {
                performanceMetrics.highConcurrency.maxResponseTime = time;
              }
              if (time < performanceMetrics.highConcurrency.minResponseTime) {
                performanceMetrics.highConcurrency.minResponseTime = time;
              }
              
              // æµ‹é‡å†…å­˜ä½¿ç”¨
              measureMemoryUsage();
              
            } catch (error) {
              console.error(`ç”¨æˆ· ${user} è¯·æ±‚ ${req} å¤±è´¥:`, error.message);
              performanceMetrics.highConcurrency.totalRequests++;
            }
          }
          
          return userResponseTimes;
        };
        
        concurrentPromises.push(userPromise());
      }
      
      // ç­‰å¾…æ‰€æœ‰å¹¶å‘è¯·æ±‚å®Œæˆ
      await Promise.all(concurrentPromises);
      
      // è®¡ç®—å¹³å‡å“åº”æ—¶é—´
      const totalResponseTime = responseTimes.reduce((sum, time) => sum + time, 0);
      performanceMetrics.highConcurrency.averageResponseTime = totalResponseTime / responseTimes.length;
      
      console.log(`âœ… é«˜å¹¶å‘æµ‹è¯•å®Œæˆ:`);
      console.log(`   - æ€»è¯·æ±‚: ${performanceMetrics.highConcurrency.totalRequests}`);
      console.log(`   - æˆåŠŸ: ${performanceMetrics.highConcurrency.successfulRequests}`);
      console.log(`   - å¹³å‡å“åº”æ—¶é—´: ${performanceMetrics.highConcurrency.averageResponseTime.toFixed(2)}ms`);
      console.log(`   - å³°å€¼å†…å­˜: ${performanceMetrics.memoryUsage.peakHeap.toFixed(2)}MB`);
      
      // éªŒè¯æ€§èƒ½è¦æ±‚
      expect(performanceMetrics.highConcurrency.successfulRequests).toBeGreaterThan(performanceMetrics.highConcurrency.totalRequests * 0.95); // 95%æˆåŠŸç‡
      expect(performanceMetrics.highConcurrency.averageResponseTime).toBeLessThan(100); // å¹³å‡å“åº”æ—¶é—´ < 100ms
      expect(performanceMetrics.memoryUsage.peakHeap).toBeLessThan(performanceMetrics.memoryUsage.initialHeap + 50); // å†…å­˜å¢é•¿ < 50MB
    });

    it('should maintain performance under sustained load', async () => {
      console.log('\\nâš¡ å¼€å§‹æŒç»­è´Ÿè½½æµ‹è¯•...');
      
      const sustainedDuration = 30000; // 30ç§’æŒç»­æµ‹è¯•
      const requestInterval = 100; // æ¯100msä¸€ä¸ªè¯·æ±‚
      const startTime = Date.now();
      const sustainedMetrics = {
        totalRequests: 0,
        successfulRequests: 0,
        responseTimes: []
      };
      
      while (Date.now() - startTime < sustainedDuration) {
        try {
          const testSymbols = ['00001', '00002', 'AAPL', 'MSFT'];
          
          const { result, time } = await measureExecutionTime(async () => {
            return await cacheService.mapSymbols(testDataSourceName, testSymbols, 'to_standard');
          });
          
          sustainedMetrics.totalRequests++;
          sustainedMetrics.responseTimes.push(time);
          
          if (result.success) {
            sustainedMetrics.successfulRequests++;
          }
          
          measureMemoryUsage();
          
          // æ§åˆ¶è¯·æ±‚é—´éš”
          await new Promise(resolve => setTimeout(resolve, requestInterval));
          
        } catch (error) {
          sustainedMetrics.totalRequests++;
          console.error('æŒç»­è´Ÿè½½æµ‹è¯•è¯·æ±‚å¤±è´¥:', error.message);
        }
      }
      
      const avgResponseTime = sustainedMetrics.responseTimes.reduce((a, b) => a + b, 0) / sustainedMetrics.responseTimes.length;
      const successRate = (sustainedMetrics.successfulRequests / sustainedMetrics.totalRequests) * 100;
      
      console.log(`âœ… æŒç»­è´Ÿè½½æµ‹è¯•å®Œæˆ:`);
      console.log(`   - æŒç»­æ—¶é—´: ${sustainedDuration / 1000}ç§’`);
      console.log(`   - æ€»è¯·æ±‚: ${sustainedMetrics.totalRequests}`);
      console.log(`   - æˆåŠŸç‡: ${successRate.toFixed(2)}%`);
      console.log(`   - å¹³å‡å“åº”æ—¶é—´: ${avgResponseTime.toFixed(2)}ms`);
      
      // éªŒè¯æŒç»­è´Ÿè½½æ€§èƒ½
      expect(successRate).toBeGreaterThan(90); // æˆåŠŸç‡ > 90%
      expect(avgResponseTime).toBeLessThan(200); // å¹³å‡å“åº”æ—¶é—´ < 200ms
    });
  });

  describe('ğŸ’¾ Memory Usage and Leak Tests', () => {
    it('should manage memory efficiently under heavy load', async () => {
      console.log('\\nğŸ’¾ å¼€å§‹å†…å­˜ä½¿ç”¨æµ‹è¯•...');
      
      const initialMemory = measureMemoryUsage();
      console.log(`åˆå§‹å†…å­˜: ${initialMemory.toFixed(2)}MB`);
      
      // æ‰§è¡Œå¤§é‡ç¼“å­˜æ“ä½œ
      const heavyLoadTasks = [];
      const largeSymbolBatches = [];
      
      // ç”Ÿæˆå¤§æ‰¹é‡ç¬¦å·é›†åˆ
      for (let batch = 0; batch < 10; batch++) {
        const batchSymbols = [];
        for (let i = 0; i < 50; i++) {
          const symbolNumber = (batch * 50 + i + 1).toString().padStart(5, '0');
          batchSymbols.push(symbolNumber);
        }
        largeSymbolBatches.push(batchSymbols);
      }
      
      // å¹¶å‘æ‰§è¡Œå¤§æ‰¹é‡æŸ¥è¯¢
      for (let i = 0; i < 5; i++) {
        const task = async () => {
          for (const batch of largeSymbolBatches) {
            await cacheService.mapSymbols(testDataSourceName, batch, 'to_standard');
            measureMemoryUsage();
          }
        };
        heavyLoadTasks.push(task());
      }
      
      await Promise.all(heavyLoadTasks);
      
      // è§¦å‘åƒåœ¾å›æ”¶
      if (global.gc) {
        global.gc();
        performanceMetrics.memoryUsage.gcCollections++;
      }
      
      const finalMemory = measureMemoryUsage();
      const memoryGrowth = finalMemory - initialMemory;
      
      console.log(`âœ… å†…å­˜ä½¿ç”¨æµ‹è¯•å®Œæˆ:`);
      console.log(`   - å³°å€¼å†…å­˜: ${performanceMetrics.memoryUsage.peakHeap.toFixed(2)}MB`);
      console.log(`   - æœ€ç»ˆå†…å­˜: ${finalMemory.toFixed(2)}MB`);
      console.log(`   - å†…å­˜å¢é•¿: ${memoryGrowth.toFixed(2)}MB`);
      
      // éªŒè¯å†…å­˜ä½¿ç”¨åˆç†æ€§
      expect(memoryGrowth).toBeLessThan(100); // å†…å­˜å¢é•¿ < 100MB
      expect(performanceMetrics.memoryUsage.peakHeap).toBeLessThan(1500); // å³°å€¼å†…å­˜ < 1.5GB (è€ƒè™‘æµ‹è¯•ç¯å¢ƒå¼€é”€)
    });

    it('should release memory after cache operations', async () => {
      console.log('\\nğŸ”„ å¼€å§‹å†…å­˜é‡Šæ”¾æµ‹è¯•...');
      
      const beforeOperations = measureMemoryUsage();
      
      // æ‰§è¡Œå¤§é‡ä¸´æ—¶ç¼“å­˜æ“ä½œ
      const tempOperations = [];
      for (let i = 0; i < 100; i++) {
        const operation = cacheService.mapSymbols(testDataSourceName, [`temp_${i}`], 'to_standard');
        tempOperations.push(operation);
      }
      
      await Promise.all(tempOperations);
      
      const afterOperations = measureMemoryUsage();
      
      // å¼ºåˆ¶åƒåœ¾å›æ”¶
      if (global.gc) {
        global.gc();
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      const afterGC = measureMemoryUsage();
      const memoryReclaimed = afterOperations - afterGC;
      
      console.log(`âœ… å†…å­˜é‡Šæ”¾æµ‹è¯•å®Œæˆ:`);
      console.log(`   - æ“ä½œå‰: ${beforeOperations.toFixed(2)}MB`);
      console.log(`   - æ“ä½œå: ${afterOperations.toFixed(2)}MB`);
      console.log(`   - GCå: ${afterGC.toFixed(2)}MB`);
      console.log(`   - å›æ”¶å†…å­˜: ${memoryReclaimed.toFixed(2)}MB`);
      
      // éªŒè¯å†…å­˜é‡Šæ”¾æ•ˆæœ (å…è®¸å¾®å°çš„å†…å­˜æ³¢åŠ¨)
      expect(afterGC).toBeLessThan(afterOperations + 1); // å…è®¸1MBçš„æ³¢åŠ¨èŒƒå›´
    });
  });

  describe('ğŸ”„ Cache Invalidation Performance', () => {
    it('should handle cache invalidation efficiently', async () => {
      console.log('\\nğŸ”„ å¼€å§‹ç¼“å­˜å¤±æ•ˆæ€§èƒ½æµ‹è¯•...');
      
      // é¢„çƒ­ç¼“å­˜
      const warmupSymbols = ['00001', '00002', '00003', 'AAPL', 'MSFT'];
      await cacheService.mapSymbols(testDataSourceName, warmupSymbols, 'to_standard');
      
      const preInvalidationStats = cacheService.getCacheStats();
      console.log('å¤±æ•ˆå‰ç¼“å­˜çŠ¶æ€:', JSON.stringify(preInvalidationStats, null, 2));
      
      // æµ‹é‡ç¼“å­˜å¤±æ•ˆæ—¶é—´
      const invalidationStart = performance.now();
      
      try {
        // æ¨¡æ‹Ÿæ•°æ®åº“æ›´æ–°è§¦å‘ç¼“å­˜å¤±æ•ˆ
        await repository.updateSymbolMappingRule(testDataSourceName, '00001.HK', {
          standardSymbol: '00001.HK',
          sdkSymbol: '00001',
          market: 'HK',
          symbolType: 'stock',
          isActive: true,
          description: 'Updated for cache invalidation test'
        });
        
        const invalidationEnd = performance.now();
        performanceMetrics.cacheInvalidation.invalidationTime = invalidationEnd - invalidationStart;
        
        // ç­‰å¾…å¤±æ•ˆå¤„ç†
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // æµ‹é‡æ¢å¤æ—¶é—´
        const recoveryStart = performance.now();
        const recoveryResult = await cacheService.mapSymbols(testDataSourceName, ['00001'], 'to_standard');
        const recoveryEnd = performance.now();
        
        performanceMetrics.cacheInvalidation.recoveryTime = recoveryEnd - recoveryStart;
        performanceMetrics.cacheInvalidation.affectedEntries = 1;
        
        cacheService.getCacheStats();
        
        console.log(`âœ… ç¼“å­˜å¤±æ•ˆæ€§èƒ½æµ‹è¯•å®Œæˆ:`);
        console.log(`   - å¤±æ•ˆæ—¶é—´: ${performanceMetrics.cacheInvalidation.invalidationTime.toFixed(2)}ms`);
        console.log(`   - æ¢å¤æ—¶é—´: ${performanceMetrics.cacheInvalidation.recoveryTime.toFixed(2)}ms`);
        console.log(`   - å—å½±å“æ¡ç›®: ${performanceMetrics.cacheInvalidation.affectedEntries}`);
        
        expect(recoveryResult.success).toBe(true);
        expect(performanceMetrics.cacheInvalidation.recoveryTime).toBeLessThan(50); // æ¢å¤æ—¶é—´ < 50ms
        
      } catch (error) {
        console.log('âš ï¸ ç¼“å­˜å¤±æ•ˆæµ‹è¯•éœ€è¦ Change Stream æ”¯æŒï¼Œè·³è¿‡:', error.message);
        performanceMetrics.cacheInvalidation.invalidationTime = 0;
        performanceMetrics.cacheInvalidation.recoveryTime = 0;
      }
    });

    it('should handle massive cache invalidation scenarios', async () => {
      console.log('\\nğŸ’¥ å¼€å§‹å¤§è§„æ¨¡ç¼“å­˜å¤±æ•ˆæµ‹è¯•...');
      
      // é¢„çƒ­å¤§é‡ç¼“å­˜æ¡ç›®
      const massiveSymbolBatches = [];
      for (let i = 0; i < 20; i++) {
        const batch = [];
        for (let j = 0; j < 25; j++) {
          const symbolNumber = (i * 25 + j + 1).toString().padStart(5, '0');
          batch.push(symbolNumber);
        }
        massiveSymbolBatches.push(batch);
      }
      
      // é¢„çƒ­æ‰€æœ‰æ‰¹æ¬¡
      const warmupPromises = massiveSymbolBatches.map(batch => 
        cacheService.mapSymbols(testDataSourceName, batch, 'to_standard')
      );
      await Promise.all(warmupPromises);
      
      const beforeMassiveInvalidation = cacheService.getCacheStats();
      console.log(`å¤§è§„æ¨¡å¤±æ•ˆå‰ç¼“å­˜æ¡ç›®: L1=${beforeMassiveInvalidation.cacheSize.l1}, L2=${beforeMassiveInvalidation.cacheSize.l2}, L3=${beforeMassiveInvalidation.cacheSize.l3}`);
      
      // æ¨¡æ‹Ÿå¤§è§„æ¨¡å¤±æ•ˆåœºæ™¯ï¼ˆé€šè¿‡æ¸…é™¤éƒ¨åˆ†è§„åˆ™ï¼‰
      const massiveInvalidationStart = performance.now();
      
      try {
        // æ¨¡æ‹Ÿåˆ é™¤éƒ¨åˆ†æ˜ å°„è§„åˆ™
        await repository.removeSymbolMappingRule(testDataSourceName, '00001.HK');
        await repository.removeSymbolMappingRule(testDataSourceName, '00002.HK');
        
        // ç­‰å¾…å¤±æ•ˆä¼ æ’­
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const massiveInvalidationEnd = performance.now();
        const massiveInvalidationTime = massiveInvalidationEnd - massiveInvalidationStart;
        
        // éªŒè¯ç³»ç»Ÿåœ¨å¤§è§„æ¨¡å¤±æ•ˆåä»èƒ½æ­£å¸¸å·¥ä½œ
        const postInvalidationQueries = [];
        for (let i = 0; i < 10; i++) {
          postInvalidationQueries.push(
            cacheService.mapSymbols(testDataSourceName, massiveSymbolBatches[i], 'to_standard')
          );
        }
        
        const postInvalidationResults = await Promise.all(postInvalidationQueries);
        const allSuccessful = postInvalidationResults.every(result => result.success);
        
        console.log(`âœ… å¤§è§„æ¨¡ç¼“å­˜å¤±æ•ˆæµ‹è¯•å®Œæˆ:`);
        console.log(`   - å¤±æ•ˆå¤„ç†æ—¶é—´: ${massiveInvalidationTime.toFixed(2)}ms`);
        console.log(`   - åç»­æŸ¥è¯¢å…¨éƒ¨æˆåŠŸ: ${allSuccessful}`);
        
        expect(allSuccessful).toBe(true);
        expect(massiveInvalidationTime).toBeLessThan(2000); // å¤§è§„æ¨¡å¤±æ•ˆå¤„ç† < 2ç§’
        
      } catch (error) {
        console.log('âš ï¸ å¤§è§„æ¨¡ç¼“å­˜å¤±æ•ˆæµ‹è¯•éœ€è¦ Change Stream æ”¯æŒï¼Œè·³è¿‡:', error.message);
      }
    });
  });

  describe('ğŸ¯ Cache Hit Ratio Optimization', () => {
    it('should achieve high cache hit ratios under realistic workloads', async () => {
      console.log('\\nğŸ¯ å¼€å§‹ç¼“å­˜å‘½ä¸­ç‡ä¼˜åŒ–æµ‹è¯•...');
      
      // æ¨¡æ‹ŸçœŸå®å·¥ä½œè´Ÿè½½æ¨¡å¼ï¼š80/20è§„åˆ™ï¼ˆ80%çš„æŸ¥è¯¢é›†ä¸­åœ¨20%çš„ç¬¦å·ä¸Šï¼‰
      const hotSymbols = ['00700', '00005', 'AAPL', 'MSFT', 'GOOGL']; // 20%çƒ­é—¨ç¬¦å·
      const coldSymbols = []; // 80%å†·é—¨ç¬¦å·
      
      for (let i = 6; i <= 25; i++) {
        const symbolNumber = i.toString().padStart(5, '0');
        coldSymbols.push(symbolNumber);
      }
      
      const workloadQueries = [];
      
      // ç”ŸæˆçœŸå®å·¥ä½œè´Ÿè½½ï¼š80%æŸ¥è¯¢çƒ­é—¨ç¬¦å·ï¼Œ20%æŸ¥è¯¢å†·é—¨ç¬¦å·
      for (let i = 0; i < 100; i++) {
        if (i < 80) {
          // 80%æŸ¥è¯¢çƒ­é—¨ç¬¦å·
          const hotSymbol = hotSymbols[i % hotSymbols.length];
          workloadQueries.push({ symbols: [hotSymbol], type: 'hot' });
        } else {
          // 20%æŸ¥è¯¢å†·é—¨ç¬¦å·
          const coldSymbol = coldSymbols[i % coldSymbols.length];
          workloadQueries.push({ symbols: [coldSymbol], type: 'cold' });
        }
      }
      
      // æ‰§è¡Œå·¥ä½œè´Ÿè½½
      cacheService.getCacheStats();
      
      for (const query of workloadQueries) {
        await cacheService.mapSymbols(testDataSourceName, query.symbols, 'to_standard');
      }
      
      const finalStats = cacheService.getCacheStats();
      
      console.log(`âœ… ç¼“å­˜å‘½ä¸­ç‡ä¼˜åŒ–æµ‹è¯•å®Œæˆ:`);
      console.log(`   - L1å‘½ä¸­ç‡: ${(finalStats.l1HitRatio * 100).toFixed(1)}%`);
      console.log(`   - L2å‘½ä¸­ç‡: ${(finalStats.l2HitRatio * 100).toFixed(1)}%`);
      console.log(`   - L3å‘½ä¸­ç‡: ${(finalStats.l3HitRatio * 100).toFixed(1)}%`);
      console.log(`   - æ€»æŸ¥è¯¢æ•°: ${finalStats.totalQueries}`);
      
      // éªŒè¯ç¼“å­˜å‘½ä¸­ç‡è¦æ±‚
      expect(finalStats.l1HitRatio).toBeGreaterThan(0.3); // L1å‘½ä¸­ç‡ > 30%
      expect(finalStats.l2HitRatio).toBeGreaterThan(0.6); // L2å‘½ä¸­ç‡ > 60%
      
      // è®¡ç®—ç»¼åˆç¼“å­˜æ•ˆç‡
      const overallHitRatio = Math.max(finalStats.l1HitRatio, finalStats.l2HitRatio, finalStats.l3HitRatio);
      expect(overallHitRatio).toBeGreaterThan(0.5); // ç»¼åˆå‘½ä¸­ç‡ > 50%
    });
  });
});