/**
 * SymbolMapperCacheService 高性能压力测试
 * 测试高并发、大批量、内存使用、缓存失效等极限场景
 */

import { Test, TestingModule } from '@nestjs/testing';
import { MongooseModule } from '@nestjs/mongoose';
import { SymbolMapperCacheService } from '../../../../../src/core/05-caching/symbol-mapper-cache/services/symbol-mapper-cache.service';
import { SymbolMappingRepository } from '../../../../../src/core/00-prepare/symbol-mapper/repositories/symbol-mapping.repository';
// import { FeatureFlags } from '../../../../../src/common/config/feature-flags.config';
import { MetricsRegistryService } from '../../../../../src/monitoring/metrics/services/metrics-registry.service';
import { PaginationService } from '../../../../../src/common/modules/pagination/services/pagination.service';
import { 
  SymbolMappingRuleDocument, 
  SymbolMappingRuleDocumentSchema 
} from '../../../../../src/core/00-prepare/symbol-mapper/schemas/symbol-mapping-rule.schema';

describe.skip('SymbolMapperCache High-Performance Tests', () => {
  let moduleRef: TestingModule;
  let cacheService: SymbolMapperCacheService;
  let repository: SymbolMappingRepository;

  const testDataSourceName = 'longport_performance_test';
  const performanceMetrics = {
    highConcurrency: {
      totalRequests: 0,
      successfulRequests: 0,
      averageResponseTime: 0,
      maxResponseTime: 0,
      minResponseTime: Number.MAX_VALUE,
      concurrentUsers: 50,
      requestsPerUser: 10
    },
    memoryUsage: {
      initialHeap: 0,
      peakHeap: 0,
      finalHeap: 0,
      gcCollections: 0
    },
    cacheInvalidation: {
      invalidationTime: 0,
      affectedEntries: 0,
      recoveryTime: 0
    }
  };

  beforeAll(async () => {
    // 创建性能测试模块
    moduleRef = await Test.createTestingModule({
      imports: [
        MongooseModule.forRoot(process.env.MONGODB_URI_TEST || 'mongodb://localhost:27017/symbol-mapper-perf-test'),
        MongooseModule.forFeature([
          { name: SymbolMappingRuleDocument.name, schema: SymbolMappingRuleDocumentSchema },
        ]),
      ],
      providers: [
        SymbolMapperCacheService,
        SymbolMappingRepository,
        // FeatureFlags,
        PaginationService,
        {
          provide: MetricsRegistryService,
          useValue: {
            streamCacheHitRate: {
              inc: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    cacheService = moduleRef.get<SymbolMapperCacheService>(SymbolMapperCacheService);
    repository = moduleRef.get<SymbolMappingRepository>(SymbolMappingRepository);

    // 清理和准备大规模测试数据
    await setupLargeScaleTestData();
    
    // 记录初始内存使用
    const initialMemUsage = process.memoryUsage();
    performanceMetrics.memoryUsage.initialHeap = initialMemUsage.heapUsed / 1024 / 1024;
    
    console.log(`\\n🚀 开始高性能压力测试 - 初始内存: ${performanceMetrics.memoryUsage.initialHeap.toFixed(2)}MB`);
  });

  afterAll(async () => {
    // 清理测试数据
    await cleanupPerformanceTestData();
    
    // 记录最终内存使用
    const finalMemUsage = process.memoryUsage();
    performanceMetrics.memoryUsage.finalHeap = finalMemUsage.heapUsed / 1024 / 1024;
    
    // 生成性能报告
    generatePerformanceReport();
    
    await moduleRef.close();
  });

  async function cleanupPerformanceTestData() {
    try {
      await repository.deleteByDataSource(testDataSourceName);
      console.log('✅ Performance test data cleanup completed');
    } catch (error) {
      console.error('❌ Performance test data cleanup failed:', error.message);
    }
  }

  async function setupLargeScaleTestData() {
    // 创建大规模测试数据集 (1000个符号映射)
    const largeSymbolSet = [];
    
    // 港股符号 (500个)
    for (let i = 1; i <= 500; i++) {
      const paddedNumber = i.toString().padStart(5, '0');
      largeSymbolSet.push({
        standardSymbol: `${paddedNumber}.HK`,
        sdkSymbol: paddedNumber,
        market: 'HK',
        symbolType: 'stock',
        isActive: true,
        description: `HK Stock ${paddedNumber}`
      });
    }
    
    // 美股符号 (500个)
    const usSymbols = [
      'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'BRK.A', 'JNJ', 'V',
      'PG', 'UNH', 'HD', 'MA', 'BAC', 'DIS', 'ADBE', 'CRM', 'NFLX', 'INTC'
    ];
    
    for (let i = 0; i < 500; i++) {
      const baseSymbol = usSymbols[i % usSymbols.length];
      const suffix = i > 19 ? `_${Math.floor(i / 20)}` : '';
      largeSymbolSet.push({
        standardSymbol: `${baseSymbol}${suffix}.US`,
        sdkSymbol: `${baseSymbol}${suffix}`,
        market: 'US',
        symbolType: 'stock',
        isActive: true,
        description: `US Stock ${baseSymbol}${suffix}`
      });
    }

    const testMappingConfig = {
      dataSourceName: testDataSourceName,
      SymbolMappingRule: largeSymbolSet,
      description: 'Large scale performance test mapping rules',
      version: '1.0.0',
      isActive: true,
      createdBy: 'performance-test'
    };

    try {
      await repository.deleteByDataSource(testDataSourceName);
      await repository.create(testMappingConfig);
      console.log(`✅ Large scale test data setup completed: ${largeSymbolSet.length} symbols`);
    } catch (error) {
      console.error('❌ Large scale test data setup failed:', error.message);
    }
  }

  function measureMemoryUsage(): number {
    const memUsage = process.memoryUsage();
    const heapUsedMB = memUsage.heapUsed / 1024 / 1024;
    
    // 更新峰值内存使用
    if (heapUsedMB > performanceMetrics.memoryUsage.peakHeap) {
      performanceMetrics.memoryUsage.peakHeap = heapUsedMB;
    }
    
    return heapUsedMB;
  }

  async function measureExecutionTime(fn: () => Promise<any>): Promise<{ result: any; time: number }> {
    const start = performance.now();
    const result = await fn();
    const end = performance.now();
    return { result, time: end - start };
  }

  function generatePerformanceReport() {
    console.log('\\n📊 === 高性能压力测试报告 ===');
    console.log(`🚀 高并发测试:`);
    console.log(`   - 并发用户数: ${performanceMetrics.highConcurrency.concurrentUsers}`);
    console.log(`   - 每用户请求数: ${performanceMetrics.highConcurrency.requestsPerUser}`);
    console.log(`   - 总请求数: ${performanceMetrics.highConcurrency.totalRequests}`);
    console.log(`   - 成功请求数: ${performanceMetrics.highConcurrency.successfulRequests}`);
    console.log(`   - 成功率: ${((performanceMetrics.highConcurrency.successfulRequests / performanceMetrics.highConcurrency.totalRequests) * 100).toFixed(2)}%`);
    console.log(`   - 平均响应时间: ${performanceMetrics.highConcurrency.averageResponseTime.toFixed(2)}ms`);
    console.log(`   - 最大响应时间: ${performanceMetrics.highConcurrency.maxResponseTime.toFixed(2)}ms`);
    console.log(`   - 最小响应时间: ${performanceMetrics.highConcurrency.minResponseTime.toFixed(2)}ms`);
    
    console.log(`\\n💾 内存使用:`);
    console.log(`   - 初始堆内存: ${performanceMetrics.memoryUsage.initialHeap.toFixed(2)}MB`);
    console.log(`   - 峰值堆内存: ${performanceMetrics.memoryUsage.peakHeap.toFixed(2)}MB`);
    console.log(`   - 最终堆内存: ${performanceMetrics.memoryUsage.finalHeap.toFixed(2)}MB`);
    console.log(`   - 内存增长: ${(performanceMetrics.memoryUsage.finalHeap - performanceMetrics.memoryUsage.initialHeap).toFixed(2)}MB`);
    
    console.log(`\\n🔄 缓存失效:`);
    console.log(`   - 失效时间: ${performanceMetrics.cacheInvalidation.invalidationTime.toFixed(2)}ms`);
    console.log(`   - 受影响条目: ${performanceMetrics.cacheInvalidation.affectedEntries}`);
    console.log(`   - 恢复时间: ${performanceMetrics.cacheInvalidation.recoveryTime.toFixed(2)}ms`);
  }

  describe('🚀 High-Concurrency Stress Tests', () => {
    it('should handle high-concurrency batch queries efficiently', async () => {
      console.log('\\n🚀 开始高并发批量查询测试...');
      
      const concurrentUsers = performanceMetrics.highConcurrency.concurrentUsers;
      const requestsPerUser = performanceMetrics.highConcurrency.requestsPerUser;
      const responseTimes: number[] = [];
      
      // 生成测试符号集合
      const testSymbols = [
        ['00001', '00700', '00005'],
        ['AAPL', 'MSFT', 'GOOGL'],
        ['00002', '00003', '00004'],
        ['AMZN', 'TSLA', 'META'],
        ['00010', '00011', '00012']
      ];
      
      // 模拟高并发场景
      const concurrentPromises = [];
      
      for (let user = 0; user < concurrentUsers; user++) {
        const userPromise = async () => {
          const userResponseTimes: number[] = [];
          
          for (let req = 0; req < requestsPerUser; req++) {
            const symbolSet = testSymbols[req % testSymbols.length];
            
            try {
              const { result, time } = await measureExecutionTime(async () => {
                return await cacheService.mapSymbols(testDataSourceName, symbolSet, 'to_standard');
              });
              
              userResponseTimes.push(time);
              responseTimes.push(time);
              
              performanceMetrics.highConcurrency.totalRequests++;
              if (result.success) {
                performanceMetrics.highConcurrency.successfulRequests++;
              }
              
              // 更新响应时间统计
              if (time > performanceMetrics.highConcurrency.maxResponseTime) {
                performanceMetrics.highConcurrency.maxResponseTime = time;
              }
              if (time < performanceMetrics.highConcurrency.minResponseTime) {
                performanceMetrics.highConcurrency.minResponseTime = time;
              }
              
              // 测量内存使用
              measureMemoryUsage();
              
            } catch (error) {
              console.error(`用户 ${user} 请求 ${req} 失败:`, error.message);
              performanceMetrics.highConcurrency.totalRequests++;
            }
          }
          
          return userResponseTimes;
        };
        
        concurrentPromises.push(userPromise());
      }
      
      // 等待所有并发请求完成
      await Promise.all(concurrentPromises);
      
      // 计算平均响应时间
      const totalResponseTime = responseTimes.reduce((sum, time) => sum + time, 0);
      performanceMetrics.highConcurrency.averageResponseTime = totalResponseTime / responseTimes.length;
      
      console.log(`✅ 高并发测试完成:`);
      console.log(`   - 总请求: ${performanceMetrics.highConcurrency.totalRequests}`);
      console.log(`   - 成功: ${performanceMetrics.highConcurrency.successfulRequests}`);
      console.log(`   - 平均响应时间: ${performanceMetrics.highConcurrency.averageResponseTime.toFixed(2)}ms`);
      console.log(`   - 峰值内存: ${performanceMetrics.memoryUsage.peakHeap.toFixed(2)}MB`);
      
      // 验证性能要求
      expect(performanceMetrics.highConcurrency.successfulRequests).toBeGreaterThan(performanceMetrics.highConcurrency.totalRequests * 0.95); // 95%成功率
      expect(performanceMetrics.highConcurrency.averageResponseTime).toBeLessThan(100); // 平均响应时间 < 100ms
      expect(performanceMetrics.memoryUsage.peakHeap).toBeLessThan(performanceMetrics.memoryUsage.initialHeap + 50); // 内存增长 < 50MB
    });

    it('should maintain performance under sustained load', async () => {
      console.log('\\n⚡ 开始持续负载测试...');
      
      const sustainedDuration = 30000; // 30秒持续测试
      const requestInterval = 100; // 每100ms一个请求
      const startTime = Date.now();
      const sustainedMetrics = {
        totalRequests: 0,
        successfulRequests: 0,
        responseTimes: []
      };
      
      while (Date.now() - startTime < sustainedDuration) {
        try {
          const testSymbols = ['00001', '00002', 'AAPL', 'MSFT'];
          
          const { result, time } = await measureExecutionTime(async () => {
            return await cacheService.mapSymbols(testDataSourceName, testSymbols, 'to_standard');
          });
          
          sustainedMetrics.totalRequests++;
          sustainedMetrics.responseTimes.push(time);
          
          if (result.success) {
            sustainedMetrics.successfulRequests++;
          }
          
          measureMemoryUsage();
          
          // 控制请求间隔
          await new Promise(resolve => setTimeout(resolve, requestInterval));
          
        } catch (error) {
          sustainedMetrics.totalRequests++;
          console.error('持续负载测试请求失败:', error.message);
        }
      }
      
      const avgResponseTime = sustainedMetrics.responseTimes.reduce((a, b) => a + b, 0) / sustainedMetrics.responseTimes.length;
      const successRate = (sustainedMetrics.successfulRequests / sustainedMetrics.totalRequests) * 100;
      
      console.log(`✅ 持续负载测试完成:`);
      console.log(`   - 持续时间: ${sustainedDuration / 1000}秒`);
      console.log(`   - 总请求: ${sustainedMetrics.totalRequests}`);
      console.log(`   - 成功率: ${successRate.toFixed(2)}%`);
      console.log(`   - 平均响应时间: ${avgResponseTime.toFixed(2)}ms`);
      
      // 验证持续负载性能
      expect(successRate).toBeGreaterThan(90); // 成功率 > 90%
      expect(avgResponseTime).toBeLessThan(200); // 平均响应时间 < 200ms
    });
  });

  describe('💾 Memory Usage and Leak Tests', () => {
    it('should manage memory efficiently under heavy load', async () => {
      console.log('\\n💾 开始内存使用测试...');
      
      const initialMemory = measureMemoryUsage();
      console.log(`初始内存: ${initialMemory.toFixed(2)}MB`);
      
      // 执行大量缓存操作
      const heavyLoadTasks = [];
      const largeSymbolBatches = [];
      
      // 生成大批量符号集合
      for (let batch = 0; batch < 10; batch++) {
        const batchSymbols = [];
        for (let i = 0; i < 50; i++) {
          const symbolNumber = (batch * 50 + i + 1).toString().padStart(5, '0');
          batchSymbols.push(symbolNumber);
        }
        largeSymbolBatches.push(batchSymbols);
      }
      
      // 并发执行大批量查询
      for (let i = 0; i < 5; i++) {
        const task = async () => {
          for (const batch of largeSymbolBatches) {
            await cacheService.mapSymbols(testDataSourceName, batch, 'to_standard');
            measureMemoryUsage();
          }
        };
        heavyLoadTasks.push(task());
      }
      
      await Promise.all(heavyLoadTasks);
      
      // 触发垃圾回收
      if (global.gc) {
        global.gc();
        performanceMetrics.memoryUsage.gcCollections++;
      }
      
      const finalMemory = measureMemoryUsage();
      const memoryGrowth = finalMemory - initialMemory;
      
      console.log(`✅ 内存使用测试完成:`);
      console.log(`   - 峰值内存: ${performanceMetrics.memoryUsage.peakHeap.toFixed(2)}MB`);
      console.log(`   - 最终内存: ${finalMemory.toFixed(2)}MB`);
      console.log(`   - 内存增长: ${memoryGrowth.toFixed(2)}MB`);
      
      // 验证内存使用合理性
      expect(memoryGrowth).toBeLessThan(100); // 内存增长 < 100MB
      expect(performanceMetrics.memoryUsage.peakHeap).toBeLessThan(1500); // 峰值内存 < 1.5GB (考虑测试环境开销)
    });

    it('should release memory after cache operations', async () => {
      console.log('\\n🔄 开始内存释放测试...');
      
      const beforeOperations = measureMemoryUsage();
      
      // 执行大量临时缓存操作
      const tempOperations = [];
      for (let i = 0; i < 100; i++) {
        const operation = cacheService.mapSymbols(testDataSourceName, [`temp_${i}`], 'to_standard');
        tempOperations.push(operation);
      }
      
      await Promise.all(tempOperations);
      
      const afterOperations = measureMemoryUsage();
      
      // 强制垃圾回收
      if (global.gc) {
        global.gc();
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      const afterGC = measureMemoryUsage();
      const memoryReclaimed = afterOperations - afterGC;
      
      console.log(`✅ 内存释放测试完成:`);
      console.log(`   - 操作前: ${beforeOperations.toFixed(2)}MB`);
      console.log(`   - 操作后: ${afterOperations.toFixed(2)}MB`);
      console.log(`   - GC后: ${afterGC.toFixed(2)}MB`);
      console.log(`   - 回收内存: ${memoryReclaimed.toFixed(2)}MB`);
      
      // 验证内存释放效果 (允许微小的内存波动)
      expect(afterGC).toBeLessThan(afterOperations + 1); // 允许1MB的波动范围
    });
  });

  describe('🔄 Cache Invalidation Performance', () => {
    it('should handle cache invalidation efficiently', async () => {
      console.log('\\n🔄 开始缓存失效性能测试...');
      
      // 预热缓存
      const warmupSymbols = ['00001', '00002', '00003', 'AAPL', 'MSFT'];
      await cacheService.mapSymbols(testDataSourceName, warmupSymbols, 'to_standard');
      
      const preInvalidationStats = cacheService.getCacheStats();
      console.log('失效前缓存状态:', JSON.stringify(preInvalidationStats, null, 2));
      
      // 测量缓存失效时间
      const invalidationStart = performance.now();
      
      try {
        // 模拟数据库更新触发缓存失效
        await repository.updateSymbolMappingRule(testDataSourceName, '00001.HK', {
          standardSymbol: '00001.HK',
          sdkSymbol: '00001',
          market: 'HK',
          symbolType: 'stock',
          isActive: true,
          description: 'Updated for cache invalidation test'
        });
        
        const invalidationEnd = performance.now();
        performanceMetrics.cacheInvalidation.invalidationTime = invalidationEnd - invalidationStart;
        
        // 等待失效处理
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // 测量恢复时间
        const recoveryStart = performance.now();
        const recoveryResult = await cacheService.mapSymbols(testDataSourceName, ['00001'], 'to_standard');
        const recoveryEnd = performance.now();
        
        performanceMetrics.cacheInvalidation.recoveryTime = recoveryEnd - recoveryStart;
        performanceMetrics.cacheInvalidation.affectedEntries = 1;
        
        cacheService.getCacheStats();
        
        console.log(`✅ 缓存失效性能测试完成:`);
        console.log(`   - 失效时间: ${performanceMetrics.cacheInvalidation.invalidationTime.toFixed(2)}ms`);
        console.log(`   - 恢复时间: ${performanceMetrics.cacheInvalidation.recoveryTime.toFixed(2)}ms`);
        console.log(`   - 受影响条目: ${performanceMetrics.cacheInvalidation.affectedEntries}`);
        
        expect(recoveryResult.success).toBe(true);
        expect(performanceMetrics.cacheInvalidation.recoveryTime).toBeLessThan(50); // 恢复时间 < 50ms
        
      } catch (error) {
        console.log('⚠️ 缓存失效测试需要 Change Stream 支持，跳过:', error.message);
        performanceMetrics.cacheInvalidation.invalidationTime = 0;
        performanceMetrics.cacheInvalidation.recoveryTime = 0;
      }
    });

    it('should handle massive cache invalidation scenarios', async () => {
      console.log('\\n💥 开始大规模缓存失效测试...');
      
      // 预热大量缓存条目
      const massiveSymbolBatches = [];
      for (let i = 0; i < 20; i++) {
        const batch = [];
        for (let j = 0; j < 25; j++) {
          const symbolNumber = (i * 25 + j + 1).toString().padStart(5, '0');
          batch.push(symbolNumber);
        }
        massiveSymbolBatches.push(batch);
      }
      
      // 预热所有批次
      const warmupPromises = massiveSymbolBatches.map(batch => 
        cacheService.mapSymbols(testDataSourceName, batch, 'to_standard')
      );
      await Promise.all(warmupPromises);
      
      const beforeMassiveInvalidation = cacheService.getCacheStats();
      console.log(`大规模失效前缓存条目: L1=${beforeMassiveInvalidation.cacheSize.l1}, L2=${beforeMassiveInvalidation.cacheSize.l2}, L3=${beforeMassiveInvalidation.cacheSize.l3}`);
      
      // 模拟大规模失效场景（通过清除部分规则）
      const massiveInvalidationStart = performance.now();
      
      try {
        // 模拟删除部分映射规则
        await repository.removeSymbolMappingRule(testDataSourceName, '00001.HK');
        await repository.removeSymbolMappingRule(testDataSourceName, '00002.HK');
        
        // 等待失效传播
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const massiveInvalidationEnd = performance.now();
        const massiveInvalidationTime = massiveInvalidationEnd - massiveInvalidationStart;
        
        // 验证系统在大规模失效后仍能正常工作
        const postInvalidationQueries = [];
        for (let i = 0; i < 10; i++) {
          postInvalidationQueries.push(
            cacheService.mapSymbols(testDataSourceName, massiveSymbolBatches[i], 'to_standard')
          );
        }
        
        const postInvalidationResults = await Promise.all(postInvalidationQueries);
        const allSuccessful = postInvalidationResults.every(result => result.success);
        
        console.log(`✅ 大规模缓存失效测试完成:`);
        console.log(`   - 失效处理时间: ${massiveInvalidationTime.toFixed(2)}ms`);
        console.log(`   - 后续查询全部成功: ${allSuccessful}`);
        
        expect(allSuccessful).toBe(true);
        expect(massiveInvalidationTime).toBeLessThan(2000); // 大规模失效处理 < 2秒
        
      } catch (error) {
        console.log('⚠️ 大规模缓存失效测试需要 Change Stream 支持，跳过:', error.message);
      }
    });
  });

  describe('🎯 Cache Hit Ratio Optimization', () => {
    it('should achieve high cache hit ratios under realistic workloads', async () => {
      console.log('\\n🎯 开始缓存命中率优化测试...');
      
      // 模拟真实工作负载模式：80/20规则（80%的查询集中在20%的符号上）
      const hotSymbols = ['00700', '00005', 'AAPL', 'MSFT', 'GOOGL']; // 20%热门符号
      const coldSymbols = []; // 80%冷门符号
      
      for (let i = 6; i <= 25; i++) {
        const symbolNumber = i.toString().padStart(5, '0');
        coldSymbols.push(symbolNumber);
      }
      
      const workloadQueries = [];
      
      // 生成真实工作负载：80%查询热门符号，20%查询冷门符号
      for (let i = 0; i < 100; i++) {
        if (i < 80) {
          // 80%查询热门符号
          const hotSymbol = hotSymbols[i % hotSymbols.length];
          workloadQueries.push({ symbols: [hotSymbol], type: 'hot' });
        } else {
          // 20%查询冷门符号
          const coldSymbol = coldSymbols[i % coldSymbols.length];
          workloadQueries.push({ symbols: [coldSymbol], type: 'cold' });
        }
      }
      
      // 执行工作负载
      cacheService.getCacheStats();
      
      for (const query of workloadQueries) {
        await cacheService.mapSymbols(testDataSourceName, query.symbols, 'to_standard');
      }
      
      const finalStats = cacheService.getCacheStats();
      
      console.log(`✅ 缓存命中率优化测试完成:`);
      console.log(`   - L1命中率: ${(finalStats.l1HitRatio * 100).toFixed(1)}%`);
      console.log(`   - L2命中率: ${(finalStats.l2HitRatio * 100).toFixed(1)}%`);
      console.log(`   - L3命中率: ${(finalStats.l3HitRatio * 100).toFixed(1)}%`);
      console.log(`   - 总查询数: ${finalStats.totalQueries}`);
      
      // 验证缓存命中率要求
      expect(finalStats.l1HitRatio).toBeGreaterThan(0.3); // L1命中率 > 30%
      expect(finalStats.l2HitRatio).toBeGreaterThan(0.6); // L2命中率 > 60%
      
      // 计算综合缓存效率
      const overallHitRatio = Math.max(finalStats.l1HitRatio, finalStats.l2HitRatio, finalStats.l3HitRatio);
      expect(overallHitRatio).toBeGreaterThan(0.5); // 综合命中率 > 50%
    });
  });
});